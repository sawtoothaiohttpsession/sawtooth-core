{"created": 1552990412.7542992, "duration": 2533.2730751037598, "exitcode": 1, "root": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test", "environment": {"Python": "3.6.7", "Platform": "Linux-4.15.0-46-generic-x86_64-with-Ubuntu-18.04-bionic", "Packages": {"pytest": "4.3.1", "py": "1.8.0", "pluggy": "0.9.0"}, "Plugins": {"ordering": "0.6", "metadata": "1.8.0", "json-report": "1.0.3", "aiohttp": "0.3.0"}}, "summary": {"failed": 56, "passed": 75, "error": 9, "total": 140}, "collectors": [{"nodeid": "", "outcome": "passed", "result": [{"nodeid": "dep_txns/test_rest_api_dep_txns.py", "type": "Module"}, {"nodeid": "get/test_rest_api_get_batch.py", "type": "Module"}, {"nodeid": "get/test_rest_api_get_block.py", "type": "Module"}, {"nodeid": "get/test_rest_api_get_peers.py", "type": "Module"}, {"nodeid": "get/test_rest_api_get_receipts.py", "type": "Module"}, {"nodeid": "get/test_rest_api_get_state.py", "type": "Module"}, {"nodeid": "get/test_rest_api_get_transaction.py", "type": "Module"}, {"nodeid": "post/test_rest_api_post.py", "type": "Module"}, {"nodeid": "scenario/test_rest_api_scenario.py", "type": "Module"}]}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies", "outcome": "passed", "result": [{"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_set_inc_txn_dep", "type": "Function", "lineno": 102}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_rest_api_double_dep_txns", "type": "Function", "lineno": 200}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_single_set_dep_txns", "type": "Function", "lineno": 310}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_rest_api_single_set_dec_txns", "type": "Function", "lineno": 421}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_rest_api_set_inc_inc_Txns_Dep", "type": "Function", "lineno": 522}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_rest_api_single_set_dec_same_txns", "type": "Function", "lineno": 632}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_rest_api_single_set_dec_invalid_txns_id", "type": "Function", "lineno": 741}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_single_set_dep_reverse", "type": "Function", "lineno": 849}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_valid_set_invalid_inc_txn_dep", "type": "Function", "lineno": 955}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_valid_set_invalid_inc_DiffKey_txn_dep", "type": "Function", "lineno": 1033}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_set_Max_txn_dep", "type": "Function", "lineno": 1115}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_invalid_set_txn_dep", "type": "Function", "lineno": 1195}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_invalid_Address_txn_dep", "type": "Function", "lineno": 1274}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_Multiple_Indep_Txn_txn_dep", "type": "Function", "lineno": 1377}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_inc_first_txn_dep", "type": "Function", "lineno": 1484}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_Multiple_dep_Txn_Consecutive_dep", "type": "Function", "lineno": 1575}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_Multiple_invalid_dep_Txn_Consecutive_dep", "type": "Function", "lineno": 1678}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_separate_batch_txn_dep", "type": "Function", "lineno": 1782}]}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies", "outcome": "passed", "result": [{"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies", "type": "Instance"}]}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py", "outcome": "passed", "result": [{"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies", "type": "Class"}]}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::test_api_get_batch_list", "type": "Function", "lineno": 92}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::test_api_get_batch_list_head", "type": "Function", "lineno": 134}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::test_api_get_batch_list_bad_head", "type": "Function", "lineno": 170}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::test_api_get_batch_list_id", "type": "Function", "lineno": 186}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::test_api_get_batch_list_bad_id", "type": "Function", "lineno": 225}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::test_api_get_batch_list_head_and_id", "type": "Function", "lineno": 241}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::test_api_get_paginated_batch_list", "type": "Function", "lineno": 280}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::test_api_get_batch_list_limit", "type": "Function", "lineno": 300}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::test_api_get_batch_list_invalid_start", "type": "Function", "lineno": 337}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::test_api_get_batch_list_invalid_limit", "type": "Function", "lineno": 357}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::test_api_get_batch_list_reversed", "type": "Function", "lineno": 376}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::test_api_get_batch_key_params", "type": "Function", "lineno": 417}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::test_api_get_batch_param_link_val", "type": "Function", "lineno": 433}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::test_rest_api_check_batches_count", "type": "Function", "lineno": 453}]}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_batch.py::TestBatchList", "type": "Instance"}]}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchGet", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_batch.py::TestBatchGet::test_api_get_batch_id", "type": "Function", "lineno": 469}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchGet::test_api_get_bad_batch_id", "type": "Function", "lineno": 499}]}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchGet", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_batch.py::TestBatchGet", "type": "Instance"}]}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::test_api_post_batch_status_15ids", "type": "Function", "lineno": 516}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::test_api_post_batch_status_10ids", "type": "Function", "lineno": 534}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::test_api_get_batch_statuses", "type": "Function", "lineno": 552}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::test_api_get_batch_statuses_many_ids", "type": "Function", "lineno": 574}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::test_api_get_batch_statuses_bad_id", "type": "Function", "lineno": 598}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::test_api_get_batch_statuses_invalid_query", "type": "Function", "lineno": 617}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::test_api_get_batch_statuses_wait", "type": "Function", "lineno": 634}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::test_api_get_batch_statuses_invalid", "type": "Function", "lineno": 660}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::test_api_get_batch_statuses_unknown", "type": "Function", "lineno": 681}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::test_api_get_batch_statuses_default_wait", "type": "Function", "lineno": 704}]}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList", "type": "Instance"}]}, {"nodeid": "get/test_rest_api_get_batch.py", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_batch.py::TestBatchList", "type": "Class"}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchGet", "type": "Class"}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList", "type": "Class"}]}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_api_get_block_list", "type": "Function", "lineno": 82}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_api_get_block_list_head", "type": "Function", "lineno": 113}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_api_get_block_list_bad_head", "type": "Function", "lineno": 131}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_api_get_block_list_id", "type": "Function", "lineno": 147}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_api_get_block_list_bad_id", "type": "Function", "lineno": 180}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_api_get_paginated_block_list", "type": "Function", "lineno": 198}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_api_get_block_list_limit", "type": "Function", "lineno": 218}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_api_get_block_list_invalid_start", "type": "Function", "lineno": 246}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_api_get_block_list_invalid_limit", "type": "Function", "lineno": 266}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_api_get_block_list_reversed", "type": "Function", "lineno": 286}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_api_get_block_link_val", "type": "Function", "lineno": 309}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_api_get_block_key_params", "type": "Function", "lineno": 328}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_api_get_each_block_batch_id_length", "type": "Function", "lineno": 344}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_api_get_first_block_id_length", "type": "Function", "lineno": 360}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_rest_api_check_post_max_batches", "type": "Function", "lineno": 378}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_rest_api_check_head_signature", "type": "Function", "lineno": 396}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_rest_api_check_family_version", "type": "Function", "lineno": 414}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_rest_api_check_input_output_content", "type": "Function", "lineno": 431}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_rest_api_check_signer_public_key", "type": "Function", "lineno": 449}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_rest_api_check_blocks_count", "type": "Function", "lineno": 465}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_rest_api_blk_content_head_signature", "type": "Function", "lineno": 480}]}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_block.py::TestBlockList", "type": "Instance"}]}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockGet", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_block.py::TestBlockGet::test_api_get_block_id", "type": "Function", "lineno": 501}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockGet::test_api_get_bad_block_id", "type": "Function", "lineno": 526}]}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockGet", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_block.py::TestBlockGet", "type": "Instance"}]}, {"nodeid": "get/test_rest_api_get_block.py", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_block.py::TestBlockList", "type": "Class"}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockGet", "type": "Class"}]}, {"nodeid": "get/test_rest_api_get_peers.py::TestPeerList", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_peers.py::TestPeerList::test_api_get_peer_list", "type": "Function", "lineno": 49}]}, {"nodeid": "get/test_rest_api_get_peers.py::TestPeerList", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_peers.py::TestPeerList", "type": "Instance"}]}, {"nodeid": "get/test_rest_api_get_peers.py", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_peers.py::TestPeerList", "type": "Class"}]}, {"nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList::test_api_get_reciept_invalid_id", "type": "Function", "lineno": 57}, {"nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList::test_api_get_reciepts_multiple_transactions", "type": "Function", "lineno": 73}, {"nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList::test_api_get_reciepts_single_transactions", "type": "Function", "lineno": 98}, {"nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList::test_api_post_reciepts_single_transactions", "type": "Function", "lineno": 113}, {"nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList::test_api_post_reciepts_invalid_transactions", "type": "Function", "lineno": 130}, {"nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList::test_api_post_reciepts_multiple_transactions", "type": "Function", "lineno": 146}]}, {"nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList", "type": "Instance"}]}, {"nodeid": "get/test_rest_api_get_receipts.py", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList", "type": "Class"}]}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_list", "type": "Function", "lineno": 86}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_list_head", "type": "Function", "lineno": 107}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_list_invalid_batch", "type": "Function", "lineno": 130}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_list_bad_head", "type": "Function", "lineno": 143}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_list_address", "type": "Function", "lineno": 162}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_list_bad_address", "type": "Function", "lineno": 180}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_paginated_state_list", "type": "Function", "lineno": 196}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_paginated_state_list_limit", "type": "Function", "lineno": 216}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_paginated_state_list_start", "type": "Function", "lineno": 234}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_list_bad_paging", "type": "Function", "lineno": 252}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_list_invalid_start", "type": "Function", "lineno": 272}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_list_invalid_limit", "type": "Function", "lineno": 292}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_list_reversed", "type": "Function", "lineno": 311}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_data_address_prefix_namespace", "type": "Function", "lineno": 332}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_data_head_wildcard_character", "type": "Function", "lineno": 349}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_data_head_partial_character", "type": "Function", "lineno": 369}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_data_address_partial_character", "type": "Function", "lineno": 384}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_data_address_length", "type": "Function", "lineno": 400}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_data_address_with_odd_hex_value", "type": "Function", "lineno": 418}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_data_address_with_reduced_length", "type": "Function", "lineno": 436}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_data_address_64_Hex", "type": "Function", "lineno": 454}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_data_address_alter_bytes", "type": "Function", "lineno": 473}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_link_val", "type": "Function", "lineno": 494}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_key_params", "type": "Function", "lineno": 513}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_each_state_head_length", "type": "Function", "lineno": 529}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_rest_api_check_state_count", "type": "Function", "lineno": 545}]}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_state.py::TestStateList", "type": "Instance"}]}, {"nodeid": "get/test_rest_api_get_state.py::TestStateGet", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_state.py::TestStateGet::test_api_get_state_address", "type": "Function", "lineno": 563}, {"nodeid": "get/test_rest_api_get_state.py::TestStateGet::test_api_get_bad_address", "type": "Function", "lineno": 575}]}, {"nodeid": "get/test_rest_api_get_state.py::TestStateGet", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_state.py::TestStateGet", "type": "Instance"}]}, {"nodeid": "get/test_rest_api_get_state.py::TestStateDeleteRoot", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_state.py::TestStateDeleteRoot::test_api_get_state_delete_root", "type": "Function", "lineno": 590}, {"nodeid": "get/test_rest_api_get_state.py::TestStateDeleteRoot::test_api_get_state_delete_not_root_node", "type": "Function", "lineno": 612}]}, {"nodeid": "get/test_rest_api_get_state.py::TestStateDeleteRoot", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_state.py::TestStateDeleteRoot", "type": "Instance"}]}, {"nodeid": "get/test_rest_api_get_state.py", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_state.py::TestStateList", "type": "Class"}, {"nodeid": "get/test_rest_api_get_state.py::TestStateGet", "type": "Class"}, {"nodeid": "get/test_rest_api_get_state.py::TestStateDeleteRoot", "type": "Class"}]}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_transaction_list", "type": "Function", "lineno": 74}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_transaction_list_head", "type": "Function", "lineno": 109}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_transaction_list_bad_head", "type": "Function", "lineno": 142}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_transaction_list_id", "type": "Function", "lineno": 158}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_transaction_list_bad_id", "type": "Function", "lineno": 193}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_transaction_list_head_and_id", "type": "Function", "lineno": 209}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_paginated_transaction_list", "type": "Function", "lineno": 245}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_transaction_list_limit", "type": "Function", "lineno": 267}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_transaction_bad_paging", "type": "Function", "lineno": 305}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_transaction_list_invalid_start", "type": "Function", "lineno": 321}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_transaction_list_invalid_limit", "type": "Function", "lineno": 337}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_transaction_list_reversed", "type": "Function", "lineno": 354}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_transactions_link_val", "type": "Function", "lineno": 385}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_transactions_key_params", "type": "Function", "lineno": 404}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_transaction_id_length", "type": "Function", "lineno": 420}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_rest_api_check_transactions_count", "type": "Function", "lineno": 436}]}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList", "type": "Instance"}]}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionGet", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionGet::test_api_get_transaction_id", "type": "Function", "lineno": 452}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionGet::test_api_get_transaction_bad_id", "type": "Function", "lineno": 479}]}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionGet", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionGet", "type": "Instance"}]}, {"nodeid": "get/test_rest_api_get_transaction.py", "outcome": "passed", "result": [{"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList", "type": "Class"}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionGet", "type": "Class"}]}, {"nodeid": "post/test_rest_api_post.py::TestPostList", "outcome": "passed", "result": [{"nodeid": "post/test_rest_api_post.py::TestPostList::test_rest_api_post_batch", "type": "Function", "lineno": 124}, {"nodeid": "post/test_rest_api_post.py::TestPostList::test_rest_api_no_batches", "type": "Function", "lineno": 206}, {"nodeid": "post/test_rest_api_post.py::TestPostList::test_rest_api_bad_protobuf", "type": "Function", "lineno": 224}, {"nodeid": "post/test_rest_api_post.py::TestPostList::test_rest_api_post_wrong_header", "type": "Function", "lineno": 243}, {"nodeid": "post/test_rest_api_post.py::TestPostList::test_rest_api_post_same_txns", "type": "Function", "lineno": 299}, {"nodeid": "post/test_rest_api_post.py::TestPostList::test_rest_api_multiple_txns_batches", "type": "Function", "lineno": 353}, {"nodeid": "post/test_rest_api_post.py::TestPostList::test_api_post_empty_trxns_list", "type": "Function", "lineno": 436}, {"nodeid": "post/test_rest_api_post.py::TestPostList::test_api_post_batch_different_signer", "type": "Function", "lineno": 456}, {"nodeid": "post/test_rest_api_post.py::TestPostList::test_rest_api_post_no_endpoint", "type": "Function", "lineno": 481}]}, {"nodeid": "post/test_rest_api_post.py::TestPostList", "outcome": "passed", "result": [{"nodeid": "post/test_rest_api_post.py::TestPostList", "type": "Instance"}]}, {"nodeid": "post/test_rest_api_post.py::TestPostInvalidTxns", "outcome": "passed", "result": [{"nodeid": "post/test_rest_api_post.py::TestPostInvalidTxns::test_txn_invalid_addr", "type": "Function", "lineno": 505}, {"nodeid": "post/test_rest_api_post.py::TestPostInvalidTxns::test_txn_invalid_min", "type": "Function", "lineno": 517}, {"nodeid": "post/test_rest_api_post.py::TestPostInvalidTxns::test_txn_invalid_max", "type": "Function", "lineno": 529}, {"nodeid": "post/test_rest_api_post.py::TestPostInvalidTxns::test_txn_valid_invalid_txns", "type": "Function", "lineno": 541}, {"nodeid": "post/test_rest_api_post.py::TestPostInvalidTxns::test_txn_invalid_valid_txns", "type": "Function", "lineno": 553}, {"nodeid": "post/test_rest_api_post.py::TestPostInvalidTxns::test_txn_same_txns", "type": "Function", "lineno": 565}, {"nodeid": "post/test_rest_api_post.py::TestPostInvalidTxns::test_api_sent_commit_txns", "type": "Function", "lineno": 577}, {"nodeid": "post/test_rest_api_post.py::TestPostInvalidTxns::test_txn_invalid_bad_addr", "type": "Function", "lineno": 595}, {"nodeid": "post/test_rest_api_post.py::TestPostInvalidTxns::test_txn_invalid_family_name", "type": "Function", "lineno": 606}]}, {"nodeid": "post/test_rest_api_post.py::TestPostInvalidTxns", "outcome": "passed", "result": [{"nodeid": "post/test_rest_api_post.py::TestPostInvalidTxns", "type": "Instance"}]}, {"nodeid": "post/test_rest_api_post.py", "outcome": "passed", "result": [{"nodeid": "post/test_rest_api_post.py::TestPostList", "type": "Class"}, {"nodeid": "post/test_rest_api_post.py::TestPostInvalidTxns", "type": "Class"}]}, {"nodeid": "scenario/test_rest_api_scenario.py", "outcome": "passed", "result": []}], "tests": [{"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_transaction_list", "lineno": 74, "outcome": "failed", "keywords": ["TestTransactionList", "()", "run", "transactions", "test_api_get_transaction_list", "api_test", "get", "get/test_rest_api_get_transaction.py", "first"], "metadata": {"0": "Tests the transaction list after submitting intkey batches\n        ", "1": "Tests that GET /transactions is reachable with head parameter \n        ", "2": "Tests that GET /transactions is unreachable with bad head parameter \n        ", "3": "Tests that GET /transactions is reachable with id as parameter \n        ", "4": "Tests that GET /transactions is unreachable with bad id parameter \n        ", "5": "Tests GET /transactions is reachable with head and id as parameters \n        ", "6": "Tests GET /transactions is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable using paging parameters \n        ", "8": "Tests GET /transactions is reachbale using bad paging parameters \n        ", "9": "Tests that GET /transactions is unreachable with invalid start parameter \n        ", "10": "Tests that GET /transactions is unreachable with bad limit parameter \n        ", "11": "verifies that GET /transactions with list reversed\n        ", "12": "Tests/ validate the transactions parameters with transactions, head, start and limit\n        ", "13": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "14": "Tests the transaction id length should be 128 hex character long \n        ", "15": "Tests transaction count from transaction list \n        ", "16": "Tests that GET /transactions/{transaction_id} is reachable \n        ", "17": "Tests that GET /transactions/{transaction_id} is not reachable\nwith bad id"}, "setup": {"duration": 300.1920278072357, "outcome": "passed", "log": [{"name": "conftest", "msg": "Starting Setup method for posting batches using intkey as payload", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/conftest.py", "filename": "conftest.py", "module": "conftest", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 36, "funcName": "setup", "created": 1552987879.5881069, "msecs": 588.1068706512451, "relativeCreated": 445.5275535583496, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:01:19"}, {"name": "payload", "msg": "Creating intkey transactions with set operations", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/payload.py", "filename": "payload.py", "module": "payload", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 73, "funcName": "_create_transactions", "created": 1552987879.5904696, "msecs": 590.4695987701416, "relativeCreated": 447.8902816772461, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:01:19"}, {"name": "payload", "msg": "Creating batches for transactions 1trn/batch", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/payload.py", "filename": "payload.py", "module": "payload", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 79, "funcName": "_create_batches", "created": 1552987879.605108, "msecs": 605.1080226898193, "relativeCreated": 462.5287055969238, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:01:19"}, {"name": "payload", "msg": "Gathering expected data before submission of batches", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/payload.py", "filename": "payload.py", "module": "payload", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 168, "funcName": "_expected_data", "created": 1552987879.605403, "msecs": 605.402946472168, "relativeCreated": 462.82362937927246, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:01:19"}, {"name": "payload", "msg": "Calculating the expected count of batches, transactions, state", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/payload.py", "filename": "payload.py", "module": "payload", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 155, "funcName": "_expected_count", "created": 1552987879.605462, "msecs": 605.4620742797852, "relativeCreated": 462.88275718688965, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:01:19"}, {"name": "payload", "msg": "Calculating the initial count of batches,transactions, state before submission of batches", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/payload.py", "filename": "payload.py", "module": "payload", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 146, "funcName": "_initial_count", "created": 1552987879.6055038, "msecs": 605.5037975311279, "relativeCreated": 462.9244804382324, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:01:19"}, {"name": "payload", "msg": "Expected transaction ids", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/payload.py", "filename": "payload.py", "module": "payload", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 111, "funcName": "_expected_txn_ids", "created": 1552987879.632715, "msecs": 632.7149868011475, "relativeCreated": 490.13566970825195, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:01:19"}, {"name": "payload", "msg": "Expected batch ids", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/payload.py", "filename": "payload.py", "module": "payload", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 97, "funcName": "_expected_batch_ids", "created": 1552987879.632968, "msecs": 632.9679489135742, "relativeCreated": 490.3886318206787, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:01:19"}, {"name": "payload", "msg": "Expected transaction ids", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/payload.py", "filename": "payload.py", "module": "payload", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 111, "funcName": "_expected_txn_ids", "created": 1552987879.6330733, "msecs": 633.0733299255371, "relativeCreated": 490.4940128326416, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:01:19"}, {"name": "payload", "msg": "Expected batch ids", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/payload.py", "filename": "payload.py", "module": "payload", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 97, "funcName": "_expected_batch_ids", "created": 1552987879.6331341, "msecs": 633.134126663208, "relativeCreated": 490.5548095703125, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:01:19"}, {"name": "payload", "msg": "Expected batch ids", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/payload.py", "filename": "payload.py", "module": "payload", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 97, "funcName": "_expected_batch_ids", "created": 1552988179.6503036, "msecs": 650.3036022186279, "relativeCreated": 300507.72428512573, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:19"}]}, "call": {"duration": 0.0076715946197509766, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/base.py", "lineno": 284, "message": "AssertionError"}, "traceback": [{"path": "get/test_rest_api_get_transaction.py", "lineno": 104, "message": ""}, {"path": "base.py", "lineno": 284, "message": "AssertionError"}], "longrepr": "self = <test_rest_api_get_transaction.TestTransactionList object at 0x7fd599d1eb00>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_get_transaction_list(self, setup):\n        \"\"\"Tests the transaction list after submitting intkey batches\n        \"\"\"\n        signer_key = setup['signer_key']\n        expected_head = setup['expected_head']\n        expected_txns = setup['expected_txns']\n        expected_length = setup['expected_trn_length']\n        payload = setup['payload']\n        address = setup['address']\n        start = setup['start']\n        limit = setup['limit']\n        start = expected_txns[0]\n    \n        expected_link = '{}/transactions?head={}&start={}&limit={}'.format(address,\\\n                         expected_head, start, limit)\n    \n        paging_link = '{}/transactions?head={}&start={}'.format(address,\\\n                         expected_head, start)\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.get(url='{}/transactions'.format(address)) as data:\n                    response = await data.json()\n        except aiohttp.client_exceptions.ClientResponseError as error:\n            LOGGER.info(\"Rest Api is Unreachable\")\n    \n        txns = response['data'][:-1]\n    \n        self.assert_check_transaction_seq(txns, expected_txns,\n>                                         payload, signer_key)\n\nget/test_rest_api_get_transaction.py:104: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <test_rest_api_get_transaction.TestTransactionList object at 0x7fd599d1eb00>\ntxns = [{'header': {'batcher_public_key': '036cc5e4005ff7cc80bc05164978d724912c7e1aa8e76b4aa024c9255c7c39d753', 'dependencies...d3d95135c282', 'payload': 'CAESOgoec2F3dG9vdGguY29uc2Vuc3VzLnJhZnQucGVyaW9kEgQ2MDAwGhIweDY5ZmUwZWIzY2U2MmFiYWQ='}, ...]\nexpected_ids = ['1cd0f86121acd0cda17a3b3117131df40bef5b57683c81e046aaddb58815583c659c176bc6d078ac0e78d87d41e7f3c3ba8a8ce59d119db680eda70a8012e19d']\npayload = 'o2ROYW1lZ0Fic2Fsb21lVmFsdWUBZFZlcmJjc2V0', signer_key = '03d502ec7556c7ee0418211f27eee91cbb37830adea2d25eb346af742900eb50d0'\n\n    def assert_check_transaction_seq(self, txns, expected_ids,\n                                     payload, signer_key):\n        \"\"\"Asserts transactions are constructed properly\n        \"\"\"\n        if not isinstance(txns, list):\n                txns = [txns]\n    \n        if not isinstance(expected_ids, list):\n                expected_ids = [expected_ids]\n    \n        if not isinstance(payload, list):\n                payload = [payload]\n    \n    \n        for txn, expected_id, payload in zip(txns, expected_ids, payload):\n>           assert expected_id == txn['header_signature']\nE           AssertionError\n\nbase.py:284: AssertionError"}, "teardown": {"duration": 0.0002841949462890625, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_transaction_list_head", "lineno": 109, "outcome": "failed", "keywords": ["TestTransactionList", "()", "test_api_get_transaction_list_head", "run", "transactions", "api_test", "get", "get/test_rest_api_get_transaction.py", "first"], "metadata": {"0": "Tests the transaction list after submitting intkey batches\n        ", "1": "Tests that GET /transactions is reachable with head parameter \n        ", "2": "Tests that GET /transactions is unreachable with bad head parameter \n        ", "3": "Tests that GET /transactions is reachable with id as parameter \n        ", "4": "Tests that GET /transactions is unreachable with bad id parameter \n        ", "5": "Tests GET /transactions is reachable with head and id as parameters \n        ", "6": "Tests GET /transactions is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable using paging parameters \n        ", "8": "Tests GET /transactions is reachbale using bad paging parameters \n        ", "9": "Tests that GET /transactions is unreachable with invalid start parameter \n        ", "10": "Tests that GET /transactions is unreachable with bad limit parameter \n        ", "11": "verifies that GET /transactions with list reversed\n        ", "12": "Tests/ validate the transactions parameters with transactions, head, start and limit\n        ", "13": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "14": "Tests the transaction id length should be 128 hex character long \n        ", "15": "Tests transaction count from transaction list \n        ", "16": "Tests that GET /transactions/{transaction_id} is reachable \n        ", "17": "Tests that GET /transactions/{transaction_id} is not reachable\nwith bad id"}, "setup": {"duration": 0.00045752525329589844, "outcome": "passed"}, "call": {"duration": 0.006151676177978516, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/base.py", "lineno": 284, "message": "AssertionError"}, "traceback": [{"path": "get/test_rest_api_get_transaction.py", "lineno": 138, "message": ""}, {"path": "base.py", "lineno": 284, "message": "AssertionError"}], "log": [{"name": "test_rest_api_get_transaction", "msg": "Starting test for transactions with head parameter", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_transaction.py", "filename": "test_rest_api_get_transaction.py", "module": "test_rest_api_get_transaction", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 113, "funcName": "test_api_get_transaction_list_head", "created": 1552988179.8288732, "msecs": 828.8731575012207, "relativeCreated": 300686.2938404083, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:19"}], "longrepr": "self = <test_rest_api_get_transaction.TestTransactionList object at 0x7fd599b7d278>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_get_transaction_list_head(self, setup):\n        \"\"\"Tests that GET /transactions is reachable with head parameter\n        \"\"\"\n        LOGGER.info(\"Starting test for transactions with head parameter\")\n        signer_key = setup['signer_key']\n        expected_head = setup['expected_head']\n        expected_txns = setup['expected_txns']\n        expected_length = setup['expected_trn_length']\n        payload = setup['payload'][0]\n        address = setup['address']\n        start = expected_txns[0]\n        limit = setup['limit']\n    \n        expected_link = '{}/transactions?head={}&start={}&limit={}'.format(address,\\\n                         expected_head, start, limit)\n    \n        params={'head': expected_head}\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.get(url='{}/transactions'.format(address), params=params) as data:\n                    response = await data.json()\n        except aiohttp.client_exceptions.ClientResponseError as error:\n            LOGGER.info(\"Rest Api is Unreachable\")\n    \n        txns = response['data'][:-1]\n    \n        self.assert_check_transaction_seq(txns, expected_txns,\n>                                         payload, signer_key)\n\nget/test_rest_api_get_transaction.py:138: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <test_rest_api_get_transaction.TestTransactionList object at 0x7fd599b7d278>\ntxns = [{'header': {'batcher_public_key': '036cc5e4005ff7cc80bc05164978d724912c7e1aa8e76b4aa024c9255c7c39d753', 'dependencies...d3d95135c282', 'payload': 'CAESOgoec2F3dG9vdGguY29uc2Vuc3VzLnJhZnQucGVyaW9kEgQ2MDAwGhIweDY5ZmUwZWIzY2U2MmFiYWQ='}, ...]\nexpected_ids = ['1cd0f86121acd0cda17a3b3117131df40bef5b57683c81e046aaddb58815583c659c176bc6d078ac0e78d87d41e7f3c3ba8a8ce59d119db680eda70a8012e19d']\npayload = 'o2ROYW1lZ0Fic2Fsb21lVmFsdWUBZFZlcmJjc2V0', signer_key = '03d502ec7556c7ee0418211f27eee91cbb37830adea2d25eb346af742900eb50d0'\n\n    def assert_check_transaction_seq(self, txns, expected_ids,\n                                     payload, signer_key):\n        \"\"\"Asserts transactions are constructed properly\n        \"\"\"\n        if not isinstance(txns, list):\n                txns = [txns]\n    \n        if not isinstance(expected_ids, list):\n                expected_ids = [expected_ids]\n    \n        if not isinstance(payload, list):\n                payload = [payload]\n    \n    \n        for txn, expected_id, payload in zip(txns, expected_ids, payload):\n>           assert expected_id == txn['header_signature']\nE           AssertionError\n\nbase.py:284: AssertionError"}, "teardown": {"duration": 0.00025963783264160156, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_transaction_list_bad_head", "lineno": 142, "outcome": "passed", "keywords": ["TestTransactionList", "()", "run", "transactions", "api_test", "get", "get/test_rest_api_get_transaction.py", "first", "test_api_get_transaction_list_bad_head"], "metadata": {"0": "Tests the transaction list after submitting intkey batches\n        ", "1": "Tests that GET /transactions is reachable with head parameter \n        ", "2": "Tests that GET /transactions is unreachable with bad head parameter \n        ", "3": "Tests that GET /transactions is reachable with id as parameter \n        ", "4": "Tests that GET /transactions is unreachable with bad id parameter \n        ", "5": "Tests GET /transactions is reachable with head and id as parameters \n        ", "6": "Tests GET /transactions is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable using paging parameters \n        ", "8": "Tests GET /transactions is reachbale using bad paging parameters \n        ", "9": "Tests that GET /transactions is unreachable with invalid start parameter \n        ", "10": "Tests that GET /transactions is unreachable with bad limit parameter \n        ", "11": "verifies that GET /transactions with list reversed\n        ", "12": "Tests/ validate the transactions parameters with transactions, head, start and limit\n        ", "13": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "14": "Tests the transaction id length should be 128 hex character long \n        ", "15": "Tests transaction count from transaction list \n        ", "16": "Tests that GET /transactions/{transaction_id} is reachable \n        ", "17": "Tests that GET /transactions/{transaction_id} is not reachable\nwith bad id"}, "setup": {"duration": 0.0004513263702392578, "outcome": "passed"}, "call": {"duration": 0.015633106231689453, "outcome": "passed", "log": [{"name": "test_rest_api_get_transaction", "msg": "Starting test for transactions with bad head parameter", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_transaction.py", "filename": "test_rest_api_get_transaction.py", "module": "test_rest_api_get_transaction", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 146, "funcName": "test_api_get_transaction_list_bad_head", "created": 1552988179.8492146, "msecs": 849.2145538330078, "relativeCreated": 300706.6352367401, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:19"}]}, "teardown": {"duration": 0.0002415180206298828, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_transaction_list_id", "lineno": 158, "outcome": "passed", "keywords": ["TestTransactionList", "()", "run", "transactions", "api_test", "get", "get/test_rest_api_get_transaction.py", "first", "test_api_get_transaction_list_id"], "metadata": {"0": "Tests the transaction list after submitting intkey batches\n        ", "1": "Tests that GET /transactions is reachable with head parameter \n        ", "2": "Tests that GET /transactions is unreachable with bad head parameter \n        ", "3": "Tests that GET /transactions is reachable with id as parameter \n        ", "4": "Tests that GET /transactions is unreachable with bad id parameter \n        ", "5": "Tests GET /transactions is reachable with head and id as parameters \n        ", "6": "Tests GET /transactions is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable using paging parameters \n        ", "8": "Tests GET /transactions is reachbale using bad paging parameters \n        ", "9": "Tests that GET /transactions is unreachable with invalid start parameter \n        ", "10": "Tests that GET /transactions is unreachable with bad limit parameter \n        ", "11": "verifies that GET /transactions with list reversed\n        ", "12": "Tests/ validate the transactions parameters with transactions, head, start and limit\n        ", "13": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "14": "Tests the transaction id length should be 128 hex character long \n        ", "15": "Tests transaction count from transaction list \n        ", "16": "Tests that GET /transactions/{transaction_id} is reachable \n        ", "17": "Tests that GET /transactions/{transaction_id} is not reachable\nwith bad id"}, "setup": {"duration": 0.00043773651123046875, "outcome": "passed"}, "call": {"duration": 0.016901731491088867, "outcome": "passed", "log": [{"name": "test_rest_api_get_transaction", "msg": "Starting test for transactions with id parameter", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_transaction.py", "filename": "test_rest_api_get_transaction.py", "module": "test_rest_api_get_transaction", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 162, "funcName": "test_api_get_transaction_list_id", "created": 1552988179.8662875, "msecs": 866.2874698638916, "relativeCreated": 300723.708152771, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:19"}]}, "teardown": {"duration": 0.00024437904357910156, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_transaction_list_bad_id", "lineno": 193, "outcome": "passed", "keywords": ["TestTransactionList", "()", "run", "get", "transactions", "api_test", "test_api_get_transaction_list_bad_id", "get/test_rest_api_get_transaction.py", "first"], "metadata": {"0": "Tests the transaction list after submitting intkey batches\n        ", "1": "Tests that GET /transactions is reachable with head parameter \n        ", "2": "Tests that GET /transactions is unreachable with bad head parameter \n        ", "3": "Tests that GET /transactions is reachable with id as parameter \n        ", "4": "Tests that GET /transactions is unreachable with bad id parameter \n        ", "5": "Tests GET /transactions is reachable with head and id as parameters \n        ", "6": "Tests GET /transactions is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable using paging parameters \n        ", "8": "Tests GET /transactions is reachbale using bad paging parameters \n        ", "9": "Tests that GET /transactions is unreachable with invalid start parameter \n        ", "10": "Tests that GET /transactions is unreachable with bad limit parameter \n        ", "11": "verifies that GET /transactions with list reversed\n        ", "12": "Tests/ validate the transactions parameters with transactions, head, start and limit\n        ", "13": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "14": "Tests the transaction id length should be 128 hex character long \n        ", "15": "Tests transaction count from transaction list \n        ", "16": "Tests that GET /transactions/{transaction_id} is reachable \n        ", "17": "Tests that GET /transactions/{transaction_id} is not reachable\nwith bad id"}, "setup": {"duration": 0.0004420280456542969, "outcome": "passed"}, "call": {"duration": 0.013870477676391602, "outcome": "passed", "log": [{"name": "test_rest_api_get_transaction", "msg": "Starting test for transactions with bad id parameter", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_transaction.py", "filename": "test_rest_api_get_transaction.py", "module": "test_rest_api_get_transaction", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 197, "funcName": "test_api_get_transaction_list_bad_id", "created": 1552988179.8847067, "msecs": 884.7067356109619, "relativeCreated": 300742.12741851807, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:19"}]}, "teardown": {"duration": 0.0002586841583251953, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_transaction_list_head_and_id", "lineno": 209, "outcome": "passed", "keywords": ["TestTransactionList", "test_api_get_transaction_list_head_and_id", "()", "run", "transactions", "api_test", "get", "get/test_rest_api_get_transaction.py", "first"], "metadata": {"0": "Tests the transaction list after submitting intkey batches\n        ", "1": "Tests that GET /transactions is reachable with head parameter \n        ", "2": "Tests that GET /transactions is unreachable with bad head parameter \n        ", "3": "Tests that GET /transactions is reachable with id as parameter \n        ", "4": "Tests that GET /transactions is unreachable with bad id parameter \n        ", "5": "Tests GET /transactions is reachable with head and id as parameters \n        ", "6": "Tests GET /transactions is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable using paging parameters \n        ", "8": "Tests GET /transactions is reachbale using bad paging parameters \n        ", "9": "Tests that GET /transactions is unreachable with invalid start parameter \n        ", "10": "Tests that GET /transactions is unreachable with bad limit parameter \n        ", "11": "verifies that GET /transactions with list reversed\n        ", "12": "Tests/ validate the transactions parameters with transactions, head, start and limit\n        ", "13": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "14": "Tests the transaction id length should be 128 hex character long \n        ", "15": "Tests transaction count from transaction list \n        ", "16": "Tests that GET /transactions/{transaction_id} is reachable \n        ", "17": "Tests that GET /transactions/{transaction_id} is not reachable\nwith bad id"}, "setup": {"duration": 0.0004470348358154297, "outcome": "passed"}, "call": {"duration": 0.01721024513244629, "outcome": "passed", "log": [{"name": "test_rest_api_get_transaction", "msg": "Starting test for transactions with head and id parameter", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_transaction.py", "filename": "test_rest_api_get_transaction.py", "module": "test_rest_api_get_transaction", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 213, "funcName": "test_api_get_transaction_list_head_and_id", "created": 1552988179.9001405, "msecs": 900.1405239105225, "relativeCreated": 300757.5612068176, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:19"}]}, "teardown": {"duration": 0.0002551078796386719, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_paginated_transaction_list", "lineno": 245, "outcome": "passed", "keywords": ["TestTransactionList", "()", "run", "test_api_get_paginated_transaction_list", "transactions", "api_test", "get", "get/test_rest_api_get_transaction.py", "first"], "metadata": {"0": "Tests the transaction list after submitting intkey batches\n        ", "1": "Tests that GET /transactions is reachable with head parameter \n        ", "2": "Tests that GET /transactions is unreachable with bad head parameter \n        ", "3": "Tests that GET /transactions is reachable with id as parameter \n        ", "4": "Tests that GET /transactions is unreachable with bad id parameter \n        ", "5": "Tests GET /transactions is reachable with head and id as parameters \n        ", "6": "Tests GET /transactions is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable using paging parameters \n        ", "8": "Tests GET /transactions is reachbale using bad paging parameters \n        ", "9": "Tests that GET /transactions is unreachable with invalid start parameter \n        ", "10": "Tests that GET /transactions is unreachable with bad limit parameter \n        ", "11": "verifies that GET /transactions with list reversed\n        ", "12": "Tests/ validate the transactions parameters with transactions, head, start and limit\n        ", "13": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "14": "Tests the transaction id length should be 128 hex character long \n        ", "15": "Tests transaction count from transaction list \n        ", "16": "Tests that GET /transactions/{transaction_id} is reachable \n        ", "17": "Tests that GET /transactions/{transaction_id} is not reachable\nwith bad id"}, "setup": {"duration": 0.0004627704620361328, "outcome": "passed"}, "call": {"duration": 0.01745152473449707, "outcome": "passed", "log": [{"name": "test_rest_api_get_transaction", "msg": "Starting test for transactions with paging parameters", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_transaction.py", "filename": "test_rest_api_get_transaction.py", "module": "test_rest_api_get_transaction", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 249, "funcName": "test_api_get_paginated_transaction_list", "created": 1552988179.918934, "msecs": 918.9341068267822, "relativeCreated": 300776.3547897339, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:19"}]}, "teardown": {"duration": 0.0003273487091064453, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_transaction_list_limit", "lineno": 267, "outcome": "failed", "keywords": ["test_api_get_transaction_list_limit", "TestTransactionList", "()", "run", "transactions", "api_test", "get", "get/test_rest_api_get_transaction.py", "first"], "metadata": {"0": "Tests the transaction list after submitting intkey batches\n        ", "1": "Tests that GET /transactions is reachable with head parameter \n        ", "2": "Tests that GET /transactions is unreachable with bad head parameter \n        ", "3": "Tests that GET /transactions is reachable with id as parameter \n        ", "4": "Tests that GET /transactions is unreachable with bad id parameter \n        ", "5": "Tests GET /transactions is reachable with head and id as parameters \n        ", "6": "Tests GET /transactions is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable using paging parameters \n        ", "8": "Tests GET /transactions is reachbale using bad paging parameters \n        ", "9": "Tests that GET /transactions is unreachable with invalid start parameter \n        ", "10": "Tests that GET /transactions is unreachable with bad limit parameter \n        ", "11": "verifies that GET /transactions with list reversed\n        ", "12": "Tests/ validate the transactions parameters with transactions, head, start and limit\n        ", "13": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "14": "Tests the transaction id length should be 128 hex character long \n        ", "15": "Tests transaction count from transaction list \n        ", "16": "Tests that GET /transactions/{transaction_id} is reachable \n        ", "17": "Tests that GET /transactions/{transaction_id} is not reachable\nwith bad id"}, "setup": {"duration": 0.0004711151123046875, "outcome": "passed"}, "call": {"duration": 0.005624294281005859, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/base.py", "lineno": 145, "message": "AssertionError"}, "traceback": [{"path": "get/test_rest_api_get_transaction.py", "lineno": 303, "message": ""}, {"path": "base.py", "lineno": 145, "message": "AssertionError"}], "log": [{"name": "test_rest_api_get_transaction", "msg": "Starting test for batch with paging parameters", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_transaction.py", "filename": "test_rest_api_get_transaction.py", "module": "test_rest_api_get_transaction", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 271, "funcName": "test_api_get_transaction_list_limit", "created": 1552988179.9381604, "msecs": 938.1604194641113, "relativeCreated": 300795.5811023712, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:19"}], "longrepr": "self = <test_rest_api_get_transaction.TestTransactionList object at 0x7fd599d1ec50>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_get_transaction_list_limit(self, setup):\n        \"\"\"Tests GET /batches is reachable using paging parameters\n        \"\"\"\n        LOGGER.info(\"Starting test for batch with paging parameters\")\n        signer_key = setup['signer_key']\n        expected_head = setup['expected_head']\n        expected_txns = setup['expected_txns']\n        expected_length = setup['expected_trn_length']\n        payload = setup['payload'][0]\n        address = setup['address']\n        start = expected_txns[0]\n        transaction_ids   =  setup['transaction_ids']\n        expected_id = transaction_ids[0]\n        expected_length = len([expected_id])\n        limit = setup['limit']\n    \n        params={'limit':1}\n    \n        expected_link = '{}/transactions?head={}&start={}&limit={}'.format(address,\\\n                         expected_head, start, 1)\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.get(url='{}/transactions'.format(address), params=params) as data:\n                    response = await data.json()\n        except aiohttp.client_exceptions.ClientResponseError as error:\n            LOGGER.info(\"Rest Api is Unreachable\")\n    \n    \n        txns = response['data'][:-1]\n    \n        self.assert_check_transaction_seq(txns, expected_txns,\n                                          payload, signer_key)\n    \n        self.assert_valid_head(response, expected_head)\n>       self.assert_valid_link(response, expected_link)\n\nget/test_rest_api_get_transaction.py:303: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <test_rest_api_get_transaction.TestTransactionList object at 0x7fd599d1ec50>\nresponse = {'data': [{'header': {'batcher_public_key': '036cc5e4005ff7cc80bc05164978d724912c7e1aa8e76b4aa024c9255c7c39d753', 'dep...2be56df60ee130bcdcf8f22147334143c432b427be31a0a25e6bbe36557ce2fb669cd89bc6f84d584eff700174679b6064241', 'start': None}}\nexpected_link = 'http://192.168.1.23:8008/transactions?head=c6fd3eead81d509e46564beda332ce517415879b75c1fcf6c179b7e981c1cf930bb23f51d3...7a3b3117131df40bef5b57683c81e046aaddb58815583c659c176bc6d078ac0e78d87d41e7f3c3ba8a8ce59d119db680eda70a8012e19d&limit=1'\n\n    def assert_valid_link(self, response, expected_link):\n        \"\"\"Asserts a response has a link url string with an\n           expected ending\n        \"\"\"\n        print(response['link'])\n        print(expected_link)\n        assert 'link' in response\n>       assert response['link'] == expected_link\nE       AssertionError\n\nbase.py:145: AssertionError"}, "teardown": {"duration": 0.0002505779266357422, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_transaction_bad_paging", "lineno": 305, "outcome": "passed", "keywords": ["TestTransactionList", "()", "test_api_get_transaction_bad_paging", "run", "transactions", "api_test", "get", "get/test_rest_api_get_transaction.py", "first"], "metadata": {"0": "Tests the transaction list after submitting intkey batches\n        ", "1": "Tests that GET /transactions is reachable with head parameter \n        ", "2": "Tests that GET /transactions is unreachable with bad head parameter \n        ", "3": "Tests that GET /transactions is reachable with id as parameter \n        ", "4": "Tests that GET /transactions is unreachable with bad id parameter \n        ", "5": "Tests GET /transactions is reachable with head and id as parameters \n        ", "6": "Tests GET /transactions is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable using paging parameters \n        ", "8": "Tests GET /transactions is reachbale using bad paging parameters \n        ", "9": "Tests that GET /transactions is unreachable with invalid start parameter \n        ", "10": "Tests that GET /transactions is unreachable with bad limit parameter \n        ", "11": "verifies that GET /transactions with list reversed\n        ", "12": "Tests/ validate the transactions parameters with transactions, head, start and limit\n        ", "13": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "14": "Tests the transaction id length should be 128 hex character long \n        ", "15": "Tests transaction count from transaction list \n        ", "16": "Tests that GET /transactions/{transaction_id} is reachable \n        ", "17": "Tests that GET /transactions/{transaction_id} is not reachable\nwith bad id"}, "setup": {"duration": 0.0004363059997558594, "outcome": "passed"}, "call": {"duration": 0.014420747756958008, "outcome": "passed", "log": [{"name": "test_rest_api_get_transaction", "msg": "Starting test for transactions with bad paging parameters", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_transaction.py", "filename": "test_rest_api_get_transaction.py", "module": "test_rest_api_get_transaction", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 309, "funcName": "test_api_get_transaction_bad_paging", "created": 1552988179.9579346, "msecs": 957.9346179962158, "relativeCreated": 300815.3553009033, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:19"}]}, "teardown": {"duration": 0.00023746490478515625, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_transaction_list_invalid_start", "lineno": 321, "outcome": "passed", "keywords": ["TestTransactionList", "()", "run", "transactions", "test_api_get_transaction_list_invalid_start", "api_test", "get", "get/test_rest_api_get_transaction.py", "first"], "metadata": {"0": "Tests the transaction list after submitting intkey batches\n        ", "1": "Tests that GET /transactions is reachable with head parameter \n        ", "2": "Tests that GET /transactions is unreachable with bad head parameter \n        ", "3": "Tests that GET /transactions is reachable with id as parameter \n        ", "4": "Tests that GET /transactions is unreachable with bad id parameter \n        ", "5": "Tests GET /transactions is reachable with head and id as parameters \n        ", "6": "Tests GET /transactions is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable using paging parameters \n        ", "8": "Tests GET /transactions is reachbale using bad paging parameters \n        ", "9": "Tests that GET /transactions is unreachable with invalid start parameter \n        ", "10": "Tests that GET /transactions is unreachable with bad limit parameter \n        ", "11": "verifies that GET /transactions with list reversed\n        ", "12": "Tests/ validate the transactions parameters with transactions, head, start and limit\n        ", "13": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "14": "Tests the transaction id length should be 128 hex character long \n        ", "15": "Tests transaction count from transaction list \n        ", "16": "Tests that GET /transactions/{transaction_id} is reachable \n        ", "17": "Tests that GET /transactions/{transaction_id} is not reachable\nwith bad id"}, "setup": {"duration": 0.0004429817199707031, "outcome": "passed"}, "call": {"duration": 0.017349720001220703, "outcome": "passed", "log": [{"name": "test_rest_api_get_transaction", "msg": "Starting test for transactions with invalid start parameter", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_transaction.py", "filename": "test_rest_api_get_transaction.py", "module": "test_rest_api_get_transaction", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 325, "funcName": "test_api_get_transaction_list_invalid_start", "created": 1552988179.973785, "msecs": 973.7849235534668, "relativeCreated": 300831.2056064606, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:19"}]}, "teardown": {"duration": 0.0002396106719970703, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_transaction_list_invalid_limit", "lineno": 337, "outcome": "passed", "keywords": ["TestTransactionList", "()", "run", "test_api_get_transaction_list_invalid_limit", "transactions", "api_test", "get", "get/test_rest_api_get_transaction.py", "first"], "metadata": {"0": "Tests the transaction list after submitting intkey batches\n        ", "1": "Tests that GET /transactions is reachable with head parameter \n        ", "2": "Tests that GET /transactions is unreachable with bad head parameter \n        ", "3": "Tests that GET /transactions is reachable with id as parameter \n        ", "4": "Tests that GET /transactions is unreachable with bad id parameter \n        ", "5": "Tests GET /transactions is reachable with head and id as parameters \n        ", "6": "Tests GET /transactions is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable using paging parameters \n        ", "8": "Tests GET /transactions is reachbale using bad paging parameters \n        ", "9": "Tests that GET /transactions is unreachable with invalid start parameter \n        ", "10": "Tests that GET /transactions is unreachable with bad limit parameter \n        ", "11": "verifies that GET /transactions with list reversed\n        ", "12": "Tests/ validate the transactions parameters with transactions, head, start and limit\n        ", "13": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "14": "Tests the transaction id length should be 128 hex character long \n        ", "15": "Tests transaction count from transaction list \n        ", "16": "Tests that GET /transactions/{transaction_id} is reachable \n        ", "17": "Tests that GET /transactions/{transaction_id} is not reachable\nwith bad id"}, "setup": {"duration": 0.00043964385986328125, "outcome": "passed"}, "call": {"duration": 0.014333248138427734, "outcome": "passed", "log": [{"name": "test_rest_api_get_transaction", "msg": "Starting test for transactions with bad limit parameter", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_transaction.py", "filename": "test_rest_api_get_transaction.py", "module": "test_rest_api_get_transaction", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 341, "funcName": "test_api_get_transaction_list_invalid_limit", "created": 1552988179.9926412, "msecs": 992.6412105560303, "relativeCreated": 300850.06189346313, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:19"}]}, "teardown": {"duration": 0.0002460479736328125, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_transaction_list_reversed", "lineno": 354, "outcome": "passed", "keywords": ["test_api_get_transaction_list_reversed", "TestTransactionList", "()", "run", "transactions", "api_test", "get", "get/test_rest_api_get_transaction.py", "first"], "metadata": {"0": "Tests the transaction list after submitting intkey batches\n        ", "1": "Tests that GET /transactions is reachable with head parameter \n        ", "2": "Tests that GET /transactions is unreachable with bad head parameter \n        ", "3": "Tests that GET /transactions is reachable with id as parameter \n        ", "4": "Tests that GET /transactions is unreachable with bad id parameter \n        ", "5": "Tests GET /transactions is reachable with head and id as parameters \n        ", "6": "Tests GET /transactions is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable using paging parameters \n        ", "8": "Tests GET /transactions is reachbale using bad paging parameters \n        ", "9": "Tests that GET /transactions is unreachable with invalid start parameter \n        ", "10": "Tests that GET /transactions is unreachable with bad limit parameter \n        ", "11": "verifies that GET /transactions with list reversed\n        ", "12": "Tests/ validate the transactions parameters with transactions, head, start and limit\n        ", "13": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "14": "Tests the transaction id length should be 128 hex character long \n        ", "15": "Tests transaction count from transaction list \n        ", "16": "Tests that GET /transactions/{transaction_id} is reachable \n        ", "17": "Tests that GET /transactions/{transaction_id} is not reachable\nwith bad id"}, "setup": {"duration": 0.0004508495330810547, "outcome": "passed"}, "call": {"duration": 0.019181013107299805, "outcome": "passed", "log": [{"name": "test_rest_api_get_transaction", "msg": "Starting test for transactions with list reversed", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_transaction.py", "filename": "test_rest_api_get_transaction.py", "module": "test_rest_api_get_transaction", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 358, "funcName": "test_api_get_transaction_list_reversed", "created": 1552988180.008479, "msecs": 8.479118347167969, "relativeCreated": 300865.8998012543, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:20"}]}, "teardown": {"duration": 0.00026488304138183594, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_transactions_link_val", "lineno": 385, "outcome": "passed", "keywords": ["TestTransactionList", "()", "run", "transactions", "test_api_get_transactions_link_val", "api_test", "get", "get/test_rest_api_get_transaction.py", "first"], "metadata": {"0": "Tests the transaction list after submitting intkey batches\n        ", "1": "Tests that GET /transactions is reachable with head parameter \n        ", "2": "Tests that GET /transactions is unreachable with bad head parameter \n        ", "3": "Tests that GET /transactions is reachable with id as parameter \n        ", "4": "Tests that GET /transactions is unreachable with bad id parameter \n        ", "5": "Tests GET /transactions is reachable with head and id as parameters \n        ", "6": "Tests GET /transactions is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable using paging parameters \n        ", "8": "Tests GET /transactions is reachbale using bad paging parameters \n        ", "9": "Tests that GET /transactions is unreachable with invalid start parameter \n        ", "10": "Tests that GET /transactions is unreachable with bad limit parameter \n        ", "11": "verifies that GET /transactions with list reversed\n        ", "12": "Tests/ validate the transactions parameters with transactions, head, start and limit\n        ", "13": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "14": "Tests the transaction id length should be 128 hex character long \n        ", "15": "Tests transaction count from transaction list \n        ", "16": "Tests that GET /transactions/{transaction_id} is reachable \n        ", "17": "Tests that GET /transactions/{transaction_id} is not reachable\nwith bad id"}, "setup": {"duration": 0.0004565715789794922, "outcome": "passed"}, "call": {"duration": 0.018403053283691406, "outcome": "passed"}, "teardown": {"duration": 0.0002391338348388672, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_transactions_key_params", "lineno": 404, "outcome": "passed", "keywords": ["TestTransactionList", "()", "run", "transactions", "test_api_get_transactions_key_params", "api_test", "get", "get/test_rest_api_get_transaction.py", "first"], "metadata": {"0": "Tests the transaction list after submitting intkey batches\n        ", "1": "Tests that GET /transactions is reachable with head parameter \n        ", "2": "Tests that GET /transactions is unreachable with bad head parameter \n        ", "3": "Tests that GET /transactions is reachable with id as parameter \n        ", "4": "Tests that GET /transactions is unreachable with bad id parameter \n        ", "5": "Tests GET /transactions is reachable with head and id as parameters \n        ", "6": "Tests GET /transactions is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable using paging parameters \n        ", "8": "Tests GET /transactions is reachbale using bad paging parameters \n        ", "9": "Tests that GET /transactions is unreachable with invalid start parameter \n        ", "10": "Tests that GET /transactions is unreachable with bad limit parameter \n        ", "11": "verifies that GET /transactions with list reversed\n        ", "12": "Tests/ validate the transactions parameters with transactions, head, start and limit\n        ", "13": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "14": "Tests the transaction id length should be 128 hex character long \n        ", "15": "Tests transaction count from transaction list \n        ", "16": "Tests that GET /transactions/{transaction_id} is reachable \n        ", "17": "Tests that GET /transactions/{transaction_id} is not reachable\nwith bad id"}, "setup": {"duration": 0.0004322528839111328, "outcome": "passed"}, "call": {"duration": 0.018454790115356445, "outcome": "passed"}, "teardown": {"duration": 0.00024175643920898438, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_api_get_transaction_id_length", "lineno": 420, "outcome": "passed", "keywords": ["TestTransactionList", "()", "run", "transactions", "test_api_get_transaction_id_length", "api_test", "get", "get/test_rest_api_get_transaction.py", "first"], "metadata": {"0": "Tests the transaction list after submitting intkey batches\n        ", "1": "Tests that GET /transactions is reachable with head parameter \n        ", "2": "Tests that GET /transactions is unreachable with bad head parameter \n        ", "3": "Tests that GET /transactions is reachable with id as parameter \n        ", "4": "Tests that GET /transactions is unreachable with bad id parameter \n        ", "5": "Tests GET /transactions is reachable with head and id as parameters \n        ", "6": "Tests GET /transactions is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable using paging parameters \n        ", "8": "Tests GET /transactions is reachbale using bad paging parameters \n        ", "9": "Tests that GET /transactions is unreachable with invalid start parameter \n        ", "10": "Tests that GET /transactions is unreachable with bad limit parameter \n        ", "11": "verifies that GET /transactions with list reversed\n        ", "12": "Tests/ validate the transactions parameters with transactions, head, start and limit\n        ", "13": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "14": "Tests the transaction id length should be 128 hex character long \n        ", "15": "Tests transaction count from transaction list \n        ", "16": "Tests that GET /transactions/{transaction_id} is reachable \n        ", "17": "Tests that GET /transactions/{transaction_id} is not reachable\nwith bad id"}, "setup": {"duration": 0.00045228004455566406, "outcome": "passed"}, "call": {"duration": 0.018413782119750977, "outcome": "passed"}, "teardown": {"duration": 0.0002474784851074219, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionList::test_rest_api_check_transactions_count", "lineno": 436, "outcome": "passed", "keywords": ["TestTransactionList", "()", "run", "transactions", "get/test_rest_api_get_transaction.py", "api_test", "get", "test_rest_api_check_transactions_count", "first"], "metadata": {"0": "Tests the transaction list after submitting intkey batches\n        ", "1": "Tests that GET /transactions is reachable with head parameter \n        ", "2": "Tests that GET /transactions is unreachable with bad head parameter \n        ", "3": "Tests that GET /transactions is reachable with id as parameter \n        ", "4": "Tests that GET /transactions is unreachable with bad id parameter \n        ", "5": "Tests GET /transactions is reachable with head and id as parameters \n        ", "6": "Tests GET /transactions is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable using paging parameters \n        ", "8": "Tests GET /transactions is reachbale using bad paging parameters \n        ", "9": "Tests that GET /transactions is unreachable with invalid start parameter \n        ", "10": "Tests that GET /transactions is unreachable with bad limit parameter \n        ", "11": "verifies that GET /transactions with list reversed\n        ", "12": "Tests/ validate the transactions parameters with transactions, head, start and limit\n        ", "13": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "14": "Tests the transaction id length should be 128 hex character long \n        ", "15": "Tests transaction count from transaction list \n        ", "16": "Tests that GET /transactions/{transaction_id} is reachable \n        ", "17": "Tests that GET /transactions/{transaction_id} is not reachable\nwith bad id"}, "setup": {"duration": 0.0004565715789794922, "outcome": "passed"}, "call": {"duration": 0.018398046493530273, "outcome": "passed"}, "teardown": {"duration": 0.0002467632293701172, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionGet::test_api_get_transaction_id", "lineno": 452, "outcome": "failed", "keywords": ["()", "test_api_get_transaction_id", "api_test", "run", "transactions", "TestTransactionGet", "get", "get/test_rest_api_get_transaction.py", "first"], "metadata": {"0": "Tests the transaction list after submitting intkey batches\n        ", "1": "Tests that GET /transactions is reachable with head parameter \n        ", "2": "Tests that GET /transactions is unreachable with bad head parameter \n        ", "3": "Tests that GET /transactions is reachable with id as parameter \n        ", "4": "Tests that GET /transactions is unreachable with bad id parameter \n        ", "5": "Tests GET /transactions is reachable with head and id as parameters \n        ", "6": "Tests GET /transactions is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable using paging parameters \n        ", "8": "Tests GET /transactions is reachbale using bad paging parameters \n        ", "9": "Tests that GET /transactions is unreachable with invalid start parameter \n        ", "10": "Tests that GET /transactions is unreachable with bad limit parameter \n        ", "11": "verifies that GET /transactions with list reversed\n        ", "12": "Tests/ validate the transactions parameters with transactions, head, start and limit\n        ", "13": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "14": "Tests the transaction id length should be 128 hex character long \n        ", "15": "Tests transaction count from transaction list \n        ", "16": "Tests that GET /transactions/{transaction_id} is reachable \n        ", "17": "Tests that GET /transactions/{transaction_id} is not reachable\nwith bad id"}, "setup": {"duration": 0.00044798851013183594, "outcome": "passed"}, "call": {"duration": 0.0040187835693359375, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_transaction.py", "lineno": 474, "message": "KeyError: 'data'"}, "traceback": [{"path": "get/test_rest_api_get_transaction.py", "lineno": 474, "message": "KeyError"}], "log": [{"name": "test_rest_api_get_transaction", "msg": "Starting test for transaction/{transaction_id}", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_transaction.py", "filename": "test_rest_api_get_transaction.py", "module": "test_rest_api_get_transaction", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 456, "funcName": "test_api_get_transaction_id", "created": 1552988180.1088884, "msecs": 108.88838768005371, "relativeCreated": 300966.30907058716, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:20"}], "longrepr": "self = <test_rest_api_get_transaction.TestTransactionGet object at 0x7fd599b706d8>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_get_transaction_id(self, setup):\n        \"\"\"Tests that GET /transactions/{transaction_id} is reachable\n        \"\"\"\n        LOGGER.info(\"Starting test for transaction/{transaction_id}\")\n        signer_key = setup['signer_key']\n        expected_head = setup['expected_head']\n        expected_txns = setup['expected_txns']\n        expected_id = expected_txns[0]\n        address = setup['address']\n        payload = setup['payload']\n        expected_length = 1\n    \n        expected_link = '{}/transactions/{}'.format(address,expected_id)\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.get(url='{}/transactions/{}'.format(address,expected_id)) as data:\n                    response = await data.json()\n        except aiohttp.client_exceptions.ClientResponseError as error:\n            LOGGER.info(\"Rest Api is Unreachable\")\n    \n>       txns = response['data']\nE       KeyError: 'data'\n\nget/test_rest_api_get_transaction.py:474: KeyError"}, "teardown": {"duration": 0.0002548694610595703, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_transaction.py::TestTransactionGet::test_api_get_transaction_bad_id", "lineno": 479, "outcome": "passed", "keywords": ["()", "test_api_get_transaction_bad_id", "api_test", "run", "transactions", "TestTransactionGet", "get", "get/test_rest_api_get_transaction.py", "first"], "metadata": {"0": "Tests the transaction list after submitting intkey batches\n        ", "1": "Tests that GET /transactions is reachable with head parameter \n        ", "2": "Tests that GET /transactions is unreachable with bad head parameter \n        ", "3": "Tests that GET /transactions is reachable with id as parameter \n        ", "4": "Tests that GET /transactions is unreachable with bad id parameter \n        ", "5": "Tests GET /transactions is reachable with head and id as parameters \n        ", "6": "Tests GET /transactions is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable using paging parameters \n        ", "8": "Tests GET /transactions is reachbale using bad paging parameters \n        ", "9": "Tests that GET /transactions is unreachable with invalid start parameter \n        ", "10": "Tests that GET /transactions is unreachable with bad limit parameter \n        ", "11": "verifies that GET /transactions with list reversed\n        ", "12": "Tests/ validate the transactions parameters with transactions, head, start and limit\n        ", "13": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "14": "Tests the transaction id length should be 128 hex character long \n        ", "15": "Tests transaction count from transaction list \n        ", "16": "Tests that GET /transactions/{transaction_id} is reachable \n        ", "17": "Tests that GET /transactions/{transaction_id} is not reachable\nwith bad id"}, "setup": {"duration": 0.0004363059997558594, "outcome": "passed"}, "call": {"duration": 0.014657020568847656, "outcome": "passed", "log": [{"name": "test_rest_api_get_transaction", "msg": "Starting test for transactions/{bad_id}", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_transaction.py", "filename": "test_rest_api_get_transaction.py", "module": "test_rest_api_get_transaction", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 484, "funcName": "test_api_get_transaction_bad_id", "created": 1552988180.1224387, "msecs": 122.43866920471191, "relativeCreated": 300979.8593521118, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:20"}]}, "teardown": {"duration": 0.00025153160095214844, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::test_api_get_batch_list", "lineno": 92, "outcome": "failed", "keywords": ["test_api_get_batch_list", "TestBatchList", "run", "second", "get/test_rest_api_get_batch.py", "batch", "api_test", "get", "()"], "metadata": {"0": "Tests the batch list by submitting intkey batches\n        ", "1": "Tests that GET /batches is reachable with head parameter \n        ", "2": "Tests that GET /batches is unreachable with bad head parameter \n        ", "3": "Tests that GET /batches is reachable with id as parameter \n        ", "4": "Tests that GET /batches is unreachable with bad id parameter \n        ", "5": "Tests GET /batches is reachable with head and id as parameters \n        ", "6": "Tests GET /batches is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable with limit \n        ", "8": "Tests that GET /batches is unreachable with invalid start parameter \n        ", "9": "Tests that GET /batches is unreachable with bad limit parameter \n        ", "10": "verifies that GET /batches is unreachable with bad head parameter \n        ", "11": "Tests/ validate the block key parameters with data, head, link and paging               \n        ", "12": "Tests/ validate the batch parameters with batches, head, start and limit\n        ", "13": "Tests batches count from batch list \n        ", "14": "verifies that GET /batches/{batch_id} \nis reachable with head parameter ", "15": "verifies that GET /batches/{bad_batch_id} \nis unreachable with bad head parameter ", "16": "verifies that POST /batches_statuses with more than 15 ids\n        ", "17": "verifies that POST /batches_status with less than 10 ids\n        ", "18": "verifies that GET /batches_status\n        ", "19": "verifies that GET /batches_status with many ids\n        ", "20": "verifies that GET /batches_status with bad ids\n        ", "21": "verifies that GET /batches_status with invalid query\n        ", "22": "verifies that GET /batches_status with waiting time\n        ", "23": "verifies that GET /batches_status is unreachable with invalid\n        ", "24": "verifies that GET /batches_status with unknown \n        ", "25": "verifies that GET /batches_status is unreachable with default wait time\n        "}, "setup": {"duration": 0.00048661231994628906, "outcome": "passed"}, "call": {"duration": 0.006876230239868164, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/base.py", "lineno": 207, "message": "AssertionError"}, "traceback": [{"path": "get/test_rest_api_get_batch.py", "lineno": 128, "message": ""}, {"path": "base.py", "lineno": 207, "message": "AssertionError"}], "log": [{"name": "test_rest_api_get_batch", "msg": "Starting tests for batch list", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_batch.py", "filename": "test_rest_api_get_batch.py", "module": "test_rest_api_get_batch", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 96, "funcName": "test_api_get_batch_list", "created": 1552988180.1386254, "msecs": 138.6253833770752, "relativeCreated": 300996.0460662842, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:20"}, {"name": "base", "msg": "3", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/base.py", "filename": "base.py", "module": "base", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 205, "funcName": "assert_valid_data_length", "created": 1552988180.1448834, "msecs": 144.883394241333, "relativeCreated": 301002.30407714844, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:20"}, {"name": "base", "msg": "4", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/base.py", "filename": "base.py", "module": "base", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 206, "funcName": "assert_valid_data_length", "created": 1552988180.144976, "msecs": 144.9759006500244, "relativeCreated": 301002.3965835571, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:20"}], "longrepr": "self = <test_rest_api_get_batch.TestBatchList object at 0x7fd599d1e588>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_get_batch_list(self, setup):\n        \"\"\"Tests the batch list by submitting intkey batches\n        \"\"\"\n        LOGGER.info(\"Starting tests for batch list\")\n        signer_key = setup['signer_key']\n        expected_head = setup['expected_head']\n        expected_batches = setup['expected_batches']\n        expected_txns = setup['expected_txns']\n        expected_length = setup['expected_batch_length']\n        payload = setup['payload']\n        start = setup['start']\n        limit = setup['limit']\n        address = setup['address']\n        url='{}/batches'.format(address)\n        tasks=[]\n    \n        expected_link = '{}/batches?head={}&start={}&limit={}'.format(address,\\\n                         expected_head, start, limit)\n    \n        paging_link = '{}/batches?head={}&start={}'.format(address,\\\n                         expected_head, start)\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                task = asyncio.ensure_future(fetch(url, session))\n                tasks.append(task)\n                response = await asyncio.gather(*tasks)\n        except aiohttp.client_exceptions.ClientResponseError as error:\n            LOGGER.info(\"Rest Api is Unreachable\")\n    \n    \n        batches = _get_batch_list(response[0])\n    \n        self.assert_valid_data(response[0])\n        self.assert_valid_head(response[0], expected_head)\n>       self.assert_valid_data_length(batches, expected_length)\n\nget/test_rest_api_get_batch.py:128: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <test_rest_api_get_batch.TestBatchList object at 0x7fd599d1e588>\nresponse = [{'header': {'signer_public_key': '036cc5e4005ff7cc80bc05164978d724912c7e1aa8e76b4aa024c9255c7c39d753', 'transaction_i...bb1fd47', 'payload': 'CAESQAolc2F3dG9vdGguY29uc2Vuc3VzLnJhZnQuZWxlY3Rpb25fdGljaxIDMjAwGhIweDlkZDFkNGI1NzIxYWQwZWI='}]}]\nexpected_length = 4\n\n    def assert_valid_data_length(self, response, expected_length):\n        \"\"\"Asserts a response has a data list of dicts of an\n           expected length.\n        \"\"\"\n        LOGGER.info(len(response))\n        LOGGER.info(expected_length)\n>       assert len(response) == expected_length\nE       AssertionError\n\nbase.py:207: AssertionError"}, "teardown": {"duration": 0.00025582313537597656, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::test_api_get_batch_list_head", "lineno": 134, "outcome": "failed", "keywords": ["api_test", "TestBatchList", "run", "second", "get/test_rest_api_get_batch.py", "batch", "test_api_get_batch_list_head", "get", "()"], "metadata": {"0": "Tests the batch list by submitting intkey batches\n        ", "1": "Tests that GET /batches is reachable with head parameter \n        ", "2": "Tests that GET /batches is unreachable with bad head parameter \n        ", "3": "Tests that GET /batches is reachable with id as parameter \n        ", "4": "Tests that GET /batches is unreachable with bad id parameter \n        ", "5": "Tests GET /batches is reachable with head and id as parameters \n        ", "6": "Tests GET /batches is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable with limit \n        ", "8": "Tests that GET /batches is unreachable with invalid start parameter \n        ", "9": "Tests that GET /batches is unreachable with bad limit parameter \n        ", "10": "verifies that GET /batches is unreachable with bad head parameter \n        ", "11": "Tests/ validate the block key parameters with data, head, link and paging               \n        ", "12": "Tests/ validate the batch parameters with batches, head, start and limit\n        ", "13": "Tests batches count from batch list \n        ", "14": "verifies that GET /batches/{batch_id} \nis reachable with head parameter ", "15": "verifies that GET /batches/{bad_batch_id} \nis unreachable with bad head parameter ", "16": "verifies that POST /batches_statuses with more than 15 ids\n        ", "17": "verifies that POST /batches_status with less than 10 ids\n        ", "18": "verifies that GET /batches_status\n        ", "19": "verifies that GET /batches_status with many ids\n        ", "20": "verifies that GET /batches_status with bad ids\n        ", "21": "verifies that GET /batches_status with invalid query\n        ", "22": "verifies that GET /batches_status with waiting time\n        ", "23": "verifies that GET /batches_status is unreachable with invalid\n        ", "24": "verifies that GET /batches_status with unknown \n        ", "25": "verifies that GET /batches_status is unreachable with default wait time\n        "}, "setup": {"duration": 0.000453948974609375, "outcome": "passed"}, "call": {"duration": 0.006418943405151367, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/base.py", "lineno": 256, "message": "AssertionError"}, "traceback": [{"path": "get/test_rest_api_get_batch.py", "lineno": 165, "message": ""}, {"path": "base.py", "lineno": 256, "message": "AssertionError"}], "log": [{"name": "test_rest_api_get_batch", "msg": "Starting test for batch with head parameter", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_batch.py", "filename": "test_rest_api_get_batch.py", "module": "test_rest_api_get_batch", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 138, "funcName": "test_api_get_batch_list_head", "created": 1552988180.16267, "msecs": 162.66989707946777, "relativeCreated": 301020.0905799866, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:20"}], "longrepr": "self = <test_rest_api_get_batch.TestBatchList object at 0x7fd599af8278>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_get_batch_list_head(self, setup):\n        \"\"\"Tests that GET /batches is reachable with head parameter\n        \"\"\"\n        LOGGER.info(\"Starting test for batch with head parameter\")\n        signer_key = setup['signer_key']\n        expected_head = setup['expected_head']\n        expected_batches = setup['expected_batches']\n        expected_txns = setup['expected_txns']\n        payload = setup['payload']\n        expected_head = setup['expected_head']\n        start = setup['start']\n        limit = setup['limit']\n        address = setup['address']\n    \n        expected_link = '{}/batches?head={}&start={}&limit={}'.format(address,\\\n                         expected_head, start, limit)\n    \n        params={'head': expected_head}\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.get(url='{}/batches'.format(address), params=params) as data:\n                    response = await data.json()\n        except aiohttp.client_exceptions.ClientResponseError as error:\n            LOGGER.info(\"Rest Api is Unreachable\")\n    \n        batches = response['data'][:-1]\n    \n        self.assert_check_batch_seq(batches, expected_batches,\n                                    expected_txns, payload,\n>                                   signer_key)\n\nget/test_rest_api_get_batch.py:165: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <test_rest_api_get_batch.TestBatchList object at 0x7fd599af8278>\nbatches = [{'header': {'signer_public_key': '036cc5e4005ff7cc80bc05164978d724912c7e1aa8e76b4aa024c9255c7c39d753', 'transaction_i...79db391fb3071d522be1e6d', 'payload': 'CAESNQocc2F3dG9vdGguZ29zc2lwLnRpbWVfdG9fbGl2ZRIBMRoSMHhjNDRhMGUzYzZmMjMyNzYz'}]}]\nexpected_batches = ['8ce16f2f313430ddba62196370379d3b27092209fcf2233cbb251929b6e44c772e8e02fa0af16b29352526b67b2c398f732a7ecdf9256bc6b63bd0d850ae62c8']\nexpected_txns = ['1cd0f86121acd0cda17a3b3117131df40bef5b57683c81e046aaddb58815583c659c176bc6d078ac0e78d87d41e7f3c3ba8a8ce59d119db680eda70a8012e19d']\npayload = 'o2ROYW1lZ0Fic2Fsb21lVmFsdWUBZFZlcmJjc2V0', signer_key = '03d502ec7556c7ee0418211f27eee91cbb37830adea2d25eb346af742900eb50d0'\n\n    def assert_check_batch_seq(self, batches, expected_batches, expected_txns,\n                               payload, signer_key):\n        \"\"\"Asserts batch is constructed properly\n        \"\"\"\n    \n        if not isinstance(batches, list):\n                batches = [batches]\n    \n        if not isinstance(expected_batches, list):\n                expected_batches = [expected_batches]\n    \n        if not isinstance(expected_txns, list):\n                expected_txns = [expected_txns]\n    \n        if not isinstance(payload, list):\n                payload = [payload]\n    \n        for batch, expected_batch , expected_txn, payload in zip(batches, expected_batches , expected_txns, payload):\n>           assert expected_batch == batch['header_signature']\nE           AssertionError\n\nbase.py:256: AssertionError"}, "teardown": {"duration": 0.0002562999725341797, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::test_api_get_batch_list_bad_head", "lineno": 170, "outcome": "passed", "keywords": ["TestBatchList", "run", "second", "get/test_rest_api_get_batch.py", "test_api_get_batch_list_bad_head", "batch", "api_test", "get", "()"], "metadata": {"0": "Tests the batch list by submitting intkey batches\n        ", "1": "Tests that GET /batches is reachable with head parameter \n        ", "2": "Tests that GET /batches is unreachable with bad head parameter \n        ", "3": "Tests that GET /batches is reachable with id as parameter \n        ", "4": "Tests that GET /batches is unreachable with bad id parameter \n        ", "5": "Tests GET /batches is reachable with head and id as parameters \n        ", "6": "Tests GET /batches is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable with limit \n        ", "8": "Tests that GET /batches is unreachable with invalid start parameter \n        ", "9": "Tests that GET /batches is unreachable with bad limit parameter \n        ", "10": "verifies that GET /batches is unreachable with bad head parameter \n        ", "11": "Tests/ validate the block key parameters with data, head, link and paging               \n        ", "12": "Tests/ validate the batch parameters with batches, head, start and limit\n        ", "13": "Tests batches count from batch list \n        ", "14": "verifies that GET /batches/{batch_id} \nis reachable with head parameter ", "15": "verifies that GET /batches/{bad_batch_id} \nis unreachable with bad head parameter ", "16": "verifies that POST /batches_statuses with more than 15 ids\n        ", "17": "verifies that POST /batches_status with less than 10 ids\n        ", "18": "verifies that GET /batches_status\n        ", "19": "verifies that GET /batches_status with many ids\n        ", "20": "verifies that GET /batches_status with bad ids\n        ", "21": "verifies that GET /batches_status with invalid query\n        ", "22": "verifies that GET /batches_status with waiting time\n        ", "23": "verifies that GET /batches_status is unreachable with invalid\n        ", "24": "verifies that GET /batches_status with unknown \n        ", "25": "verifies that GET /batches_status is unreachable with default wait time\n        "}, "setup": {"duration": 0.0004413127899169922, "outcome": "passed"}, "call": {"duration": 0.014190912246704102, "outcome": "passed", "log": [{"name": "test_rest_api_get_batch", "msg": "Starting test for batch with bad head parameter", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_batch.py", "filename": "test_rest_api_get_batch.py", "module": "test_rest_api_get_batch", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 174, "funcName": "test_api_get_batch_list_bad_head", "created": 1552988180.1861997, "msecs": 186.19966506958008, "relativeCreated": 301043.6203479767, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:20"}]}, "teardown": {"duration": 0.0002319812774658203, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::test_api_get_batch_list_id", "lineno": 186, "outcome": "failed", "keywords": ["TestBatchList", "run", "second", "test_api_get_batch_list_id", "get/test_rest_api_get_batch.py", "batch", "api_test", "get", "()"], "metadata": {"0": "Tests the batch list by submitting intkey batches\n        ", "1": "Tests that GET /batches is reachable with head parameter \n        ", "2": "Tests that GET /batches is unreachable with bad head parameter \n        ", "3": "Tests that GET /batches is reachable with id as parameter \n        ", "4": "Tests that GET /batches is unreachable with bad id parameter \n        ", "5": "Tests GET /batches is reachable with head and id as parameters \n        ", "6": "Tests GET /batches is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable with limit \n        ", "8": "Tests that GET /batches is unreachable with invalid start parameter \n        ", "9": "Tests that GET /batches is unreachable with bad limit parameter \n        ", "10": "verifies that GET /batches is unreachable with bad head parameter \n        ", "11": "Tests/ validate the block key parameters with data, head, link and paging               \n        ", "12": "Tests/ validate the batch parameters with batches, head, start and limit\n        ", "13": "Tests batches count from batch list \n        ", "14": "verifies that GET /batches/{batch_id} \nis reachable with head parameter ", "15": "verifies that GET /batches/{bad_batch_id} \nis unreachable with bad head parameter ", "16": "verifies that POST /batches_statuses with more than 15 ids\n        ", "17": "verifies that POST /batches_status with less than 10 ids\n        ", "18": "verifies that GET /batches_status\n        ", "19": "verifies that GET /batches_status with many ids\n        ", "20": "verifies that GET /batches_status with bad ids\n        ", "21": "verifies that GET /batches_status with invalid query\n        ", "22": "verifies that GET /batches_status with waiting time\n        ", "23": "verifies that GET /batches_status is unreachable with invalid\n        ", "24": "verifies that GET /batches_status with unknown \n        ", "25": "verifies that GET /batches_status is unreachable with default wait time\n        "}, "setup": {"duration": 0.00044465065002441406, "outcome": "passed"}, "call": {"duration": 0.005164384841918945, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/base.py", "lineno": 145, "message": "AssertionError"}, "traceback": [{"path": "get/test_rest_api_get_batch.py", "lineno": 224, "message": ""}, {"path": "base.py", "lineno": 145, "message": "AssertionError"}], "log": [{"name": "test_rest_api_get_batch", "msg": "Starting test for batch with id parameter", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_batch.py", "filename": "test_rest_api_get_batch.py", "module": "test_rest_api_get_batch", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 190, "funcName": "test_api_get_batch_list_id", "created": 1552988180.2017856, "msecs": 201.78556442260742, "relativeCreated": 301059.2062473297, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:20"}], "longrepr": "self = <test_rest_api_get_batch.TestBatchList object at 0x7fd599b8b160>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_get_batch_list_id(self, setup):\n        \"\"\"Tests that GET /batches is reachable with id as parameter\n        \"\"\"\n        LOGGER.info(\"Starting test for batch with id parameter\")\n        signer_key = setup['signer_key']\n        expected_head = setup['expected_head']\n        expected_batches = setup['expected_batches']\n        expected_txns = setup['expected_txns']\n        payload = setup['payload']\n        batch_ids   =  setup['batch_ids']\n        start = setup['start']\n        limit = setup['limit']\n        address = setup['address']\n    \n        expected_id = batch_ids[0]\n        expected_length = len([expected_id])\n    \n        expected_link = '{}/batches?head={}&start={}&limit={}&id={}'.format(address,\\\n                         expected_head, start, limit, expected_id)\n    \n        params={'id': expected_id}\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.get(url='{}/batches'.format(address), params=params) as data:\n                    response = await data.json()\n        except aiohttp.client_exceptions.ClientResponseError as error:\n            LOGGER.info(\"Rest Api is Unreachable\")\n    \n    \n        batches = response['data'][:-1]\n    \n        self.assert_check_batch_seq(batches, expected_batches,\n                                    expected_txns, payload,\n                                    signer_key)\n    \n        self.assert_valid_head(response, expected_head)\n>       self.assert_valid_link(response, expected_link)\n\nget/test_rest_api_get_batch.py:224: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <test_rest_api_get_batch.TestBatchList object at 0x7fd599b8b160>\nresponse = {'data': [{'header': {'signer_public_key': '036cc5e4005ff7cc80bc05164978d724912c7e1aa8e76b4aa024c9255c7c39d753', 'tran...bc16430231f0877a3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4', 'paging': {'limit': None, 'start': None}}\nexpected_link = 'http://192.168.1.23:8008/batches?head=c6fd3eead81d509e46564beda332ce517415879b75c1fcf6c179b7e981c1cf930bb23f51d3c7717...b17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231f0877a3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4'\n\n    def assert_valid_link(self, response, expected_link):\n        \"\"\"Asserts a response has a link url string with an\n           expected ending\n        \"\"\"\n        print(response['link'])\n        print(expected_link)\n        assert 'link' in response\n>       assert response['link'] == expected_link\nE       AssertionError\n\nbase.py:145: AssertionError"}, "teardown": {"duration": 0.00025653839111328125, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::test_api_get_batch_list_bad_id", "lineno": 225, "outcome": "passed", "keywords": ["TestBatchList", "run", "test_api_get_batch_list_bad_id", "second", "get/test_rest_api_get_batch.py", "batch", "api_test", "get", "()"], "metadata": {"0": "Tests the batch list by submitting intkey batches\n        ", "1": "Tests that GET /batches is reachable with head parameter \n        ", "2": "Tests that GET /batches is unreachable with bad head parameter \n        ", "3": "Tests that GET /batches is reachable with id as parameter \n        ", "4": "Tests that GET /batches is unreachable with bad id parameter \n        ", "5": "Tests GET /batches is reachable with head and id as parameters \n        ", "6": "Tests GET /batches is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable with limit \n        ", "8": "Tests that GET /batches is unreachable with invalid start parameter \n        ", "9": "Tests that GET /batches is unreachable with bad limit parameter \n        ", "10": "verifies that GET /batches is unreachable with bad head parameter \n        ", "11": "Tests/ validate the block key parameters with data, head, link and paging               \n        ", "12": "Tests/ validate the batch parameters with batches, head, start and limit\n        ", "13": "Tests batches count from batch list \n        ", "14": "verifies that GET /batches/{batch_id} \nis reachable with head parameter ", "15": "verifies that GET /batches/{bad_batch_id} \nis unreachable with bad head parameter ", "16": "verifies that POST /batches_statuses with more than 15 ids\n        ", "17": "verifies that POST /batches_status with less than 10 ids\n        ", "18": "verifies that GET /batches_status\n        ", "19": "verifies that GET /batches_status with many ids\n        ", "20": "verifies that GET /batches_status with bad ids\n        ", "21": "verifies that GET /batches_status with invalid query\n        ", "22": "verifies that GET /batches_status with waiting time\n        ", "23": "verifies that GET /batches_status is unreachable with invalid\n        ", "24": "verifies that GET /batches_status with unknown \n        ", "25": "verifies that GET /batches_status is unreachable with default wait time\n        "}, "setup": {"duration": 0.0004544258117675781, "outcome": "passed"}, "call": {"duration": 0.014471292495727539, "outcome": "passed", "log": [{"name": "test_rest_api_get_batch", "msg": "Starting test for batch with bad id parameter", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_batch.py", "filename": "test_rest_api_get_batch.py", "module": "test_rest_api_get_batch", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 229, "funcName": "test_api_get_batch_list_bad_id", "created": 1552988180.2237298, "msecs": 223.72984886169434, "relativeCreated": 301081.1505317688, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:20"}]}, "teardown": {"duration": 0.00024199485778808594, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::test_api_get_batch_list_head_and_id", "lineno": 241, "outcome": "failed", "keywords": ["TestBatchList", "run", "second", "test_api_get_batch_list_head_and_id", "get/test_rest_api_get_batch.py", "batch", "api_test", "get", "()"], "metadata": {"0": "Tests the batch list by submitting intkey batches\n        ", "1": "Tests that GET /batches is reachable with head parameter \n        ", "2": "Tests that GET /batches is unreachable with bad head parameter \n        ", "3": "Tests that GET /batches is reachable with id as parameter \n        ", "4": "Tests that GET /batches is unreachable with bad id parameter \n        ", "5": "Tests GET /batches is reachable with head and id as parameters \n        ", "6": "Tests GET /batches is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable with limit \n        ", "8": "Tests that GET /batches is unreachable with invalid start parameter \n        ", "9": "Tests that GET /batches is unreachable with bad limit parameter \n        ", "10": "verifies that GET /batches is unreachable with bad head parameter \n        ", "11": "Tests/ validate the block key parameters with data, head, link and paging               \n        ", "12": "Tests/ validate the batch parameters with batches, head, start and limit\n        ", "13": "Tests batches count from batch list \n        ", "14": "verifies that GET /batches/{batch_id} \nis reachable with head parameter ", "15": "verifies that GET /batches/{bad_batch_id} \nis unreachable with bad head parameter ", "16": "verifies that POST /batches_statuses with more than 15 ids\n        ", "17": "verifies that POST /batches_status with less than 10 ids\n        ", "18": "verifies that GET /batches_status\n        ", "19": "verifies that GET /batches_status with many ids\n        ", "20": "verifies that GET /batches_status with bad ids\n        ", "21": "verifies that GET /batches_status with invalid query\n        ", "22": "verifies that GET /batches_status with waiting time\n        ", "23": "verifies that GET /batches_status is unreachable with invalid\n        ", "24": "verifies that GET /batches_status with unknown \n        ", "25": "verifies that GET /batches_status is unreachable with default wait time\n        "}, "setup": {"duration": 0.0004515647888183594, "outcome": "passed"}, "call": {"duration": 0.005281209945678711, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/base.py", "lineno": 145, "message": "AssertionError"}, "traceback": [{"path": "get/test_rest_api_get_batch.py", "lineno": 279, "message": ""}, {"path": "base.py", "lineno": 145, "message": "AssertionError"}], "log": [{"name": "test_rest_api_get_batch", "msg": "Starting test for batch with head and id parameter", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_batch.py", "filename": "test_rest_api_get_batch.py", "module": "test_rest_api_get_batch", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 245, "funcName": "test_api_get_batch_list_head_and_id", "created": 1552988180.2396908, "msecs": 239.69078063964844, "relativeCreated": 301097.11146354675, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:20"}], "longrepr": "self = <test_rest_api_get_batch.TestBatchList object at 0x7fd599b7d630>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_get_batch_list_head_and_id(self, setup):\n        \"\"\"Tests GET /batches is reachable with head and id as parameters\n        \"\"\"\n        LOGGER.info(\"Starting test for batch with head and id parameter\")\n        signer_key = setup['signer_key']\n        expected_head = setup['expected_head']\n        expected_batches = setup['expected_batches']\n        expected_txns = setup['expected_txns']\n        payload = setup['payload']\n        batch_ids   =  setup['batch_ids']\n        start = setup['start']\n        limit = setup['limit']\n        address = setup['address']\n    \n        expected_id = batch_ids[0]\n        expected_length = len([expected_id])\n    \n        expected_link = '{}/batches?head={}&start={}&limit={}&id={}'.format(address,\\\n                         expected_head, start, limit, expected_id)\n    \n        params={'head':expected_head,'id':expected_id}\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.get(url='{}/batches'.format(address), params=params) as data:\n                    response = await data.json()\n        except aiohttp.client_exceptions.ClientResponseError as error:\n            LOGGER.info(\"Rest Api is Unreachable\")\n    \n    \n        batches = response['data'][:-1]\n    \n        self.assert_check_batch_seq(batches, expected_batches,\n                                    expected_txns, payload,\n                                    signer_key)\n    \n        self.assert_valid_head(response, expected_head)\n>       self.assert_valid_link(response, expected_link)\n\nget/test_rest_api_get_batch.py:279: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <test_rest_api_get_batch.TestBatchList object at 0x7fd599b7d630>\nresponse = {'data': [{'header': {'signer_public_key': '036cc5e4005ff7cc80bc05164978d724912c7e1aa8e76b4aa024c9255c7c39d753', 'tran...bc16430231f0877a3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4', 'paging': {'limit': None, 'start': None}}\nexpected_link = 'http://192.168.1.23:8008/batches?head=c6fd3eead81d509e46564beda332ce517415879b75c1fcf6c179b7e981c1cf930bb23f51d3c7717...b17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231f0877a3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4'\n\n    def assert_valid_link(self, response, expected_link):\n        \"\"\"Asserts a response has a link url string with an\n           expected ending\n        \"\"\"\n        print(response['link'])\n        print(expected_link)\n        assert 'link' in response\n>       assert response['link'] == expected_link\nE       AssertionError\n\nbase.py:145: AssertionError"}, "teardown": {"duration": 0.00025653839111328125, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::test_api_get_paginated_batch_list", "lineno": 280, "outcome": "passed", "keywords": ["api_test", "TestBatchList", "run", "second", "get/test_rest_api_get_batch.py", "batch", "test_api_get_paginated_batch_list", "get", "()"], "metadata": {"0": "Tests the batch list by submitting intkey batches\n        ", "1": "Tests that GET /batches is reachable with head parameter \n        ", "2": "Tests that GET /batches is unreachable with bad head parameter \n        ", "3": "Tests that GET /batches is reachable with id as parameter \n        ", "4": "Tests that GET /batches is unreachable with bad id parameter \n        ", "5": "Tests GET /batches is reachable with head and id as parameters \n        ", "6": "Tests GET /batches is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable with limit \n        ", "8": "Tests that GET /batches is unreachable with invalid start parameter \n        ", "9": "Tests that GET /batches is unreachable with bad limit parameter \n        ", "10": "verifies that GET /batches is unreachable with bad head parameter \n        ", "11": "Tests/ validate the block key parameters with data, head, link and paging               \n        ", "12": "Tests/ validate the batch parameters with batches, head, start and limit\n        ", "13": "Tests batches count from batch list \n        ", "14": "verifies that GET /batches/{batch_id} \nis reachable with head parameter ", "15": "verifies that GET /batches/{bad_batch_id} \nis unreachable with bad head parameter ", "16": "verifies that POST /batches_statuses with more than 15 ids\n        ", "17": "verifies that POST /batches_status with less than 10 ids\n        ", "18": "verifies that GET /batches_status\n        ", "19": "verifies that GET /batches_status with many ids\n        ", "20": "verifies that GET /batches_status with bad ids\n        ", "21": "verifies that GET /batches_status with invalid query\n        ", "22": "verifies that GET /batches_status with waiting time\n        ", "23": "verifies that GET /batches_status is unreachable with invalid\n        ", "24": "verifies that GET /batches_status with unknown \n        ", "25": "verifies that GET /batches_status is unreachable with default wait time\n        "}, "setup": {"duration": 0.00045490264892578125, "outcome": "passed"}, "call": {"duration": 0.017313480377197266, "outcome": "passed", "log": [{"name": "test_rest_api_get_batch", "msg": "Starting test for batch with paging parameters", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_batch.py", "filename": "test_rest_api_get_batch.py", "module": "test_rest_api_get_batch", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 284, "funcName": "test_api_get_paginated_batch_list", "created": 1552988180.2619612, "msecs": 261.9612216949463, "relativeCreated": 301119.38190460205, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:20"}]}, "teardown": {"duration": 0.0002474784851074219, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::test_api_get_batch_list_limit", "lineno": 300, "outcome": "failed", "keywords": ["test_api_get_batch_list_limit", "TestBatchList", "run", "second", "get/test_rest_api_get_batch.py", "batch", "api_test", "get", "()"], "metadata": {"0": "Tests the batch list by submitting intkey batches\n        ", "1": "Tests that GET /batches is reachable with head parameter \n        ", "2": "Tests that GET /batches is unreachable with bad head parameter \n        ", "3": "Tests that GET /batches is reachable with id as parameter \n        ", "4": "Tests that GET /batches is unreachable with bad id parameter \n        ", "5": "Tests GET /batches is reachable with head and id as parameters \n        ", "6": "Tests GET /batches is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable with limit \n        ", "8": "Tests that GET /batches is unreachable with invalid start parameter \n        ", "9": "Tests that GET /batches is unreachable with bad limit parameter \n        ", "10": "verifies that GET /batches is unreachable with bad head parameter \n        ", "11": "Tests/ validate the block key parameters with data, head, link and paging               \n        ", "12": "Tests/ validate the batch parameters with batches, head, start and limit\n        ", "13": "Tests batches count from batch list \n        ", "14": "verifies that GET /batches/{batch_id} \nis reachable with head parameter ", "15": "verifies that GET /batches/{bad_batch_id} \nis unreachable with bad head parameter ", "16": "verifies that POST /batches_statuses with more than 15 ids\n        ", "17": "verifies that POST /batches_status with less than 10 ids\n        ", "18": "verifies that GET /batches_status\n        ", "19": "verifies that GET /batches_status with many ids\n        ", "20": "verifies that GET /batches_status with bad ids\n        ", "21": "verifies that GET /batches_status with invalid query\n        ", "22": "verifies that GET /batches_status with waiting time\n        ", "23": "verifies that GET /batches_status is unreachable with invalid\n        ", "24": "verifies that GET /batches_status with unknown \n        ", "25": "verifies that GET /batches_status is unreachable with default wait time\n        "}, "setup": {"duration": 0.0004496574401855469, "outcome": "passed"}, "call": {"duration": 0.0056340694427490234, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/base.py", "lineno": 145, "message": "AssertionError"}, "traceback": [{"path": "get/test_rest_api_get_batch.py", "lineno": 334, "message": ""}, {"path": "base.py", "lineno": 145, "message": "AssertionError"}], "log": [{"name": "test_rest_api_get_batch", "msg": "Starting test for batch with paging parameters", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_batch.py", "filename": "test_rest_api_get_batch.py", "module": "test_rest_api_get_batch", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 304, "funcName": "test_api_get_batch_list_limit", "created": 1552988180.2807229, "msecs": 280.72285652160645, "relativeCreated": 301138.1435394287, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:20"}], "longrepr": "self = <test_rest_api_get_batch.TestBatchList object at 0x7fd599aae9b0>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_get_batch_list_limit(self, setup):\n        \"\"\"Tests GET /batches is reachable with limit\n        \"\"\"\n        LOGGER.info(\"Starting test for batch with paging parameters\")\n        signer_key = setup['signer_key']\n        batch_ids   =  setup['batch_ids']\n        expected_head = setup['expected_head']\n        expected_head = setup['expected_head']\n        expected_batches = setup['expected_batches']\n        expected_txns = setup['expected_txns']\n        payload = setup['payload']\n        expected_id = batch_ids[0]\n        start = setup['start']\n        address = setup['address']\n        params={'limit':1}\n    \n        expected_link = '{}/batches?head={}&start={}&limit={}'.format(address,\\\n                         expected_head, start, 1)\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.get(url='{}/batches'.format(address), params=params) as data:\n                    response = await data.json()\n        except aiohttp.client_exceptions.ClientResponseError as error:\n            LOGGER.info(\"Rest Api is Unreachable\")\n    \n        batches = response['data'][:-1]\n    \n        self.assert_check_batch_seq(batches, expected_batches,\n                                    expected_txns, payload,\n                                    signer_key)\n    \n        self.assert_valid_head(response, expected_head)\n>       self.assert_valid_link(response, expected_link)\n\nget/test_rest_api_get_batch.py:334: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <test_rest_api_get_batch.TestBatchList object at 0x7fd599aae9b0>\nresponse = {'data': [{'header': {'signer_public_key': '036cc5e4005ff7cc80bc05164978d724912c7e1aa8e76b4aa024c9255c7c39d753', 'tran...f8ffa539cabc72dd6a241b5c921d5c85ef7b1487a4054debb276e228f9ad9f02e2ea4ecaf22fffe2686644ba5c817ab7660ee', 'start': None}}\nexpected_link = 'http://192.168.1.23:8008/batches?head=c6fd3eead81d509e46564beda332ce517415879b75c1fcf6c179b7e981c1cf930bb23f51d3c7717...62196370379d3b27092209fcf2233cbb251929b6e44c772e8e02fa0af16b29352526b67b2c398f732a7ecdf9256bc6b63bd0d850ae62c8&limit=1'\n\n    def assert_valid_link(self, response, expected_link):\n        \"\"\"Asserts a response has a link url string with an\n           expected ending\n        \"\"\"\n        print(response['link'])\n        print(expected_link)\n        assert 'link' in response\n>       assert response['link'] == expected_link\nE       AssertionError\n\nbase.py:145: AssertionError"}, "teardown": {"duration": 0.0002551078796386719, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::test_api_get_batch_list_invalid_start", "lineno": 337, "outcome": "passed", "keywords": ["TestBatchList", "run", "test_api_get_batch_list_invalid_start", "second", "get/test_rest_api_get_batch.py", "batch", "api_test", "get", "()"], "metadata": {"0": "Tests the batch list by submitting intkey batches\n        ", "1": "Tests that GET /batches is reachable with head parameter \n        ", "2": "Tests that GET /batches is unreachable with bad head parameter \n        ", "3": "Tests that GET /batches is reachable with id as parameter \n        ", "4": "Tests that GET /batches is unreachable with bad id parameter \n        ", "5": "Tests GET /batches is reachable with head and id as parameters \n        ", "6": "Tests GET /batches is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable with limit \n        ", "8": "Tests that GET /batches is unreachable with invalid start parameter \n        ", "9": "Tests that GET /batches is unreachable with bad limit parameter \n        ", "10": "verifies that GET /batches is unreachable with bad head parameter \n        ", "11": "Tests/ validate the block key parameters with data, head, link and paging               \n        ", "12": "Tests/ validate the batch parameters with batches, head, start and limit\n        ", "13": "Tests batches count from batch list \n        ", "14": "verifies that GET /batches/{batch_id} \nis reachable with head parameter ", "15": "verifies that GET /batches/{bad_batch_id} \nis unreachable with bad head parameter ", "16": "verifies that POST /batches_statuses with more than 15 ids\n        ", "17": "verifies that POST /batches_status with less than 10 ids\n        ", "18": "verifies that GET /batches_status\n        ", "19": "verifies that GET /batches_status with many ids\n        ", "20": "verifies that GET /batches_status with bad ids\n        ", "21": "verifies that GET /batches_status with invalid query\n        ", "22": "verifies that GET /batches_status with waiting time\n        ", "23": "verifies that GET /batches_status is unreachable with invalid\n        ", "24": "verifies that GET /batches_status with unknown \n        ", "25": "verifies that GET /batches_status is unreachable with default wait time\n        "}, "setup": {"duration": 0.0004589557647705078, "outcome": "passed"}, "call": {"duration": 0.0173947811126709, "outcome": "passed", "log": [{"name": "test_rest_api_get_batch", "msg": "Starting test for batch with invalid start parameter", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_batch.py", "filename": "test_rest_api_get_batch.py", "module": "test_rest_api_get_batch", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 341, "funcName": "test_api_get_batch_list_invalid_start", "created": 1552988180.3031557, "msecs": 303.15566062927246, "relativeCreated": 301160.5763435364, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:20"}]}, "teardown": {"duration": 0.0002384185791015625, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::test_api_get_batch_list_invalid_limit", "lineno": 357, "outcome": "passed", "keywords": ["TestBatchList", "run", "second", "get/test_rest_api_get_batch.py", "batch", "api_test", "get", "test_api_get_batch_list_invalid_limit", "()"], "metadata": {"0": "Tests the batch list by submitting intkey batches\n        ", "1": "Tests that GET /batches is reachable with head parameter \n        ", "2": "Tests that GET /batches is unreachable with bad head parameter \n        ", "3": "Tests that GET /batches is reachable with id as parameter \n        ", "4": "Tests that GET /batches is unreachable with bad id parameter \n        ", "5": "Tests GET /batches is reachable with head and id as parameters \n        ", "6": "Tests GET /batches is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable with limit \n        ", "8": "Tests that GET /batches is unreachable with invalid start parameter \n        ", "9": "Tests that GET /batches is unreachable with bad limit parameter \n        ", "10": "verifies that GET /batches is unreachable with bad head parameter \n        ", "11": "Tests/ validate the block key parameters with data, head, link and paging               \n        ", "12": "Tests/ validate the batch parameters with batches, head, start and limit\n        ", "13": "Tests batches count from batch list \n        ", "14": "verifies that GET /batches/{batch_id} \nis reachable with head parameter ", "15": "verifies that GET /batches/{bad_batch_id} \nis unreachable with bad head parameter ", "16": "verifies that POST /batches_statuses with more than 15 ids\n        ", "17": "verifies that POST /batches_status with less than 10 ids\n        ", "18": "verifies that GET /batches_status\n        ", "19": "verifies that GET /batches_status with many ids\n        ", "20": "verifies that GET /batches_status with bad ids\n        ", "21": "verifies that GET /batches_status with invalid query\n        ", "22": "verifies that GET /batches_status with waiting time\n        ", "23": "verifies that GET /batches_status is unreachable with invalid\n        ", "24": "verifies that GET /batches_status with unknown \n        ", "25": "verifies that GET /batches_status is unreachable with default wait time\n        "}, "setup": {"duration": 0.0004544258117675781, "outcome": "passed"}, "call": {"duration": 0.014585256576538086, "outcome": "passed", "log": [{"name": "test_rest_api_get_batch", "msg": "Starting test for batch with bad limit parameter", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_batch.py", "filename": "test_rest_api_get_batch.py", "module": "test_rest_api_get_batch", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 361, "funcName": "test_api_get_batch_list_invalid_limit", "created": 1552988180.322018, "msecs": 322.0179080963135, "relativeCreated": 301179.4385910034, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:20"}]}, "teardown": {"duration": 0.0002586841583251953, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::test_api_get_batch_list_reversed", "lineno": 376, "outcome": "failed", "keywords": ["api_test", "TestBatchList", "run", "second", "get/test_rest_api_get_batch.py", "batch", "test_api_get_batch_list_reversed", "get", "()"], "metadata": {"0": "Tests the batch list by submitting intkey batches\n        ", "1": "Tests that GET /batches is reachable with head parameter \n        ", "2": "Tests that GET /batches is unreachable with bad head parameter \n        ", "3": "Tests that GET /batches is reachable with id as parameter \n        ", "4": "Tests that GET /batches is unreachable with bad id parameter \n        ", "5": "Tests GET /batches is reachable with head and id as parameters \n        ", "6": "Tests GET /batches is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable with limit \n        ", "8": "Tests that GET /batches is unreachable with invalid start parameter \n        ", "9": "Tests that GET /batches is unreachable with bad limit parameter \n        ", "10": "verifies that GET /batches is unreachable with bad head parameter \n        ", "11": "Tests/ validate the block key parameters with data, head, link and paging               \n        ", "12": "Tests/ validate the batch parameters with batches, head, start and limit\n        ", "13": "Tests batches count from batch list \n        ", "14": "verifies that GET /batches/{batch_id} \nis reachable with head parameter ", "15": "verifies that GET /batches/{bad_batch_id} \nis unreachable with bad head parameter ", "16": "verifies that POST /batches_statuses with more than 15 ids\n        ", "17": "verifies that POST /batches_status with less than 10 ids\n        ", "18": "verifies that GET /batches_status\n        ", "19": "verifies that GET /batches_status with many ids\n        ", "20": "verifies that GET /batches_status with bad ids\n        ", "21": "verifies that GET /batches_status with invalid query\n        ", "22": "verifies that GET /batches_status with waiting time\n        ", "23": "verifies that GET /batches_status is unreachable with invalid\n        ", "24": "verifies that GET /batches_status with unknown \n        ", "25": "verifies that GET /batches_status is unreachable with default wait time\n        "}, "setup": {"duration": 0.00046634674072265625, "outcome": "passed"}, "call": {"duration": 0.007032632827758789, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/base.py", "lineno": 256, "message": "AssertionError"}, "traceback": [{"path": "get/test_rest_api_get_batch.py", "lineno": 411, "message": ""}, {"path": "base.py", "lineno": 256, "message": "AssertionError"}], "log": [{"name": "test_rest_api_get_batch", "msg": "Starting test for batch list as reversed", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_batch.py", "filename": "test_rest_api_get_batch.py", "module": "test_rest_api_get_batch", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 380, "funcName": "test_api_get_batch_list_reversed", "created": 1552988180.3381865, "msecs": 338.18650245666504, "relativeCreated": 301195.60718536377, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:20"}], "longrepr": "self = <test_rest_api_get_batch.TestBatchList object at 0x7fd599ab10b8>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_get_batch_list_reversed(self, setup):\n        \"\"\"verifies that GET /batches is unreachable with bad head parameter\n        \"\"\"\n        LOGGER.info(\"Starting test for batch list as reversed\")\n        signer_key = setup['signer_key']\n        expected_head = setup['expected_head']\n        expected_batches = setup['expected_batches']\n        expected_txns = setup['expected_txns']\n        expected_length = setup['expected_batch_length']\n        payload = setup['payload']\n        start = setup['batch_ids'][::-1][0]\n        print(setup['batch_ids'])\n        print(start)\n        limit = setup['limit']\n        address = setup['address']\n    \n        expected_link = '{}/batches?head={}&start={}&limit={}&reverse'.format(address,\\\n                         expected_head, start, limit)\n    \n        params = 'reverse'\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.get(url='{}/batches'.format(address), params=params) as data:\n                    response = await data.json()\n        except aiohttp.client_exceptions.ClientResponseError as error:\n            LOGGER.info(\"Rest Api is Unreachable\")\n    \n    \n        batches = response['data'][::-1][:-1]\n    \n    \n        self.assert_check_batch_seq(batches, expected_batches,\n                                    expected_txns, payload,\n>                                   signer_key)\n\nget/test_rest_api_get_batch.py:411: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <test_rest_api_get_batch.TestBatchList object at 0x7fd599ab10b8>\nbatches = [{'header': {'signer_public_key': '036cc5e4005ff7cc80bc05164978d724912c7e1aa8e76b4aa024c9255c7c39d753', 'transaction_i...79db391fb3071d522be1e6d', 'payload': 'CAESNQocc2F3dG9vdGguZ29zc2lwLnRpbWVfdG9fbGl2ZRIBMRoSMHhjNDRhMGUzYzZmMjMyNzYz'}]}]\nexpected_batches = ['8ce16f2f313430ddba62196370379d3b27092209fcf2233cbb251929b6e44c772e8e02fa0af16b29352526b67b2c398f732a7ecdf9256bc6b63bd0d850ae62c8']\nexpected_txns = ['1cd0f86121acd0cda17a3b3117131df40bef5b57683c81e046aaddb58815583c659c176bc6d078ac0e78d87d41e7f3c3ba8a8ce59d119db680eda70a8012e19d']\npayload = 'o2ROYW1lZ0Fic2Fsb21lVmFsdWUBZFZlcmJjc2V0', signer_key = '03d502ec7556c7ee0418211f27eee91cbb37830adea2d25eb346af742900eb50d0'\n\n    def assert_check_batch_seq(self, batches, expected_batches, expected_txns,\n                               payload, signer_key):\n        \"\"\"Asserts batch is constructed properly\n        \"\"\"\n    \n        if not isinstance(batches, list):\n                batches = [batches]\n    \n        if not isinstance(expected_batches, list):\n                expected_batches = [expected_batches]\n    \n        if not isinstance(expected_txns, list):\n                expected_txns = [expected_txns]\n    \n        if not isinstance(payload, list):\n                payload = [payload]\n    \n        for batch, expected_batch , expected_txn, payload in zip(batches, expected_batches , expected_txns, payload):\n>           assert expected_batch == batch['header_signature']\nE           AssertionError\n\nbase.py:256: AssertionError"}, "teardown": {"duration": 0.0002551078796386719, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::test_api_get_batch_key_params", "lineno": 417, "outcome": "passed", "keywords": ["test_api_get_batch_key_params", "TestBatchList", "run", "second", "get/test_rest_api_get_batch.py", "batch", "api_test", "get", "()"], "metadata": {"0": "Tests the batch list by submitting intkey batches\n        ", "1": "Tests that GET /batches is reachable with head parameter \n        ", "2": "Tests that GET /batches is unreachable with bad head parameter \n        ", "3": "Tests that GET /batches is reachable with id as parameter \n        ", "4": "Tests that GET /batches is unreachable with bad id parameter \n        ", "5": "Tests GET /batches is reachable with head and id as parameters \n        ", "6": "Tests GET /batches is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable with limit \n        ", "8": "Tests that GET /batches is unreachable with invalid start parameter \n        ", "9": "Tests that GET /batches is unreachable with bad limit parameter \n        ", "10": "verifies that GET /batches is unreachable with bad head parameter \n        ", "11": "Tests/ validate the block key parameters with data, head, link and paging               \n        ", "12": "Tests/ validate the batch parameters with batches, head, start and limit\n        ", "13": "Tests batches count from batch list \n        ", "14": "verifies that GET /batches/{batch_id} \nis reachable with head parameter ", "15": "verifies that GET /batches/{bad_batch_id} \nis unreachable with bad head parameter ", "16": "verifies that POST /batches_statuses with more than 15 ids\n        ", "17": "verifies that POST /batches_status with less than 10 ids\n        ", "18": "verifies that GET /batches_status\n        ", "19": "verifies that GET /batches_status with many ids\n        ", "20": "verifies that GET /batches_status with bad ids\n        ", "21": "verifies that GET /batches_status with invalid query\n        ", "22": "verifies that GET /batches_status with waiting time\n        ", "23": "verifies that GET /batches_status is unreachable with invalid\n        ", "24": "verifies that GET /batches_status with unknown \n        ", "25": "verifies that GET /batches_status is unreachable with default wait time\n        "}, "setup": {"duration": 0.0004627704620361328, "outcome": "passed"}, "call": {"duration": 0.01872539520263672, "outcome": "passed"}, "teardown": {"duration": 0.00024271011352539062, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::test_api_get_batch_param_link_val", "lineno": 433, "outcome": "passed", "keywords": ["TestBatchList", "test_api_get_batch_param_link_val", "second", "run", "get/test_rest_api_get_batch.py", "batch", "api_test", "get", "()"], "metadata": {"0": "Tests the batch list by submitting intkey batches\n        ", "1": "Tests that GET /batches is reachable with head parameter \n        ", "2": "Tests that GET /batches is unreachable with bad head parameter \n        ", "3": "Tests that GET /batches is reachable with id as parameter \n        ", "4": "Tests that GET /batches is unreachable with bad id parameter \n        ", "5": "Tests GET /batches is reachable with head and id as parameters \n        ", "6": "Tests GET /batches is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable with limit \n        ", "8": "Tests that GET /batches is unreachable with invalid start parameter \n        ", "9": "Tests that GET /batches is unreachable with bad limit parameter \n        ", "10": "verifies that GET /batches is unreachable with bad head parameter \n        ", "11": "Tests/ validate the block key parameters with data, head, link and paging               \n        ", "12": "Tests/ validate the batch parameters with batches, head, start and limit\n        ", "13": "Tests batches count from batch list \n        ", "14": "verifies that GET /batches/{batch_id} \nis reachable with head parameter ", "15": "verifies that GET /batches/{bad_batch_id} \nis unreachable with bad head parameter ", "16": "verifies that POST /batches_statuses with more than 15 ids\n        ", "17": "verifies that POST /batches_status with less than 10 ids\n        ", "18": "verifies that GET /batches_status\n        ", "19": "verifies that GET /batches_status with many ids\n        ", "20": "verifies that GET /batches_status with bad ids\n        ", "21": "verifies that GET /batches_status with invalid query\n        ", "22": "verifies that GET /batches_status with waiting time\n        ", "23": "verifies that GET /batches_status is unreachable with invalid\n        ", "24": "verifies that GET /batches_status with unknown \n        ", "25": "verifies that GET /batches_status is unreachable with default wait time\n        "}, "setup": {"duration": 0.00045180320739746094, "outcome": "passed"}, "call": {"duration": 0.018594980239868164, "outcome": "passed"}, "teardown": {"duration": 0.00026607513427734375, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchList::test_rest_api_check_batches_count", "lineno": 453, "outcome": "passed", "keywords": ["TestBatchList", "run", "second", "get/test_rest_api_get_batch.py", "batch", "test_rest_api_check_batches_count", "api_test", "get", "()"], "metadata": {"0": "Tests the batch list by submitting intkey batches\n        ", "1": "Tests that GET /batches is reachable with head parameter \n        ", "2": "Tests that GET /batches is unreachable with bad head parameter \n        ", "3": "Tests that GET /batches is reachable with id as parameter \n        ", "4": "Tests that GET /batches is unreachable with bad id parameter \n        ", "5": "Tests GET /batches is reachable with head and id as parameters \n        ", "6": "Tests GET /batches is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable with limit \n        ", "8": "Tests that GET /batches is unreachable with invalid start parameter \n        ", "9": "Tests that GET /batches is unreachable with bad limit parameter \n        ", "10": "verifies that GET /batches is unreachable with bad head parameter \n        ", "11": "Tests/ validate the block key parameters with data, head, link and paging               \n        ", "12": "Tests/ validate the batch parameters with batches, head, start and limit\n        ", "13": "Tests batches count from batch list \n        ", "14": "verifies that GET /batches/{batch_id} \nis reachable with head parameter ", "15": "verifies that GET /batches/{bad_batch_id} \nis unreachable with bad head parameter ", "16": "verifies that POST /batches_statuses with more than 15 ids\n        ", "17": "verifies that POST /batches_status with less than 10 ids\n        ", "18": "verifies that GET /batches_status\n        ", "19": "verifies that GET /batches_status with many ids\n        ", "20": "verifies that GET /batches_status with bad ids\n        ", "21": "verifies that GET /batches_status with invalid query\n        ", "22": "verifies that GET /batches_status with waiting time\n        ", "23": "verifies that GET /batches_status is unreachable with invalid\n        ", "24": "verifies that GET /batches_status with unknown \n        ", "25": "verifies that GET /batches_status is unreachable with default wait time\n        "}, "setup": {"duration": 0.00046133995056152344, "outcome": "passed"}, "call": {"duration": 0.01868414878845215, "outcome": "passed"}, "teardown": {"duration": 0.00025773048400878906, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchGet::test_api_get_batch_id", "lineno": 469, "outcome": "failed", "keywords": ["test_api_get_batch_id", "run", "second", "get/test_rest_api_get_batch.py", "batch", "TestBatchGet", "api_test", "get", "()"], "metadata": {"0": "Tests the batch list by submitting intkey batches\n        ", "1": "Tests that GET /batches is reachable with head parameter \n        ", "2": "Tests that GET /batches is unreachable with bad head parameter \n        ", "3": "Tests that GET /batches is reachable with id as parameter \n        ", "4": "Tests that GET /batches is unreachable with bad id parameter \n        ", "5": "Tests GET /batches is reachable with head and id as parameters \n        ", "6": "Tests GET /batches is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable with limit \n        ", "8": "Tests that GET /batches is unreachable with invalid start parameter \n        ", "9": "Tests that GET /batches is unreachable with bad limit parameter \n        ", "10": "verifies that GET /batches is unreachable with bad head parameter \n        ", "11": "Tests/ validate the block key parameters with data, head, link and paging               \n        ", "12": "Tests/ validate the batch parameters with batches, head, start and limit\n        ", "13": "Tests batches count from batch list \n        ", "14": "verifies that GET /batches/{batch_id} \nis reachable with head parameter ", "15": "verifies that GET /batches/{bad_batch_id} \nis unreachable with bad head parameter ", "16": "verifies that POST /batches_statuses with more than 15 ids\n        ", "17": "verifies that POST /batches_status with less than 10 ids\n        ", "18": "verifies that GET /batches_status\n        ", "19": "verifies that GET /batches_status with many ids\n        ", "20": "verifies that GET /batches_status with bad ids\n        ", "21": "verifies that GET /batches_status with invalid query\n        ", "22": "verifies that GET /batches_status with waiting time\n        ", "23": "verifies that GET /batches_status is unreachable with invalid\n        ", "24": "verifies that GET /batches_status with unknown \n        ", "25": "verifies that GET /batches_status is unreachable with default wait time\n        "}, "setup": {"duration": 0.00046896934509277344, "outcome": "passed"}, "call": {"duration": 0.004248857498168945, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/base.py", "lineno": 256, "message": "AssertionError"}, "traceback": [{"path": "get/test_rest_api_get_batch.py", "lineno": 497, "message": ""}, {"path": "base.py", "lineno": 256, "message": "AssertionError"}], "longrepr": "self = <test_rest_api_get_batch.TestBatchGet object at 0x7fd599af29b0>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_get_batch_id(self, setup):\n        \"\"\"verifies that GET /batches/{batch_id}\n           is reachable with head parameter\n        \"\"\"\n        signer_key = setup['signer_key']\n        expected_head = setup['expected_head']\n        expected_batches = setup['expected_batches']\n        expected_txns = setup['expected_txns']\n        expected_length = setup['expected_batch_length']\n        batch_ids = setup['batch_ids']\n        expected_id = batch_ids[0]\n        payload = setup['payload']\n        address = setup['address']\n    \n        expected_link = '{}/batches/{}'.format(address, expected_batches[0])\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.get(url='{}/batches/{}'.format(address,expected_id)) as data:\n                    response = await data.json()\n        except aiohttp.client_exceptions.ClientResponseError as error:\n            LOGGER.info(\"Rest Api is Unreachable\")\n    \n        batches = response['data']\n    \n        self.assert_check_batch_seq(batches, expected_batches,\n                                    expected_txns, payload,\n>                                   signer_key)\n\nget/test_rest_api_get_batch.py:497: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <test_rest_api_get_batch.TestBatchGet object at 0x7fd599af29b0>\nbatches = [{'header': {'signer_public_key': '036cc5e4005ff7cc80bc05164978d724912c7e1aa8e76b4aa024c9255c7c39d753', 'transaction_i...AzNmNjNWU0MDA1ZmY3Y2M4MGJjMDUxNjQ5NzhkNzI0OTEyYzdlMWFhOGU3NmI0YWEwMjRjOTI1NWM3YzM5ZDc1MxoQMHg4YTlhNTBlZWIyZGE5NQ=='}]}]\nexpected_batches = ['8ce16f2f313430ddba62196370379d3b27092209fcf2233cbb251929b6e44c772e8e02fa0af16b29352526b67b2c398f732a7ecdf9256bc6b63bd0d850ae62c8']\nexpected_txns = ['1cd0f86121acd0cda17a3b3117131df40bef5b57683c81e046aaddb58815583c659c176bc6d078ac0e78d87d41e7f3c3ba8a8ce59d119db680eda70a8012e19d']\npayload = 'o2ROYW1lZ0Fic2Fsb21lVmFsdWUBZFZlcmJjc2V0', signer_key = '03d502ec7556c7ee0418211f27eee91cbb37830adea2d25eb346af742900eb50d0'\n\n    def assert_check_batch_seq(self, batches, expected_batches, expected_txns,\n                               payload, signer_key):\n        \"\"\"Asserts batch is constructed properly\n        \"\"\"\n    \n        if not isinstance(batches, list):\n                batches = [batches]\n    \n        if not isinstance(expected_batches, list):\n                expected_batches = [expected_batches]\n    \n        if not isinstance(expected_txns, list):\n                expected_txns = [expected_txns]\n    \n        if not isinstance(payload, list):\n                payload = [payload]\n    \n        for batch, expected_batch , expected_txn, payload in zip(batches, expected_batches , expected_txns, payload):\n>           assert expected_batch == batch['header_signature']\nE           AssertionError\n\nbase.py:256: AssertionError"}, "teardown": {"duration": 0.00025582313537597656, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchGet::test_api_get_bad_batch_id", "lineno": 499, "outcome": "passed", "keywords": ["run", "get", "second", "get/test_rest_api_get_batch.py", "batch", "TestBatchGet", "api_test", "test_api_get_bad_batch_id", "()"], "metadata": {"0": "Tests the batch list by submitting intkey batches\n        ", "1": "Tests that GET /batches is reachable with head parameter \n        ", "2": "Tests that GET /batches is unreachable with bad head parameter \n        ", "3": "Tests that GET /batches is reachable with id as parameter \n        ", "4": "Tests that GET /batches is unreachable with bad id parameter \n        ", "5": "Tests GET /batches is reachable with head and id as parameters \n        ", "6": "Tests GET /batches is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable with limit \n        ", "8": "Tests that GET /batches is unreachable with invalid start parameter \n        ", "9": "Tests that GET /batches is unreachable with bad limit parameter \n        ", "10": "verifies that GET /batches is unreachable with bad head parameter \n        ", "11": "Tests/ validate the block key parameters with data, head, link and paging               \n        ", "12": "Tests/ validate the batch parameters with batches, head, start and limit\n        ", "13": "Tests batches count from batch list \n        ", "14": "verifies that GET /batches/{batch_id} \nis reachable with head parameter ", "15": "verifies that GET /batches/{bad_batch_id} \nis unreachable with bad head parameter ", "16": "verifies that POST /batches_statuses with more than 15 ids\n        ", "17": "verifies that POST /batches_status with less than 10 ids\n        ", "18": "verifies that GET /batches_status\n        ", "19": "verifies that GET /batches_status with many ids\n        ", "20": "verifies that GET /batches_status with bad ids\n        ", "21": "verifies that GET /batches_status with invalid query\n        ", "22": "verifies that GET /batches_status with waiting time\n        ", "23": "verifies that GET /batches_status is unreachable with invalid\n        ", "24": "verifies that GET /batches_status with unknown \n        ", "25": "verifies that GET /batches_status is unreachable with default wait time\n        "}, "setup": {"duration": 0.0004627704620361328, "outcome": "passed"}, "call": {"duration": 0.014442682266235352, "outcome": "passed"}, "teardown": {"duration": 0.0002467632293701172, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::test_api_post_batch_status_15ids", "lineno": 516, "outcome": "passed", "keywords": ["api_test", "run", "second", "TestBatchStatusesList", "get/test_rest_api_get_batch.py", "batch", "test_api_post_batch_status_15ids", "get", "()"], "metadata": {"0": "Tests the batch list by submitting intkey batches\n        ", "1": "Tests that GET /batches is reachable with head parameter \n        ", "2": "Tests that GET /batches is unreachable with bad head parameter \n        ", "3": "Tests that GET /batches is reachable with id as parameter \n        ", "4": "Tests that GET /batches is unreachable with bad id parameter \n        ", "5": "Tests GET /batches is reachable with head and id as parameters \n        ", "6": "Tests GET /batches is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable with limit \n        ", "8": "Tests that GET /batches is unreachable with invalid start parameter \n        ", "9": "Tests that GET /batches is unreachable with bad limit parameter \n        ", "10": "verifies that GET /batches is unreachable with bad head parameter \n        ", "11": "Tests/ validate the block key parameters with data, head, link and paging               \n        ", "12": "Tests/ validate the batch parameters with batches, head, start and limit\n        ", "13": "Tests batches count from batch list \n        ", "14": "verifies that GET /batches/{batch_id} \nis reachable with head parameter ", "15": "verifies that GET /batches/{bad_batch_id} \nis unreachable with bad head parameter ", "16": "verifies that POST /batches_statuses with more than 15 ids\n        ", "17": "verifies that POST /batches_status with less than 10 ids\n        ", "18": "verifies that GET /batches_status\n        ", "19": "verifies that GET /batches_status with many ids\n        ", "20": "verifies that GET /batches_status with bad ids\n        ", "21": "verifies that GET /batches_status with invalid query\n        ", "22": "verifies that GET /batches_status with waiting time\n        ", "23": "verifies that GET /batches_status is unreachable with invalid\n        ", "24": "verifies that GET /batches_status with unknown \n        ", "25": "verifies that GET /batches_status is unreachable with default wait time\n        "}, "setup": {"duration": 0.0004398822784423828, "outcome": "passed"}, "call": {"duration": 0.016304969787597656, "outcome": "passed", "log": [{"name": "test_rest_api_get_batch", "msg": "Starting test for batch with bad head parameter", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_batch.py", "filename": "test_rest_api_get_batch.py", "module": "test_rest_api_get_batch", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 520, "funcName": "test_api_post_batch_status_15ids", "created": 1552988180.4612782, "msecs": 461.27820014953613, "relativeCreated": 301318.69888305664, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:20"}]}, "teardown": {"duration": 0.00024771690368652344, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::test_api_post_batch_status_10ids", "lineno": 534, "outcome": "passed", "keywords": ["run", "second", "TestBatchStatusesList", "get/test_rest_api_get_batch.py", "batch", "api_test", "get", "()", "test_api_post_batch_status_10ids"], "metadata": {"0": "Tests the batch list by submitting intkey batches\n        ", "1": "Tests that GET /batches is reachable with head parameter \n        ", "2": "Tests that GET /batches is unreachable with bad head parameter \n        ", "3": "Tests that GET /batches is reachable with id as parameter \n        ", "4": "Tests that GET /batches is unreachable with bad id parameter \n        ", "5": "Tests GET /batches is reachable with head and id as parameters \n        ", "6": "Tests GET /batches is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable with limit \n        ", "8": "Tests that GET /batches is unreachable with invalid start parameter \n        ", "9": "Tests that GET /batches is unreachable with bad limit parameter \n        ", "10": "verifies that GET /batches is unreachable with bad head parameter \n        ", "11": "Tests/ validate the block key parameters with data, head, link and paging               \n        ", "12": "Tests/ validate the batch parameters with batches, head, start and limit\n        ", "13": "Tests batches count from batch list \n        ", "14": "verifies that GET /batches/{batch_id} \nis reachable with head parameter ", "15": "verifies that GET /batches/{bad_batch_id} \nis unreachable with bad head parameter ", "16": "verifies that POST /batches_statuses with more than 15 ids\n        ", "17": "verifies that POST /batches_status with less than 10 ids\n        ", "18": "verifies that GET /batches_status\n        ", "19": "verifies that GET /batches_status with many ids\n        ", "20": "verifies that GET /batches_status with bad ids\n        ", "21": "verifies that GET /batches_status with invalid query\n        ", "22": "verifies that GET /batches_status with waiting time\n        ", "23": "verifies that GET /batches_status is unreachable with invalid\n        ", "24": "verifies that GET /batches_status with unknown \n        ", "25": "verifies that GET /batches_status is unreachable with default wait time\n        "}, "setup": {"duration": 0.00046324729919433594, "outcome": "passed"}, "call": {"duration": 0.01679253578186035, "outcome": "passed", "log": [{"name": "test_rest_api_get_batch", "msg": "Starting test for post batch statuses with less than 15 ids", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_batch.py", "filename": "test_rest_api_get_batch.py", "module": "test_rest_api_get_batch", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 538, "funcName": "test_api_post_batch_status_10ids", "created": 1552988180.4791508, "msecs": 479.15077209472656, "relativeCreated": 301336.57145500183, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:20"}]}, "teardown": {"duration": 0.0002510547637939453, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::test_api_get_batch_statuses", "lineno": 552, "outcome": "failed", "keywords": ["()", "run", "second", "TestBatchStatusesList", "get/test_rest_api_get_batch.py", "batch", "api_test", "get", "test_api_get_batch_statuses"], "metadata": {"0": "Tests the batch list by submitting intkey batches\n        ", "1": "Tests that GET /batches is reachable with head parameter \n        ", "2": "Tests that GET /batches is unreachable with bad head parameter \n        ", "3": "Tests that GET /batches is reachable with id as parameter \n        ", "4": "Tests that GET /batches is unreachable with bad id parameter \n        ", "5": "Tests GET /batches is reachable with head and id as parameters \n        ", "6": "Tests GET /batches is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable with limit \n        ", "8": "Tests that GET /batches is unreachable with invalid start parameter \n        ", "9": "Tests that GET /batches is unreachable with bad limit parameter \n        ", "10": "verifies that GET /batches is unreachable with bad head parameter \n        ", "11": "Tests/ validate the block key parameters with data, head, link and paging               \n        ", "12": "Tests/ validate the batch parameters with batches, head, start and limit\n        ", "13": "Tests batches count from batch list \n        ", "14": "verifies that GET /batches/{batch_id} \nis reachable with head parameter ", "15": "verifies that GET /batches/{bad_batch_id} \nis unreachable with bad head parameter ", "16": "verifies that POST /batches_statuses with more than 15 ids\n        ", "17": "verifies that POST /batches_status with less than 10 ids\n        ", "18": "verifies that GET /batches_status\n        ", "19": "verifies that GET /batches_status with many ids\n        ", "20": "verifies that GET /batches_status with bad ids\n        ", "21": "verifies that GET /batches_status with invalid query\n        ", "22": "verifies that GET /batches_status with waiting time\n        ", "23": "verifies that GET /batches_status is unreachable with invalid\n        ", "24": "verifies that GET /batches_status with unknown \n        ", "25": "verifies that GET /batches_status is unreachable with default wait time\n        "}, "setup": {"duration": 0.0004658699035644531, "outcome": "passed"}, "call": {"duration": 0.003928184509277344, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/base.py", "lineno": 41, "message": "AssertionError"}, "traceback": [{"path": "get/test_rest_api_get_batch.py", "lineno": 572, "message": ""}, {"path": "base.py", "lineno": 41, "message": "AssertionError"}], "longrepr": "self = <test_rest_api_get_batch.TestBatchStatusesList object at 0x7fd599a9d6d8>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_get_batch_statuses(self,setup):\n        \"\"\"verifies that GET /batches_status\n        \"\"\"\n        signer_key = setup['signer_key']\n        address = setup['address']\n        expected_head = setup['expected_head']\n        expected_batches = setup['expected_batches']\n        status = \"COMMITTED\"\n        expected_link = '{}/batch_statuses?id={}'.format(address, expected_batches[0])\n        params = {'id': expected_batches[0]}\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.get(url='{}/batch_statuses'.format(address),\n                                        params=params) as data:\n                    response = await data.json()\n        except aiohttp.client_exceptions.ClientResponseError as error:\n            LOGGER.info(error)\n    \n>       self.assert_status(response,status)\n\nget/test_rest_api_get_batch.py:572: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <test_rest_api_get_batch.TestBatchStatusesList object at 0x7fd599a9d6d8>\nresponse = {'data': [{'id': '8ce16f2f313430ddba62196370379d3b27092209fcf2233cbb251929b6e44c772e8e02fa0af16b29352526b67b2c398f732a...430ddba62196370379d3b27092209fcf2233cbb251929b6e44c772e8e02fa0af16b29352526b67b2c398f732a7ecdf9256bc6b63bd0d850ae62c8'}\nstatus = 'COMMITTED'\n\n    def assert_status(self, response, status):\n        for data in response['data']:\n>           assert data['status'] == status\nE           AssertionError\n\nbase.py:41: AssertionError"}, "teardown": {"duration": 0.0002512931823730469, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::test_api_get_batch_statuses_many_ids", "lineno": 574, "outcome": "failed", "keywords": ["run", "second", "test_api_get_batch_statuses_many_ids", "TestBatchStatusesList", "get/test_rest_api_get_batch.py", "batch", "api_test", "get", "()"], "metadata": {"0": "Tests the batch list by submitting intkey batches\n        ", "1": "Tests that GET /batches is reachable with head parameter \n        ", "2": "Tests that GET /batches is unreachable with bad head parameter \n        ", "3": "Tests that GET /batches is reachable with id as parameter \n        ", "4": "Tests that GET /batches is unreachable with bad id parameter \n        ", "5": "Tests GET /batches is reachable with head and id as parameters \n        ", "6": "Tests GET /batches is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable with limit \n        ", "8": "Tests that GET /batches is unreachable with invalid start parameter \n        ", "9": "Tests that GET /batches is unreachable with bad limit parameter \n        ", "10": "verifies that GET /batches is unreachable with bad head parameter \n        ", "11": "Tests/ validate the block key parameters with data, head, link and paging               \n        ", "12": "Tests/ validate the batch parameters with batches, head, start and limit\n        ", "13": "Tests batches count from batch list \n        ", "14": "verifies that GET /batches/{batch_id} \nis reachable with head parameter ", "15": "verifies that GET /batches/{bad_batch_id} \nis unreachable with bad head parameter ", "16": "verifies that POST /batches_statuses with more than 15 ids\n        ", "17": "verifies that POST /batches_status with less than 10 ids\n        ", "18": "verifies that GET /batches_status\n        ", "19": "verifies that GET /batches_status with many ids\n        ", "20": "verifies that GET /batches_status with bad ids\n        ", "21": "verifies that GET /batches_status with invalid query\n        ", "22": "verifies that GET /batches_status with waiting time\n        ", "23": "verifies that GET /batches_status is unreachable with invalid\n        ", "24": "verifies that GET /batches_status with unknown \n        ", "25": "verifies that GET /batches_status is unreachable with default wait time\n        "}, "setup": {"duration": 0.00046539306640625, "outcome": "passed"}, "call": {"duration": 0.0039179325103759766, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/base.py", "lineno": 41, "message": "AssertionError"}, "traceback": [{"path": "get/test_rest_api_get_batch.py", "lineno": 596, "message": ""}, {"path": "base.py", "lineno": 41, "message": "AssertionError"}], "longrepr": "self = <test_rest_api_get_batch.TestBatchStatusesList object at 0x7fd599b17160>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_get_batch_statuses_many_ids(self,setup):\n        \"\"\"verifies that GET /batches_status with many ids\n        \"\"\"\n        signer_key = setup['signer_key']\n        expected_head = setup['expected_head']\n        expected_batches = setup['expected_batches']\n        address = setup['address']\n        status = \"COMMITTED\"\n        batches = \",\".join(expected_batches)\n        params = {'id': batches}\n    \n        expected_link = '{}/batch_statuses?id={}'.format(address, batches)\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.get(url='{}/batch_statuses'.format(address),\n                                        params=params) as data:\n                    response = await data.json()\n        except aiohttp.client_exceptions.ClientResponseError as error:\n            LOGGER.info(error)\n    \n>       self.assert_status(response,status)\n\nget/test_rest_api_get_batch.py:596: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <test_rest_api_get_batch.TestBatchStatusesList object at 0x7fd599b17160>\nresponse = {'data': [{'id': '8ce16f2f313430ddba62196370379d3b27092209fcf2233cbb251929b6e44c772e8e02fa0af16b29352526b67b2c398f732a...430ddba62196370379d3b27092209fcf2233cbb251929b6e44c772e8e02fa0af16b29352526b67b2c398f732a7ecdf9256bc6b63bd0d850ae62c8'}\nstatus = 'COMMITTED'\n\n    def assert_status(self, response, status):\n        for data in response['data']:\n>           assert data['status'] == status\nE           AssertionError\n\nbase.py:41: AssertionError"}, "teardown": {"duration": 0.00025153160095214844, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::test_api_get_batch_statuses_bad_id", "lineno": 598, "outcome": "passed", "keywords": ["test_api_get_batch_statuses_bad_id", "run", "second", "TestBatchStatusesList", "get/test_rest_api_get_batch.py", "batch", "api_test", "get", "()"], "metadata": {"0": "Tests the batch list by submitting intkey batches\n        ", "1": "Tests that GET /batches is reachable with head parameter \n        ", "2": "Tests that GET /batches is unreachable with bad head parameter \n        ", "3": "Tests that GET /batches is reachable with id as parameter \n        ", "4": "Tests that GET /batches is unreachable with bad id parameter \n        ", "5": "Tests GET /batches is reachable with head and id as parameters \n        ", "6": "Tests GET /batches is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable with limit \n        ", "8": "Tests that GET /batches is unreachable with invalid start parameter \n        ", "9": "Tests that GET /batches is unreachable with bad limit parameter \n        ", "10": "verifies that GET /batches is unreachable with bad head parameter \n        ", "11": "Tests/ validate the block key parameters with data, head, link and paging               \n        ", "12": "Tests/ validate the batch parameters with batches, head, start and limit\n        ", "13": "Tests batches count from batch list \n        ", "14": "verifies that GET /batches/{batch_id} \nis reachable with head parameter ", "15": "verifies that GET /batches/{bad_batch_id} \nis unreachable with bad head parameter ", "16": "verifies that POST /batches_statuses with more than 15 ids\n        ", "17": "verifies that POST /batches_status with less than 10 ids\n        ", "18": "verifies that GET /batches_status\n        ", "19": "verifies that GET /batches_status with many ids\n        ", "20": "verifies that GET /batches_status with bad ids\n        ", "21": "verifies that GET /batches_status with invalid query\n        ", "22": "verifies that GET /batches_status with waiting time\n        ", "23": "verifies that GET /batches_status is unreachable with invalid\n        ", "24": "verifies that GET /batches_status with unknown \n        ", "25": "verifies that GET /batches_status is unreachable with default wait time\n        "}, "setup": {"duration": 0.00045609474182128906, "outcome": "passed"}, "call": {"duration": 0.014553546905517578, "outcome": "passed"}, "teardown": {"duration": 0.0002422332763671875, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::test_api_get_batch_statuses_invalid_query", "lineno": 617, "outcome": "passed", "keywords": ["run", "test_api_get_batch_statuses_invalid_query", "second", "TestBatchStatusesList", "get/test_rest_api_get_batch.py", "batch", "api_test", "get", "()"], "metadata": {"0": "Tests the batch list by submitting intkey batches\n        ", "1": "Tests that GET /batches is reachable with head parameter \n        ", "2": "Tests that GET /batches is unreachable with bad head parameter \n        ", "3": "Tests that GET /batches is reachable with id as parameter \n        ", "4": "Tests that GET /batches is unreachable with bad id parameter \n        ", "5": "Tests GET /batches is reachable with head and id as parameters \n        ", "6": "Tests GET /batches is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable with limit \n        ", "8": "Tests that GET /batches is unreachable with invalid start parameter \n        ", "9": "Tests that GET /batches is unreachable with bad limit parameter \n        ", "10": "verifies that GET /batches is unreachable with bad head parameter \n        ", "11": "Tests/ validate the block key parameters with data, head, link and paging               \n        ", "12": "Tests/ validate the batch parameters with batches, head, start and limit\n        ", "13": "Tests batches count from batch list \n        ", "14": "verifies that GET /batches/{batch_id} \nis reachable with head parameter ", "15": "verifies that GET /batches/{bad_batch_id} \nis unreachable with bad head parameter ", "16": "verifies that POST /batches_statuses with more than 15 ids\n        ", "17": "verifies that POST /batches_status with less than 10 ids\n        ", "18": "verifies that GET /batches_status\n        ", "19": "verifies that GET /batches_status with many ids\n        ", "20": "verifies that GET /batches_status with bad ids\n        ", "21": "verifies that GET /batches_status with invalid query\n        ", "22": "verifies that GET /batches_status with waiting time\n        ", "23": "verifies that GET /batches_status is unreachable with invalid\n        ", "24": "verifies that GET /batches_status with unknown \n        ", "25": "verifies that GET /batches_status is unreachable with default wait time\n        "}, "setup": {"duration": 0.00044989585876464844, "outcome": "passed"}, "call": {"duration": 0.01452016830444336, "outcome": "passed"}, "teardown": {"duration": 0.00024628639221191406, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::test_api_get_batch_statuses_wait", "lineno": 634, "outcome": "failed", "keywords": ["test_api_get_batch_statuses_wait", "run", "second", "TestBatchStatusesList", "get/test_rest_api_get_batch.py", "batch", "api_test", "get", "()"], "metadata": {"0": "Tests the batch list by submitting intkey batches\n        ", "1": "Tests that GET /batches is reachable with head parameter \n        ", "2": "Tests that GET /batches is unreachable with bad head parameter \n        ", "3": "Tests that GET /batches is reachable with id as parameter \n        ", "4": "Tests that GET /batches is unreachable with bad id parameter \n        ", "5": "Tests GET /batches is reachable with head and id as parameters \n        ", "6": "Tests GET /batches is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable with limit \n        ", "8": "Tests that GET /batches is unreachable with invalid start parameter \n        ", "9": "Tests that GET /batches is unreachable with bad limit parameter \n        ", "10": "verifies that GET /batches is unreachable with bad head parameter \n        ", "11": "Tests/ validate the block key parameters with data, head, link and paging               \n        ", "12": "Tests/ validate the batch parameters with batches, head, start and limit\n        ", "13": "Tests batches count from batch list \n        ", "14": "verifies that GET /batches/{batch_id} \nis reachable with head parameter ", "15": "verifies that GET /batches/{bad_batch_id} \nis unreachable with bad head parameter ", "16": "verifies that POST /batches_statuses with more than 15 ids\n        ", "17": "verifies that POST /batches_status with less than 10 ids\n        ", "18": "verifies that GET /batches_status\n        ", "19": "verifies that GET /batches_status with many ids\n        ", "20": "verifies that GET /batches_status with bad ids\n        ", "21": "verifies that GET /batches_status with invalid query\n        ", "22": "verifies that GET /batches_status with waiting time\n        ", "23": "verifies that GET /batches_status is unreachable with invalid\n        ", "24": "verifies that GET /batches_status with unknown \n        ", "25": "verifies that GET /batches_status is unreachable with default wait time\n        "}, "setup": {"duration": 0.0004642009735107422, "outcome": "passed"}, "call": {"duration": 10.008514881134033, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/base.py", "lineno": 41, "message": "AssertionError"}, "traceback": [{"path": "get/test_rest_api_get_batch.py", "lineno": 657, "message": ""}, {"path": "base.py", "lineno": 41, "message": "AssertionError"}], "longrepr": "self = <test_rest_api_get_batch.TestBatchStatusesList object at 0x7fd599b2abe0>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_get_batch_statuses_wait(self,setup):\n        \"\"\"verifies that GET /batches_status with waiting time\n        \"\"\"\n        signer_key = setup['signer_key']\n        expected_head = setup['expected_head']\n        expected_batches = setup['expected_batches']\n        address = setup['address']\n        status = \"COMMITTED\"\n    \n        expected_link = '{}/batch_statuses?id={}&wait={}'.format(address, expected_batches[0], WAIT)\n    \n        params = {'id': expected_batches[0], 'wait':WAIT}\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.get(url='{}/batch_statuses'.format(address),\n                                        params=params) as data:\n                    response = await data.json()\n        except aiohttp.client_exceptions.ClientResponseError as error:\n            LOGGER.info(error)\n    \n    \n>       self.assert_status(response,status)\n\nget/test_rest_api_get_batch.py:657: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <test_rest_api_get_batch.TestBatchStatusesList object at 0x7fd599b2abe0>\nresponse = {'data': [{'id': '8ce16f2f313430ddba62196370379d3b27092209fcf2233cbb251929b6e44c772e8e02fa0af16b29352526b67b2c398f732a...2196370379d3b27092209fcf2233cbb251929b6e44c772e8e02fa0af16b29352526b67b2c398f732a7ecdf9256bc6b63bd0d850ae62c8&wait=10'}\nstatus = 'COMMITTED'\n\n    def assert_status(self, response, status):\n        for data in response['data']:\n>           assert data['status'] == status\nE           AssertionError\n\nbase.py:41: AssertionError"}, "teardown": {"duration": 0.0002529621124267578, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::test_api_get_batch_statuses_invalid", "lineno": 660, "outcome": "failed", "keywords": ["run", "get", "second", "TestBatchStatusesList", "get/test_rest_api_get_batch.py", "batch", "api_test", "test_api_get_batch_statuses_invalid", "()"], "metadata": {"0": "Tests the batch list by submitting intkey batches\n        ", "1": "Tests that GET /batches is reachable with head parameter \n        ", "2": "Tests that GET /batches is unreachable with bad head parameter \n        ", "3": "Tests that GET /batches is reachable with id as parameter \n        ", "4": "Tests that GET /batches is unreachable with bad id parameter \n        ", "5": "Tests GET /batches is reachable with head and id as parameters \n        ", "6": "Tests GET /batches is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable with limit \n        ", "8": "Tests that GET /batches is unreachable with invalid start parameter \n        ", "9": "Tests that GET /batches is unreachable with bad limit parameter \n        ", "10": "verifies that GET /batches is unreachable with bad head parameter \n        ", "11": "Tests/ validate the block key parameters with data, head, link and paging               \n        ", "12": "Tests/ validate the batch parameters with batches, head, start and limit\n        ", "13": "Tests batches count from batch list \n        ", "14": "verifies that GET /batches/{batch_id} \nis reachable with head parameter ", "15": "verifies that GET /batches/{bad_batch_id} \nis unreachable with bad head parameter ", "16": "verifies that POST /batches_statuses with more than 15 ids\n        ", "17": "verifies that POST /batches_status with less than 10 ids\n        ", "18": "verifies that GET /batches_status\n        ", "19": "verifies that GET /batches_status with many ids\n        ", "20": "verifies that GET /batches_status with bad ids\n        ", "21": "verifies that GET /batches_status with invalid query\n        ", "22": "verifies that GET /batches_status with waiting time\n        ", "23": "verifies that GET /batches_status is unreachable with invalid\n        ", "24": "verifies that GET /batches_status with unknown \n        ", "25": "verifies that GET /batches_status is unreachable with default wait time\n        "}, "setup": {"duration": 300.0284912586212, "outcome": "passed", "log": [{"name": "fixtures", "msg": "Creating intkey transactions with set operations", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/fixtures.py", "filename": "fixtures.py", "module": "fixtures", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 92, "funcName": "invalid_batch", "created": 1552988190.5998437, "msecs": 599.8437404632568, "relativeCreated": 311457.26442337036, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:30"}, {"name": "fixtures", "msg": "Creating batches for transactions 1trn/batch", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/fixtures.py", "filename": "fixtures.py", "module": "fixtures", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 107, "funcName": "invalid_batch", "created": 1552988190.6086988, "msecs": 608.698844909668, "relativeCreated": 311466.1195278168, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:06:30"}, {"name": "fixtures", "msg": "Rest Api is not reachable", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/fixtures.py", "filename": "fixtures.py", "module": "fixtures", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 130, "funcName": "invalid_batch", "created": 1552988490.6239574, "msecs": 623.9573955535889, "relativeCreated": 611481.3780784607, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:11:30"}, {"name": "fixtures", "msg": "Validator Timed Out", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/fixtures.py", "filename": "fixtures.py", "module": "fixtures", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 132, "funcName": "invalid_batch", "created": 1552988490.624984, "msecs": 624.9840259552002, "relativeCreated": 611482.4047088623, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:11:30"}, {"name": "fixtures", "msg": "The request timed out while waiting for a response from the validator. Your request may or may not have been processed.", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/fixtures.py", "filename": "fixtures.py", "module": "fixtures", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 133, "funcName": "invalid_batch", "created": 1552988490.625051, "msecs": 625.0510215759277, "relativeCreated": 611482.471704483, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:11:30"}]}, "call": {"duration": 0.004826784133911133, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/base.py", "lineno": 41, "message": "AssertionError"}, "traceback": [{"path": "get/test_rest_api_get_batch.py", "lineno": 678, "message": ""}, {"path": "base.py", "lineno": 41, "message": "AssertionError"}], "longrepr": "self = <test_rest_api_get_batch.TestBatchStatusesList object at 0x7fd599b14d30>\ninvalid_batch = {'address': 'http://192.168.1.23:8008', 'expected_batches': ['12ea04fdf5e10cb1b5412a7828cc61a96f5919702aa1d8208103f2c9...9192476256dd083334973f4231fcc6936a54d5c78bd56d5718f84e2d0e90d13b2d28eaa2b7b72579324cab00993912b570f98947976977c8c3ec']}\n\n    async def test_api_get_batch_statuses_invalid(self, invalid_batch):\n        \"\"\"verifies that GET /batches_status is unreachable with invalid\n        \"\"\"\n        expected_batches = invalid_batch['expected_batches']\n        address = invalid_batch['address']\n        status = \"INVALID\"\n        expected_link = '{}/batch_statuses?id={}'.format(address, expected_batches[0])\n        params = {'id': expected_batches[0]}\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.get(url='{}/batch_statuses'.format(address),\n                                        params=params) as data:\n                    response = await data.json()\n        except aiohttp.client_exceptions.ClientResponseError as error:\n            LOGGER.info(error)\n    \n>       self.assert_status(response,status)\n\nget/test_rest_api_get_batch.py:678: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <test_rest_api_get_batch.TestBatchStatusesList object at 0x7fd599b14d30>\nresponse = {'data': [{'id': '12ea04fdf5e10cb1b5412a7828cc61a96f5919702aa1d8208103f2c9842f7a27681d47457d2625fd66ed21dcb3aa7cd86823...10cb1b5412a7828cc61a96f5919702aa1d8208103f2c9842f7a27681d47457d2625fd66ed21dcb3aa7cd8682360992c8683d7c3ee5b1b7f27d4a9'}\nstatus = 'INVALID'\n\n    def assert_status(self, response, status):\n        for data in response['data']:\n>           assert data['status'] == status\nE           AssertionError\n\nbase.py:41: AssertionError"}, "teardown": {"duration": 0.00032448768615722656, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::test_api_get_batch_statuses_unknown", "lineno": 681, "outcome": "passed", "keywords": ["test_api_get_batch_statuses_unknown", "run", "second", "TestBatchStatusesList", "get/test_rest_api_get_batch.py", "batch", "api_test", "get", "()"], "metadata": {"0": "Tests the batch list by submitting intkey batches\n        ", "1": "Tests that GET /batches is reachable with head parameter \n        ", "2": "Tests that GET /batches is unreachable with bad head parameter \n        ", "3": "Tests that GET /batches is reachable with id as parameter \n        ", "4": "Tests that GET /batches is unreachable with bad id parameter \n        ", "5": "Tests GET /batches is reachable with head and id as parameters \n        ", "6": "Tests GET /batches is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable with limit \n        ", "8": "Tests that GET /batches is unreachable with invalid start parameter \n        ", "9": "Tests that GET /batches is unreachable with bad limit parameter \n        ", "10": "verifies that GET /batches is unreachable with bad head parameter \n        ", "11": "Tests/ validate the block key parameters with data, head, link and paging               \n        ", "12": "Tests/ validate the batch parameters with batches, head, start and limit\n        ", "13": "Tests batches count from batch list \n        ", "14": "verifies that GET /batches/{batch_id} \nis reachable with head parameter ", "15": "verifies that GET /batches/{bad_batch_id} \nis unreachable with bad head parameter ", "16": "verifies that POST /batches_statuses with more than 15 ids\n        ", "17": "verifies that POST /batches_status with less than 10 ids\n        ", "18": "verifies that GET /batches_status\n        ", "19": "verifies that GET /batches_status with many ids\n        ", "20": "verifies that GET /batches_status with bad ids\n        ", "21": "verifies that GET /batches_status with invalid query\n        ", "22": "verifies that GET /batches_status with waiting time\n        ", "23": "verifies that GET /batches_status is unreachable with invalid\n        ", "24": "verifies that GET /batches_status with unknown \n        ", "25": "verifies that GET /batches_status is unreachable with default wait time\n        "}, "setup": {"duration": 0.0005562305450439453, "outcome": "passed"}, "call": {"duration": 0.018784284591674805, "outcome": "passed"}, "teardown": {"duration": 0.00022840499877929688, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_batch.py::TestBatchStatusesList::test_api_get_batch_statuses_default_wait", "lineno": 704, "outcome": "failed", "keywords": ["api_test", "run", "second", "TestBatchStatusesList", "get/test_rest_api_get_batch.py", "batch", "test_api_get_batch_statuses_default_wait", "get", "()"], "metadata": {"0": "Tests the batch list by submitting intkey batches\n        ", "1": "Tests that GET /batches is reachable with head parameter \n        ", "2": "Tests that GET /batches is unreachable with bad head parameter \n        ", "3": "Tests that GET /batches is reachable with id as parameter \n        ", "4": "Tests that GET /batches is unreachable with bad id parameter \n        ", "5": "Tests GET /batches is reachable with head and id as parameters \n        ", "6": "Tests GET /batches is reachable using paging parameters \n        ", "7": "Tests GET /batches is reachable with limit \n        ", "8": "Tests that GET /batches is unreachable with invalid start parameter \n        ", "9": "Tests that GET /batches is unreachable with bad limit parameter \n        ", "10": "verifies that GET /batches is unreachable with bad head parameter \n        ", "11": "Tests/ validate the block key parameters with data, head, link and paging               \n        ", "12": "Tests/ validate the batch parameters with batches, head, start and limit\n        ", "13": "Tests batches count from batch list \n        ", "14": "verifies that GET /batches/{batch_id} \nis reachable with head parameter ", "15": "verifies that GET /batches/{bad_batch_id} \nis unreachable with bad head parameter ", "16": "verifies that POST /batches_statuses with more than 15 ids\n        ", "17": "verifies that POST /batches_status with less than 10 ids\n        ", "18": "verifies that GET /batches_status\n        ", "19": "verifies that GET /batches_status with many ids\n        ", "20": "verifies that GET /batches_status with bad ids\n        ", "21": "verifies that GET /batches_status with invalid query\n        ", "22": "verifies that GET /batches_status with waiting time\n        ", "23": "verifies that GET /batches_status is unreachable with invalid\n        ", "24": "verifies that GET /batches_status with unknown \n        ", "25": "verifies that GET /batches_status is unreachable with default wait time\n        "}, "setup": {"duration": 0.00045228004455566406, "outcome": "passed"}, "call": {"duration": 300.00816226005554, "outcome": "failed", "crash": {"path": "/usr/lib/python3/dist-packages/aiohttp/helpers.py", "lineno": 656, "message": "concurrent.futures._base.TimeoutError"}, "traceback": [{"path": "get/test_rest_api_get_batch.py", "lineno": 719, "message": ""}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 779, "message": "in __aenter__"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 331, "message": "in _request"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client_reqrep.py", "lineno": 691, "message": "in start"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/helpers.py", "lineno": 656, "message": "TimeoutError"}], "longrepr": "self = <test_rest_api_get_batch.TestBatchStatusesList object at 0x7fd599a636d8>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_get_batch_statuses_default_wait(self,setup):\n        \"\"\"verifies that GET /batches_status is unreachable with default wait time\n        \"\"\"\n        signer_key = setup['signer_key']\n        expected_head = setup['expected_head']\n        expected_batches = setup['expected_batches']\n        address = setup['address']\n        status = \"COMMITTED\"\n        expected_link = '{}/batch_statuses?id={}&wait=300'.format(address, expected_batches[0])\n        params = {'id': expected_batches[0], 'wait':300}\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.get(url='{}/batch_statuses'.format(address),\n>                                       params=params) as data:\n\nget/test_rest_api_get_batch.py:719: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3/dist-packages/aiohttp/client.py:779: in __aenter__\n    self._resp = await self._coro\n/usr/lib/python3/dist-packages/aiohttp/client.py:331: in _request\n    await resp.start(conn, read_until_eof)\n/usr/lib/python3/dist-packages/aiohttp/client_reqrep.py:691: in start\n    self._continue = None\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <aiohttp.helpers.TimerContext object at 0x7fd599a638d0>, exc_type = <class 'concurrent.futures._base.CancelledError'>, exc_val = CancelledError()\nexc_tb = <traceback object at 0x7fd599c2cc88>\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self._tasks:\n            self._tasks.pop()\n    \n        if exc_type is asyncio.CancelledError and self._cancelled:\n>           raise asyncio.TimeoutError from None\nE           concurrent.futures._base.TimeoutError\n\n/usr/lib/python3/dist-packages/aiohttp/helpers.py:656: TimeoutError"}, "teardown": {"duration": 0.0002491474151611328, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_list", "lineno": 86, "outcome": "passed", "keywords": ["state", "run", "TestStateList", "third", "api_test", "get", "test_api_get_state_list", "()", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.00045418739318847656, "outcome": "passed"}, "call": {"duration": 0.021130800247192383, "outcome": "passed"}, "teardown": {"duration": 0.00022363662719726562, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_list_head", "lineno": 107, "outcome": "passed", "keywords": ["state", "run", "test_api_get_state_list_head", "TestStateList", "api_test", "get", "third", "()", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.00044465065002441406, "outcome": "passed"}, "call": {"duration": 0.020030498504638672, "outcome": "passed", "log": [{"name": "test_rest_api_get_state", "msg": "Starting test for state with head parameter", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_state.py", "filename": "test_rest_api_get_state.py", "module": "test_rest_api_get_state", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 111, "funcName": "test_api_get_state_list_head", "created": 1552988790.749581, "msecs": 749.5810985565186, "relativeCreated": 911607.0017814636, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:16:30"}]}, "teardown": {"duration": 0.00022935867309570312, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_list_invalid_batch", "lineno": 130, "outcome": "passed", "keywords": ["state", "()", "run", "TestStateList", "api_test", "get", "third", "test_api_get_state_list_invalid_batch", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 300.0300509929657, "outcome": "passed", "log": [{"name": "fixtures", "msg": "Creating intkey transactions with set operations", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/fixtures.py", "filename": "fixtures.py", "module": "fixtures", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 92, "funcName": "invalid_batch", "created": 1552988790.7729905, "msecs": 772.9904651641846, "relativeCreated": 911630.4111480713, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:16:30"}, {"name": "fixtures", "msg": "Creating batches for transactions 1trn/batch", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/fixtures.py", "filename": "fixtures.py", "module": "fixtures", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 107, "funcName": "invalid_batch", "created": 1552988790.7819543, "msecs": 781.954288482666, "relativeCreated": 911639.3749713898, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:16:30"}]}, "call": {"duration": 0.024996280670166016, "outcome": "passed"}, "teardown": {"duration": 0.00027871131896972656, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_list_bad_head", "lineno": 143, "outcome": "failed", "keywords": ["state", "run", "test_api_get_state_list_bad_head", "TestStateList", "api_test", "get", "third", "()", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.0005171298980712891, "outcome": "passed"}, "call": {"duration": 0.006123781204223633, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_state.py", "lineno": 160, "message": "UnboundLocalError: local variable 'response' referenced before assignment"}, "traceback": [{"path": "get/test_rest_api_get_state.py", "lineno": 160, "message": "UnboundLocalError"}], "log": [{"name": "test_rest_api_get_state", "msg": "Starting test for state with bad head parameter", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_state.py", "filename": "test_rest_api_get_state.py", "module": "test_rest_api_get_state", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 148, "funcName": "test_api_get_state_list_bad_head", "created": 1552989090.827862, "msecs": 827.862024307251, "relativeCreated": 1211685.2827072144, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:30"}, {"name": "test_rest_api_get_state", "msg": "0, message='Attempt to decode JSON with unexpected mimetype: text/html; charset=utf-8'", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_state.py", "filename": "test_rest_api_get_state.py", "module": "test_rest_api_get_state", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 158, "funcName": "test_api_get_state_list_bad_head", "created": 1552989090.8332574, "msecs": 833.2574367523193, "relativeCreated": 1211690.6781196594, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:30"}], "longrepr": "self = <test_rest_api_get_state.TestStateList object at 0x7fd599a7f860>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_get_state_list_bad_head(self, setup):\n        \"\"\"Tests that GET /state is unreachable with bad head parameter\n        \"\"\"\n        address = setup['address']\n        LOGGER.info(\"Starting test for state with bad head parameter\")\n        bad_head = 'f'\n    \n        params={'head': BAD_HEAD}\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.get(url='{}/state'.format(address), params=params) as data:\n                    response = await data.json()\n        except aiohttp.client_exceptions.ClientResponseError as error:\n            LOGGER.info(error)\n    \n>       self.assert_valid_error(response, INVALID_RESOURCE_ID)\nE       UnboundLocalError: local variable 'response' referenced before assignment\n\nget/test_rest_api_get_state.py:160: UnboundLocalError"}, "teardown": {"duration": 0.0002639293670654297, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_list_address", "lineno": 162, "outcome": "passed", "keywords": ["state", "run", "test_api_get_state_list_address", "TestStateList", "api_test", "get", "third", "()", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.0004439353942871094, "outcome": "passed"}, "call": {"duration": 0.020821809768676758, "outcome": "passed", "log": [{"name": "test_rest_api_get_state", "msg": "Starting test for state with address parameter", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_state.py", "filename": "test_rest_api_get_state.py", "module": "test_rest_api_get_state", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 167, "funcName": "test_api_get_state_list_address", "created": 1552989090.8458955, "msecs": 845.895528793335, "relativeCreated": 1211703.3162117004, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:30"}]}, "teardown": {"duration": 0.00022530555725097656, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_list_bad_address", "lineno": 180, "outcome": "failed", "keywords": ["state", "run", "get", "TestStateList", "api_test", "test_api_get_state_list_bad_address", "third", "()", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.0004401206970214844, "outcome": "passed"}, "call": {"duration": 0.00887441635131836, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_state.py", "lineno": 195, "message": "UnboundLocalError: local variable 'response' referenced before assignment"}, "traceback": [{"path": "get/test_rest_api_get_state.py", "lineno": 195, "message": "UnboundLocalError"}], "log": [{"name": "test_rest_api_get_state", "msg": "Starting test for state with bad address parameter", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_state.py", "filename": "test_rest_api_get_state.py", "module": "test_rest_api_get_state", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 185, "funcName": "test_api_get_state_list_bad_address", "created": 1552989090.868115, "msecs": 868.1149482727051, "relativeCreated": 1211725.5356311798, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:30"}, {"name": "test_rest_api_get_state", "msg": "0, message='Attempt to decode JSON with unexpected mimetype: text/html; charset=utf-8'", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_state.py", "filename": "test_rest_api_get_state.py", "module": "test_rest_api_get_state", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 193, "funcName": "test_api_get_state_list_bad_address", "created": 1552989090.876418, "msecs": 876.4181137084961, "relativeCreated": 1211733.8387966156, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:30"}], "longrepr": "self = <test_rest_api_get_state.TestStateList object at 0x7fd599a377f0>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_get_state_list_bad_address(self, setup):\n        \"\"\"Tests that GET /state is unreachable with bad address parameter\n        \"\"\"\n        address = setup['address']\n        LOGGER.info(\"Starting test for state with bad address parameter\")\n        params = {'address': BAD_ADDRESS}\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.get(url='{}/state'.format(address), params=params) as data:\n                    response = await data.json()\n        except aiohttp.client_exceptions.ClientResponseError as error:\n            LOGGER.info(error)\n    \n>       self.assert_valid_error(response , INVALID_STATE_ADDRESS)\nE       UnboundLocalError: local variable 'response' referenced before assignment\n\nget/test_rest_api_get_state.py:195: UnboundLocalError"}, "teardown": {"duration": 0.00024580955505371094, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_paginated_state_list", "lineno": 196, "outcome": "passed", "keywords": ["state", "run", "TestStateList", "test_api_get_paginated_state_list", "api_test", "get", "third", "()", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.0004425048828125, "outcome": "passed"}, "call": {"duration": 0.02157902717590332, "outcome": "passed", "log": [{"name": "test_rest_api_get_state", "msg": "Starting test for state with paging parameters", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_state.py", "filename": "test_rest_api_get_state.py", "module": "test_rest_api_get_state", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 201, "funcName": "test_api_get_paginated_state_list", "created": 1552989090.88752, "msecs": 887.5200748443604, "relativeCreated": 1211744.9407577515, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:30"}]}, "teardown": {"duration": 0.00023674964904785156, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_paginated_state_list_limit", "lineno": 216, "outcome": "passed", "keywords": ["state", "run", "test_api_get_paginated_state_list_limit", "TestStateList", "api_test", "get", "third", "()", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.00047278404235839844, "outcome": "passed"}, "call": {"duration": 0.022152423858642578, "outcome": "passed", "log": [{"name": "test_rest_api_get_state", "msg": "Starting test for state with paging parameters", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_state.py", "filename": "test_rest_api_get_state.py", "module": "test_rest_api_get_state", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 221, "funcName": "test_api_get_paginated_state_list_limit", "created": 1552989090.9105418, "msecs": 910.5417728424072, "relativeCreated": 1211767.9624557495, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:30"}]}, "teardown": {"duration": 0.00024247169494628906, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_paginated_state_list_start", "lineno": 234, "outcome": "passed", "keywords": ["state", "run", "TestStateList", "third", "api_test", "get", "test_api_get_paginated_state_list_start", "()", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.0004723072052001953, "outcome": "passed"}, "call": {"duration": 0.02191901206970215, "outcome": "passed", "log": [{"name": "test_rest_api_get_state", "msg": "Starting test for state with paging parameters", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_state.py", "filename": "test_rest_api_get_state.py", "module": "test_rest_api_get_state", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 239, "funcName": "test_api_get_paginated_state_list_start", "created": 1552989090.9342659, "msecs": 934.2658519744873, "relativeCreated": 1211791.6865348816, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:30"}]}, "teardown": {"duration": 0.000240325927734375, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_list_bad_paging", "lineno": 252, "outcome": "passed", "keywords": ["state", "run", "test_api_get_state_list_bad_paging", "TestStateList", "api_test", "get", "third", "()", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.00046825408935546875, "outcome": "passed"}, "call": {"duration": 0.014595270156860352, "outcome": "passed", "log": [{"name": "test_rest_api_get_state", "msg": "Starting test for state with bad paging parameters", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_state.py", "filename": "test_rest_api_get_state.py", "module": "test_rest_api_get_state", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 257, "funcName": "test_api_get_state_list_bad_paging", "created": 1552989090.9577248, "msecs": 957.7248096466064, "relativeCreated": 1211815.1454925537, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:30"}]}, "teardown": {"duration": 0.0002474784851074219, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_list_invalid_start", "lineno": 272, "outcome": "passed", "keywords": ["state", "run", "test_api_get_state_list_invalid_start", "TestStateList", "api_test", "get", "third", "()", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.00047016143798828125, "outcome": "passed"}, "call": {"duration": 0.021932125091552734, "outcome": "passed", "log": [{"name": "test_rest_api_get_state", "msg": "Starting test for state with invalid start parameter", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_state.py", "filename": "test_rest_api_get_state.py", "module": "test_rest_api_get_state", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 277, "funcName": "test_api_get_state_list_invalid_start", "created": 1552989090.9738617, "msecs": 973.8616943359375, "relativeCreated": 1211831.282377243, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:30"}]}, "teardown": {"duration": 0.00024366378784179688, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_list_invalid_limit", "lineno": 292, "outcome": "passed", "keywords": ["state", "run", "test_api_get_state_list_invalid_limit", "TestStateList", "api_test", "get", "third", "()", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.00046253204345703125, "outcome": "passed"}, "call": {"duration": 0.015223026275634766, "outcome": "passed", "log": [{"name": "test_rest_api_get_state", "msg": "Starting test for state with bad limit parameter", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_state.py", "filename": "test_rest_api_get_state.py", "module": "test_rest_api_get_state", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 297, "funcName": "test_api_get_state_list_invalid_limit", "created": 1552989090.9973354, "msecs": 997.3354339599609, "relativeCreated": 1211854.756116867, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:30"}]}, "teardown": {"duration": 0.00025343894958496094, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_list_reversed", "lineno": 311, "outcome": "passed", "keywords": ["state", "test_api_get_state_list_reversed", "run", "TestStateList", "api_test", "get", "third", "()", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.0004851818084716797, "outcome": "passed"}, "call": {"duration": 0.022801637649536133, "outcome": "passed", "log": [{"name": "test_rest_api_get_state", "msg": "Starting test for state with bad head parameter", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_state.py", "filename": "test_rest_api_get_state.py", "module": "test_rest_api_get_state", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 316, "funcName": "test_api_get_state_list_reversed", "created": 1552989091.0141385, "msecs": 14.138460159301758, "relativeCreated": 1211871.5591430664, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:31"}]}, "teardown": {"duration": 0.0002491474151611328, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_data_address_prefix_namespace", "lineno": 332, "outcome": "passed", "keywords": ["state", "run", "test_api_get_state_data_address_prefix_namespace", "TestStateList", "api_test", "get", "third", "()", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.0004718303680419922, "outcome": "passed"}, "call": {"duration": 0.10889744758605957, "outcome": "passed"}, "teardown": {"duration": 0.0002694129943847656, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_data_head_wildcard_character", "lineno": 349, "outcome": "failed", "keywords": ["state", "run", "test_api_get_state_data_head_wildcard_character", "TestStateList", "api_test", "get", "third", "()", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.0004892349243164062, "outcome": "passed"}, "call": {"duration": 0.01492166519165039, "outcome": "failed", "crash": {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 650, "message": "urllib.error.HTTPError: HTTP Error 500: Internal Server Error"}, "traceback": [{"path": "get/test_rest_api_get_state.py", "lineno": 365, "message": ""}, {"path": "utils.py", "lineno": 151, "message": "in get_state_list"}, {"path": "utils.py", "lineno": 183, "message": "in query_rest_api"}, {"path": "utils.py", "lineno": 186, "message": "in submit_request"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 223, "message": "in urlopen"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 532, "message": "in open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 642, "message": "in http_response"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 570, "message": "in error"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 504, "message": "in _call_chain"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 650, "message": "HTTPError"}], "longrepr": "self = <test_rest_api_get_state.TestStateList object at 0x7fd599abf240>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_get_state_data_head_wildcard_character(self, setup):\n        \"\"\"Tests the state head with wildcard_character ***STL-1345***\n        \"\"\"\n        address = setup['address']\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.get(url='{}/state'.format(address)) as data:\n                    response = await data.json()\n    \n            for _ in response['data']:\n                expected_head = setup['expected_head'][:6]\n                addressList = list(expected_head)\n                addressList[2]='?'\n                expected_head = ''.join(addressList)\n                print(\"\\nVALUE is: \", expected_head)\n>               res=get_state_list(head_id=expected_head)\n\nget/test_rest_api_get_state.py:365: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nutils.py:151: in get_state_list\n    response = query_rest_api('/state?head=%s'% head_id)\nutils.py:183: in query_rest_api\n    return submit_request(urllib.request.Request(url, data, headers))\nutils.py:186: in submit_request\n    response = urllib.request.urlopen(request).read().decode('utf-8')\n/usr/lib/python3.6/urllib/request.py:223: in urlopen\n    return opener.open(url, data, timeout)\n/usr/lib/python3.6/urllib/request.py:532: in open\n    response = meth(req, response)\n/usr/lib/python3.6/urllib/request.py:642: in http_response\n    'http', request, response, code, msg, hdrs)\n/usr/lib/python3.6/urllib/request.py:570: in error\n    return self._call_chain(*args)\n/usr/lib/python3.6/urllib/request.py:504: in _call_chain\n    result = func(*args)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib.request.HTTPDefaultErrorHandler object at 0x7fd599cb68d0>, req = <urllib.request.Request object at 0x7fd599aae240>\nfp = <http.client.HTTPResponse object at 0x7fd599aaecc0>, code = 500, msg = 'Internal Server Error', hdrs = <http.client.HTTPMessage object at 0x7fd599aae748>\n\n    def http_error_default(self, req, fp, code, msg, hdrs):\n>       raise HTTPError(req.full_url, code, msg, hdrs, fp)\nE       urllib.error.HTTPError: HTTP Error 500: Internal Server Error\n\n/usr/lib/python3.6/urllib/request.py:650: HTTPError"}, "teardown": {"duration": 0.00029754638671875, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_data_head_partial_character", "lineno": 369, "outcome": "failed", "keywords": ["test_api_get_state_data_head_partial_character", "state", "run", "TestStateList", "api_test", "get", "third", "()", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.0005028247833251953, "outcome": "passed"}, "call": {"duration": 0.015035867691040039, "outcome": "failed", "crash": {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 650, "message": "urllib.error.HTTPError: HTTP Error 500: Internal Server Error"}, "traceback": [{"path": "get/test_rest_api_get_state.py", "lineno": 381, "message": ""}, {"path": "utils.py", "lineno": 151, "message": "in get_state_list"}, {"path": "utils.py", "lineno": 183, "message": "in query_rest_api"}, {"path": "utils.py", "lineno": 186, "message": "in submit_request"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 223, "message": "in urlopen"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 532, "message": "in open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 642, "message": "in http_response"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 570, "message": "in error"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 504, "message": "in _call_chain"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 650, "message": "HTTPError"}], "longrepr": "self = <test_rest_api_get_state.TestStateList object at 0x7fd599b7d6d8>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_get_state_data_head_partial_character(self, setup):\n        \"\"\"Tests the state head with partial head address ***STL-1345***\n        \"\"\"\n        address = setup['address']\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.get(url='{}/state'.format(address)) as data:\n                    response = await data.json()\n    \n            for _ in response['data']:\n                expected_head = setup['expected_head'][:6]\n>               res=get_state_list(head_id=expected_head)\n\nget/test_rest_api_get_state.py:381: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nutils.py:151: in get_state_list\n    response = query_rest_api('/state?head=%s'% head_id)\nutils.py:183: in query_rest_api\n    return submit_request(urllib.request.Request(url, data, headers))\nutils.py:186: in submit_request\n    response = urllib.request.urlopen(request).read().decode('utf-8')\n/usr/lib/python3.6/urllib/request.py:223: in urlopen\n    return opener.open(url, data, timeout)\n/usr/lib/python3.6/urllib/request.py:532: in open\n    response = meth(req, response)\n/usr/lib/python3.6/urllib/request.py:642: in http_response\n    'http', request, response, code, msg, hdrs)\n/usr/lib/python3.6/urllib/request.py:570: in error\n    return self._call_chain(*args)\n/usr/lib/python3.6/urllib/request.py:504: in _call_chain\n    result = func(*args)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib.request.HTTPDefaultErrorHandler object at 0x7fd599cb68d0>, req = <urllib.request.Request object at 0x7fd599b8c9e8>\nfp = <http.client.HTTPResponse object at 0x7fd599b8c748>, code = 500, msg = 'Internal Server Error', hdrs = <http.client.HTTPMessage object at 0x7fd599a9ce48>\n\n    def http_error_default(self, req, fp, code, msg, hdrs):\n>       raise HTTPError(req.full_url, code, msg, hdrs, fp)\nE       urllib.error.HTTPError: HTTP Error 500: Internal Server Error\n\n/usr/lib/python3.6/urllib/request.py:650: HTTPError"}, "teardown": {"duration": 0.0002980232238769531, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_data_address_partial_character", "lineno": 384, "outcome": "failed", "keywords": ["state", "run", "TestStateList", "third", "api_test", "get", "test_api_get_state_data_address_partial_character", "()", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.0004973411560058594, "outcome": "passed"}, "call": {"duration": 0.014950037002563477, "outcome": "failed", "crash": {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 650, "message": "urllib.error.HTTPError: HTTP Error 500: Internal Server Error"}, "traceback": [{"path": "get/test_rest_api_get_state.py", "lineno": 396, "message": ""}, {"path": "utils.py", "lineno": 151, "message": "in get_state_list"}, {"path": "utils.py", "lineno": 183, "message": "in query_rest_api"}, {"path": "utils.py", "lineno": 186, "message": "in submit_request"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 223, "message": "in urlopen"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 532, "message": "in open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 642, "message": "in http_response"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 570, "message": "in error"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 504, "message": "in _call_chain"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 650, "message": "HTTPError"}], "longrepr": "self = <test_rest_api_get_state.TestStateList object at 0x7fd5997b42b0>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_get_state_data_address_partial_character(self, setup):\n        \"\"\"Tests the state address with partial head address ***STL-1346***\n        \"\"\"\n        address = setup['address']\n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.get(url='{}/state'.format(address)) as data:\n                    response = await data.json()\n    \n            for _ in response['data']:\n                expected_head = setup['expected_head'][:6]\n>               res=get_state_list(head_id=expected_head)\n\nget/test_rest_api_get_state.py:396: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nutils.py:151: in get_state_list\n    response = query_rest_api('/state?head=%s'% head_id)\nutils.py:183: in query_rest_api\n    return submit_request(urllib.request.Request(url, data, headers))\nutils.py:186: in submit_request\n    response = urllib.request.urlopen(request).read().decode('utf-8')\n/usr/lib/python3.6/urllib/request.py:223: in urlopen\n    return opener.open(url, data, timeout)\n/usr/lib/python3.6/urllib/request.py:532: in open\n    response = meth(req, response)\n/usr/lib/python3.6/urllib/request.py:642: in http_response\n    'http', request, response, code, msg, hdrs)\n/usr/lib/python3.6/urllib/request.py:570: in error\n    return self._call_chain(*args)\n/usr/lib/python3.6/urllib/request.py:504: in _call_chain\n    result = func(*args)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib.request.HTTPDefaultErrorHandler object at 0x7fd599cb68d0>, req = <urllib.request.Request object at 0x7fd5997b4c18>\nfp = <http.client.HTTPResponse object at 0x7fd599a643c8>, code = 500, msg = 'Internal Server Error', hdrs = <http.client.HTTPMessage object at 0x7fd599a64160>\n\n    def http_error_default(self, req, fp, code, msg, hdrs):\n>       raise HTTPError(req.full_url, code, msg, hdrs, fp)\nE       urllib.error.HTTPError: HTTP Error 500: Internal Server Error\n\n/usr/lib/python3.6/urllib/request.py:650: HTTPError"}, "teardown": {"duration": 0.00027108192443847656, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_data_address_length", "lineno": 400, "outcome": "passed", "keywords": ["test_api_get_state_data_address_length", "state", "run", "TestStateList", "api_test", "get", "third", "()", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.00046181678771972656, "outcome": "passed"}, "call": {"duration": 0.021780967712402344, "outcome": "passed"}, "teardown": {"duration": 0.0002167224884033203, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_data_address_with_odd_hex_value", "lineno": 418, "outcome": "passed", "keywords": ["state", "run", "test_api_get_state_data_address_with_odd_hex_value", "TestStateList", "api_test", "get", "third", "()", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.0004317760467529297, "outcome": "passed"}, "call": {"duration": 0.021433591842651367, "outcome": "passed"}, "teardown": {"duration": 0.0002372264862060547, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_data_address_with_reduced_length", "lineno": 436, "outcome": "passed", "keywords": ["state", "test_api_get_state_data_address_with_reduced_length", "run", "TestStateList", "api_test", "get", "third", "()", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.0004496574401855469, "outcome": "passed"}, "call": {"duration": 0.10373830795288086, "outcome": "passed"}, "teardown": {"duration": 0.00026726722717285156, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_data_address_64_Hex", "lineno": 454, "outcome": "passed", "keywords": ["state", "test_api_get_state_data_address_64_Hex", "run", "TestStateList", "api_test", "get", "third", "()", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.00048422813415527344, "outcome": "passed"}, "call": {"duration": 0.10287714004516602, "outcome": "passed"}, "teardown": {"duration": 0.0002689361572265625, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_data_address_alter_bytes", "lineno": 473, "outcome": "passed", "keywords": ["state", "run", "get", "TestStateList", "api_test", "test_api_get_state_data_address_alter_bytes", "third", "()", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.0005047321319580078, "outcome": "passed"}, "call": {"duration": 0.10384559631347656, "outcome": "passed"}, "teardown": {"duration": 0.0002777576446533203, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_link_val", "lineno": 494, "outcome": "passed", "keywords": ["state", "test_api_get_state_link_val", "run", "TestStateList", "api_test", "get", "third", "()", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.0005581378936767578, "outcome": "passed"}, "call": {"duration": 0.02162909507751465, "outcome": "passed"}, "teardown": {"duration": 0.0002410411834716797, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_state_key_params", "lineno": 513, "outcome": "passed", "keywords": ["state", "run", "test_api_get_state_key_params", "TestStateList", "api_test", "get", "third", "()", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.0004611015319824219, "outcome": "passed"}, "call": {"duration": 0.021904945373535156, "outcome": "passed"}, "teardown": {"duration": 0.00025773048400878906, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_api_get_each_state_head_length", "lineno": 529, "outcome": "passed", "keywords": ["state", "run", "test_api_get_each_state_head_length", "TestStateList", "api_test", "get", "third", "()", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.0004773139953613281, "outcome": "passed"}, "call": {"duration": 0.021683454513549805, "outcome": "passed"}, "teardown": {"duration": 0.0002498626708984375, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateList::test_rest_api_check_state_count", "lineno": 545, "outcome": "passed", "keywords": ["test_rest_api_check_state_count", "state", "run", "TestStateList", "api_test", "get", "third", "()", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.0004596710205078125, "outcome": "passed"}, "call": {"duration": 0.02208709716796875, "outcome": "passed"}, "teardown": {"duration": 0.00025081634521484375, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateGet::test_api_get_state_address", "lineno": 563, "outcome": "passed", "keywords": ["state", "run", "get", "TestStateGet", "api_test", "test_api_get_state_address", "third", "()", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.0004818439483642578, "outcome": "passed"}, "call": {"duration": 0.021228551864624023, "outcome": "passed"}, "teardown": {"duration": 0.0002446174621582031, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateGet::test_api_get_bad_address", "lineno": 575, "outcome": "passed", "keywords": ["state", "run", "test_api_get_bad_address", "TestStateGet", "api_test", "get", "third", "()", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.00047326087951660156, "outcome": "passed"}, "call": {"duration": 0.0216214656829834, "outcome": "passed", "log": [{"name": "test_rest_api_get_state", "msg": "Starting test for state/{bad_address}", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_state.py", "filename": "test_rest_api_get_state.py", "module": "test_rest_api_get_state", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 580, "funcName": "test_api_get_bad_address", "created": 1552989092.0951588, "msecs": 95.15881538391113, "relativeCreated": 1212952.579498291, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:32"}]}, "teardown": {"duration": 0.00025844573974609375, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateDeleteRoot::test_api_get_state_delete_root", "lineno": 590, "outcome": "passed", "keywords": ["state", "run", "TestStateDeleteRoot", "third", "api_test", "get", "test_api_get_state_delete_root", "()", "get/test_rest_api_get_state.py"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.0004582405090332031, "outcome": "passed"}, "call": {"duration": 0.0223846435546875, "outcome": "passed"}, "teardown": {"duration": 0.00024318695068359375, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_state.py::TestStateDeleteRoot::test_api_get_state_delete_not_root_node", "lineno": 612, "outcome": "passed", "keywords": ["state", "get/test_rest_api_get_state.py", "run", "TestStateDeleteRoot", "api_test", "get", "third", "()", "test_api_get_state_delete_not_root_node"], "metadata": {"0": "Tests the state list by submitting intkey batches\n        ", "1": "Tests that GET /state is reachable with head parameter \n        ", "2": "Tests that state is not updated for when\nsubmitting invalid intkey batches", "3": "Tests that GET /state is unreachable with bad head parameter \n        ", "4": "Tests that GET /state is reachable with address parameter \n        ", "5": "Tests that GET /state is unreachable with bad address parameter \n        ", "6": "Tests GET /state is reachable using paging parameters \n        ", "7": "Tests GET /state is reachable using paging parameters with limit\n        ", "8": "Tests GET /state is reachbale using paging parameters with start \n        ", "9": "Tests GET /state is reachable using bad paging parameters \n        ", "10": "Tests that GET /state is unreachable with invalid start parameter \n        ", "11": "Tests that GET /state is unreachable with bad limit parameter \n        ", "12": "verifies that GET /state is unreachable with bad head parameter \n        ", "13": "Tests the state data address with 6 hex characters long \nnamespace prefix", "14": "Tests the state head with wildcard_character ***STL-1345***\n        ", "15": "Tests the state head with partial head address ***STL-1345***\n        ", "16": "Tests the state address with partial head address ***STL-1346***\n        ", "17": "Tests the state data address length is 70 hex character long\nwith proper prefix namespace", "18": "Tests the state data address fail with odd hex character \naddress ", "19": "Tests the state data address with reduced even length hex character long \n        ", "20": "Tests the state data address with 64 hex give empty data \n        ", "21": "Tests the state data address with alter bytes give empty data \n        ", "22": "Tests/ validate the state parameters with state, head, start and limit\n        ", "23": "Tests/ validate the state key parameters with data, head, link and paging               \n        ", "24": "Tests the each state head length should be 128 hex character long \n        ", "25": "Tests state count from state list \n        ", "26": "Tests state_address              \n        ", "27": "Tests /state/{bad_state_address}                \n        ", "28": "Tests/ validate the state of deleted block at root node\n        ", "29": "Tests/ validate the state of deleted block at not root node\n        "}, "setup": {"duration": 0.0004737377166748047, "outcome": "passed"}, "call": {"duration": 0.022401809692382812, "outcome": "passed", "log": [{"name": "test_rest_api_get_state", "msg": "Currently selected state is not root node", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_state.py", "filename": "test_rest_api_get_state.py", "module": "test_rest_api_get_state", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 627, "funcName": "test_api_get_state_delete_not_root_node", "created": 1552989092.1509902, "msecs": 150.99024772644043, "relativeCreated": 1213008.4109306335, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:32"}]}, "teardown": {"duration": 0.0002493858337402344, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_api_get_block_list", "lineno": 82, "outcome": "passed", "keywords": ["TestBlockList", "api_test", "test_api_get_block_list", "run", "block", "get/test_rest_api_get_block.py", "fourth", "get", "()"], "metadata": {"0": "Tests the block list by submitting intkey batches\n        ", "1": "Tests that GET /blocks is reachable with head parameter \n        ", "2": "Tests that GET /blocks is unreachable with bad head parameter \n        ", "3": "Tests that GET /blocks is reachable with id as parameter \n        ", "4": "Tests that GET /blocks is unreachable with bad id parameter \n        ", "5": "Tests GET /blocks is reachable using paging parameters \n        ", "6": "Tests GET /batches is reachable with limit\n        ", "7": "Tests that GET /blocks is unreachable with invalid start parameter \n        ", "8": "Tests that GET /blocks is unreachable with bad limit parameter \n        ", "9": "verifies that GET /blocks when reversed\n        ", "10": "Verify the GET/ block link  value\n        ", "11": "Tests/ validate the block key parameters like data, head, link and paging               \n        ", "12": "Tests the each batch id length should be 128 hex character long \n        ", "13": "Tests the first block id length should be 128 hex character long \n        ", "14": "Tests that allow max post batches in block\nHandled max 100 batches post in block and handle for extra batch", "15": "Tests that head signature of each batch of the block \nshould be not none ", "16": "Test batch transaction family version should be present \nfor each transaction header", "17": "Test batch input and output content should be same for\neach batch and unique from other", "18": "Tests that signer public key is calculated for a block\nproperly", "19": "Tests blocks count from block list \n        ", "20": "Tests that head signature of each batch of the block\nshould be not none", "21": "Tests that GET /blocks/  is reachable with block id \n        ", "22": "Tests that GET /blocks/ is not reachable with bad id\n        "}, "setup": {"duration": 0.0004863739013671875, "outcome": "passed"}, "call": {"duration": 0.020102739334106445, "outcome": "passed"}, "teardown": {"duration": 0.0002605915069580078, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_api_get_block_list_head", "lineno": 113, "outcome": "passed", "keywords": ["test_api_get_block_list_head", "TestBlockList", "api_test", "get/test_rest_api_get_block.py", "run", "block", "fourth", "get", "()"], "metadata": {"0": "Tests the block list by submitting intkey batches\n        ", "1": "Tests that GET /blocks is reachable with head parameter \n        ", "2": "Tests that GET /blocks is unreachable with bad head parameter \n        ", "3": "Tests that GET /blocks is reachable with id as parameter \n        ", "4": "Tests that GET /blocks is unreachable with bad id parameter \n        ", "5": "Tests GET /blocks is reachable using paging parameters \n        ", "6": "Tests GET /batches is reachable with limit\n        ", "7": "Tests that GET /blocks is unreachable with invalid start parameter \n        ", "8": "Tests that GET /blocks is unreachable with bad limit parameter \n        ", "9": "verifies that GET /blocks when reversed\n        ", "10": "Verify the GET/ block link  value\n        ", "11": "Tests/ validate the block key parameters like data, head, link and paging               \n        ", "12": "Tests the each batch id length should be 128 hex character long \n        ", "13": "Tests the first block id length should be 128 hex character long \n        ", "14": "Tests that allow max post batches in block\nHandled max 100 batches post in block and handle for extra batch", "15": "Tests that head signature of each batch of the block \nshould be not none ", "16": "Test batch transaction family version should be present \nfor each transaction header", "17": "Test batch input and output content should be same for\neach batch and unique from other", "18": "Tests that signer public key is calculated for a block\nproperly", "19": "Tests blocks count from block list \n        ", "20": "Tests that head signature of each batch of the block\nshould be not none", "21": "Tests that GET /blocks/  is reachable with block id \n        ", "22": "Tests that GET /blocks/ is not reachable with bad id\n        "}, "setup": {"duration": 0.0004558563232421875, "outcome": "passed"}, "call": {"duration": 0.020050048828125, "outcome": "passed", "log": [{"name": "test_rest_api_get_block", "msg": "Starting test for blocks with head parameter", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_block.py", "filename": "test_rest_api_get_block.py", "module": "test_rest_api_get_block", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 117, "funcName": "test_api_get_block_list_head", "created": 1552989092.187919, "msecs": 187.91890144348145, "relativeCreated": 1213045.3395843506, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:32"}]}, "teardown": {"duration": 0.00025081634521484375, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_api_get_block_list_bad_head", "lineno": 131, "outcome": "passed", "keywords": ["TestBlockList", "api_test", "get/test_rest_api_get_block.py", "run", "block", "test_api_get_block_list_bad_head", "fourth", "get", "()"], "metadata": {"0": "Tests the block list by submitting intkey batches\n        ", "1": "Tests that GET /blocks is reachable with head parameter \n        ", "2": "Tests that GET /blocks is unreachable with bad head parameter \n        ", "3": "Tests that GET /blocks is reachable with id as parameter \n        ", "4": "Tests that GET /blocks is unreachable with bad id parameter \n        ", "5": "Tests GET /blocks is reachable using paging parameters \n        ", "6": "Tests GET /batches is reachable with limit\n        ", "7": "Tests that GET /blocks is unreachable with invalid start parameter \n        ", "8": "Tests that GET /blocks is unreachable with bad limit parameter \n        ", "9": "verifies that GET /blocks when reversed\n        ", "10": "Verify the GET/ block link  value\n        ", "11": "Tests/ validate the block key parameters like data, head, link and paging               \n        ", "12": "Tests the each batch id length should be 128 hex character long \n        ", "13": "Tests the first block id length should be 128 hex character long \n        ", "14": "Tests that allow max post batches in block\nHandled max 100 batches post in block and handle for extra batch", "15": "Tests that head signature of each batch of the block \nshould be not none ", "16": "Test batch transaction family version should be present \nfor each transaction header", "17": "Test batch input and output content should be same for\neach batch and unique from other", "18": "Tests that signer public key is calculated for a block\nproperly", "19": "Tests blocks count from block list \n        ", "20": "Tests that head signature of each batch of the block\nshould be not none", "21": "Tests that GET /blocks/  is reachable with block id \n        ", "22": "Tests that GET /blocks/ is not reachable with bad id\n        "}, "setup": {"duration": 0.00047588348388671875, "outcome": "passed"}, "call": {"duration": 0.01507258415222168, "outcome": "passed", "log": [{"name": "test_rest_api_get_block", "msg": "Starting test for blocks with bad head parameter", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_block.py", "filename": "test_rest_api_get_block.py", "module": "test_rest_api_get_block", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 135, "funcName": "test_api_get_block_list_bad_head", "created": 1552989092.2095137, "msecs": 209.51366424560547, "relativeCreated": 1213066.9343471527, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:32"}]}, "teardown": {"duration": 0.0002529621124267578, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_api_get_block_list_id", "lineno": 147, "outcome": "failed", "keywords": ["TestBlockList", "api_test", "get/test_rest_api_get_block.py", "run", "block", "fourth", "get", "test_api_get_block_list_id", "()"], "metadata": {"0": "Tests the block list by submitting intkey batches\n        ", "1": "Tests that GET /blocks is reachable with head parameter \n        ", "2": "Tests that GET /blocks is unreachable with bad head parameter \n        ", "3": "Tests that GET /blocks is reachable with id as parameter \n        ", "4": "Tests that GET /blocks is unreachable with bad id parameter \n        ", "5": "Tests GET /blocks is reachable using paging parameters \n        ", "6": "Tests GET /batches is reachable with limit\n        ", "7": "Tests that GET /blocks is unreachable with invalid start parameter \n        ", "8": "Tests that GET /blocks is unreachable with bad limit parameter \n        ", "9": "verifies that GET /blocks when reversed\n        ", "10": "Verify the GET/ block link  value\n        ", "11": "Tests/ validate the block key parameters like data, head, link and paging               \n        ", "12": "Tests the each batch id length should be 128 hex character long \n        ", "13": "Tests the first block id length should be 128 hex character long \n        ", "14": "Tests that allow max post batches in block\nHandled max 100 batches post in block and handle for extra batch", "15": "Tests that head signature of each batch of the block \nshould be not none ", "16": "Test batch transaction family version should be present \nfor each transaction header", "17": "Test batch input and output content should be same for\neach batch and unique from other", "18": "Tests that signer public key is calculated for a block\nproperly", "19": "Tests blocks count from block list \n        ", "20": "Tests that head signature of each batch of the block\nshould be not none", "21": "Tests that GET /blocks/  is reachable with block id \n        ", "22": "Tests that GET /blocks/ is not reachable with bad id\n        "}, "setup": {"duration": 0.00047659873962402344, "outcome": "passed"}, "call": {"duration": 0.0004999637603759766, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_block.py", "lineno": 156, "message": "IndexError: list index out of range"}, "traceback": [{"path": "get/test_rest_api_get_block.py", "lineno": 156, "message": "IndexError"}], "log": [{"name": "test_rest_api_get_block", "msg": "Starting test for blocks with id parameter", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_block.py", "filename": "test_rest_api_get_block.py", "module": "test_rest_api_get_block", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 151, "funcName": "test_api_get_block_list_id", "created": 1552989092.2261548, "msecs": 226.15480422973633, "relativeCreated": 1213083.5754871368, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:32"}], "longrepr": "self = <test_rest_api_get_block.TestBlockList object at 0x7fd599ba33c8>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_get_block_list_id(self, setup):\n        \"\"\"Tests that GET /blocks is reachable with id as parameter\n        \"\"\"\n        LOGGER.info(\"Starting test for blocks with id parameter\")\n        address = setup['address']\n        signer_key = setup['signer_key']\n        block_ids   =  setup['block_ids']\n        expected_head = setup['expected_head']\n>       expected_id = block_ids[0]\nE       IndexError: list index out of range\n\nget/test_rest_api_get_block.py:156: IndexError"}, "teardown": {"duration": 0.00024509429931640625, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_api_get_block_list_bad_id", "lineno": 180, "outcome": "passed", "keywords": ["TestBlockList", "api_test", "get/test_rest_api_get_block.py", "fourth", "block", "run", "test_api_get_block_list_bad_id", "get", "()"], "metadata": {"0": "Tests the block list by submitting intkey batches\n        ", "1": "Tests that GET /blocks is reachable with head parameter \n        ", "2": "Tests that GET /blocks is unreachable with bad head parameter \n        ", "3": "Tests that GET /blocks is reachable with id as parameter \n        ", "4": "Tests that GET /blocks is unreachable with bad id parameter \n        ", "5": "Tests GET /blocks is reachable using paging parameters \n        ", "6": "Tests GET /batches is reachable with limit\n        ", "7": "Tests that GET /blocks is unreachable with invalid start parameter \n        ", "8": "Tests that GET /blocks is unreachable with bad limit parameter \n        ", "9": "verifies that GET /blocks when reversed\n        ", "10": "Verify the GET/ block link  value\n        ", "11": "Tests/ validate the block key parameters like data, head, link and paging               \n        ", "12": "Tests the each batch id length should be 128 hex character long \n        ", "13": "Tests the first block id length should be 128 hex character long \n        ", "14": "Tests that allow max post batches in block\nHandled max 100 batches post in block and handle for extra batch", "15": "Tests that head signature of each batch of the block \nshould be not none ", "16": "Test batch transaction family version should be present \nfor each transaction header", "17": "Test batch input and output content should be same for\neach batch and unique from other", "18": "Tests that signer public key is calculated for a block\nproperly", "19": "Tests blocks count from block list \n        ", "20": "Tests that head signature of each batch of the block\nshould be not none", "21": "Tests that GET /blocks/  is reachable with block id \n        ", "22": "Tests that GET /blocks/ is not reachable with bad id\n        "}, "setup": {"duration": 0.0004551410675048828, "outcome": "passed"}, "call": {"duration": 0.015487432479858398, "outcome": "passed", "log": [{"name": "test_rest_api_get_block", "msg": "Starting test for blocks with bad id parameter", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_block.py", "filename": "test_rest_api_get_block.py", "module": "test_rest_api_get_block", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 184, "funcName": "test_api_get_block_list_bad_id", "created": 1552989092.2365854, "msecs": 236.5853786468506, "relativeCreated": 1213094.006061554, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:32"}]}, "teardown": {"duration": 0.00025177001953125, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_api_get_paginated_block_list", "lineno": 198, "outcome": "failed", "keywords": ["TestBlockList", "api_test", "get/test_rest_api_get_block.py", "run", "block", "test_api_get_paginated_block_list", "fourth", "get", "()"], "metadata": {"0": "Tests the block list by submitting intkey batches\n        ", "1": "Tests that GET /blocks is reachable with head parameter \n        ", "2": "Tests that GET /blocks is unreachable with bad head parameter \n        ", "3": "Tests that GET /blocks is reachable with id as parameter \n        ", "4": "Tests that GET /blocks is unreachable with bad id parameter \n        ", "5": "Tests GET /blocks is reachable using paging parameters \n        ", "6": "Tests GET /batches is reachable with limit\n        ", "7": "Tests that GET /blocks is unreachable with invalid start parameter \n        ", "8": "Tests that GET /blocks is unreachable with bad limit parameter \n        ", "9": "verifies that GET /blocks when reversed\n        ", "10": "Verify the GET/ block link  value\n        ", "11": "Tests/ validate the block key parameters like data, head, link and paging               \n        ", "12": "Tests the each batch id length should be 128 hex character long \n        ", "13": "Tests the first block id length should be 128 hex character long \n        ", "14": "Tests that allow max post batches in block\nHandled max 100 batches post in block and handle for extra batch", "15": "Tests that head signature of each batch of the block \nshould be not none ", "16": "Test batch transaction family version should be present \nfor each transaction header", "17": "Test batch input and output content should be same for\neach batch and unique from other", "18": "Tests that signer public key is calculated for a block\nproperly", "19": "Tests blocks count from block list \n        ", "20": "Tests that head signature of each batch of the block\nshould be not none", "21": "Tests that GET /blocks/  is reachable with block id \n        ", "22": "Tests that GET /blocks/ is not reachable with bad id\n        "}, "setup": {"duration": 0.0004773139953613281, "outcome": "passed"}, "call": {"duration": 0.000457763671875, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_block.py", "lineno": 206, "message": "IndexError: list index out of range"}, "traceback": [{"path": "get/test_rest_api_get_block.py", "lineno": 206, "message": "IndexError"}], "log": [{"name": "test_rest_api_get_block", "msg": "Starting test for blocks with paging parameters", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_block.py", "filename": "test_rest_api_get_block.py", "module": "test_rest_api_get_block", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 202, "funcName": "test_api_get_paginated_block_list", "created": 1552989092.2535899, "msecs": 253.58986854553223, "relativeCreated": 1213111.0105514526, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:32"}], "longrepr": "self = <test_rest_api_get_block.TestBlockList object at 0x7fd599a584e0>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_get_paginated_block_list(self, setup):\n        \"\"\"Tests GET /blocks is reachable using paging parameters\n        \"\"\"\n        LOGGER.info(\"Starting test for blocks with paging parameters\")\n        address = setup['address']\n        block_ids   =  setup['block_ids']\n        expected_head = setup['expected_head']\n>       expected_id = block_ids[0]\nE       IndexError: list index out of range\n\nget/test_rest_api_get_block.py:206: IndexError"}, "teardown": {"duration": 0.00023818016052246094, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_api_get_block_list_limit", "lineno": 218, "outcome": "passed", "keywords": ["TestBlockList", "api_test", "get/test_rest_api_get_block.py", "run", "block", "test_api_get_block_list_limit", "fourth", "get", "()"], "metadata": {"0": "Tests the block list by submitting intkey batches\n        ", "1": "Tests that GET /blocks is reachable with head parameter \n        ", "2": "Tests that GET /blocks is unreachable with bad head parameter \n        ", "3": "Tests that GET /blocks is reachable with id as parameter \n        ", "4": "Tests that GET /blocks is unreachable with bad id parameter \n        ", "5": "Tests GET /blocks is reachable using paging parameters \n        ", "6": "Tests GET /batches is reachable with limit\n        ", "7": "Tests that GET /blocks is unreachable with invalid start parameter \n        ", "8": "Tests that GET /blocks is unreachable with bad limit parameter \n        ", "9": "verifies that GET /blocks when reversed\n        ", "10": "Verify the GET/ block link  value\n        ", "11": "Tests/ validate the block key parameters like data, head, link and paging               \n        ", "12": "Tests the each batch id length should be 128 hex character long \n        ", "13": "Tests the first block id length should be 128 hex character long \n        ", "14": "Tests that allow max post batches in block\nHandled max 100 batches post in block and handle for extra batch", "15": "Tests that head signature of each batch of the block \nshould be not none ", "16": "Test batch transaction family version should be present \nfor each transaction header", "17": "Test batch input and output content should be same for\neach batch and unique from other", "18": "Tests that signer public key is calculated for a block\nproperly", "19": "Tests blocks count from block list \n        ", "20": "Tests that head signature of each batch of the block\nshould be not none", "21": "Tests that GET /blocks/  is reachable with block id \n        ", "22": "Tests that GET /blocks/ is not reachable with bad id\n        "}, "setup": {"duration": 0.0004558563232421875, "outcome": "passed"}, "call": {"duration": 0.020806550979614258, "outcome": "passed", "log": [{"name": "test_rest_api_get_block", "msg": "Starting test for batch with paging parameters", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_block.py", "filename": "test_rest_api_get_block.py", "module": "test_rest_api_get_block", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 222, "funcName": "test_api_get_block_list_limit", "created": 1552989092.2636185, "msecs": 263.61846923828125, "relativeCreated": 1213121.0391521454, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:32"}]}, "teardown": {"duration": 0.0002617835998535156, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_api_get_block_list_invalid_start", "lineno": 246, "outcome": "failed", "keywords": ["TestBlockList", "test_api_get_block_list_invalid_start", "api_test", "get/test_rest_api_get_block.py", "run", "block", "fourth", "get", "()"], "metadata": {"0": "Tests the block list by submitting intkey batches\n        ", "1": "Tests that GET /blocks is reachable with head parameter \n        ", "2": "Tests that GET /blocks is unreachable with bad head parameter \n        ", "3": "Tests that GET /blocks is reachable with id as parameter \n        ", "4": "Tests that GET /blocks is unreachable with bad id parameter \n        ", "5": "Tests GET /blocks is reachable using paging parameters \n        ", "6": "Tests GET /batches is reachable with limit\n        ", "7": "Tests that GET /blocks is unreachable with invalid start parameter \n        ", "8": "Tests that GET /blocks is unreachable with bad limit parameter \n        ", "9": "verifies that GET /blocks when reversed\n        ", "10": "Verify the GET/ block link  value\n        ", "11": "Tests/ validate the block key parameters like data, head, link and paging               \n        ", "12": "Tests the each batch id length should be 128 hex character long \n        ", "13": "Tests the first block id length should be 128 hex character long \n        ", "14": "Tests that allow max post batches in block\nHandled max 100 batches post in block and handle for extra batch", "15": "Tests that head signature of each batch of the block \nshould be not none ", "16": "Test batch transaction family version should be present \nfor each transaction header", "17": "Test batch input and output content should be same for\neach batch and unique from other", "18": "Tests that signer public key is calculated for a block\nproperly", "19": "Tests blocks count from block list \n        ", "20": "Tests that head signature of each batch of the block\nshould be not none", "21": "Tests that GET /blocks/  is reachable with block id \n        ", "22": "Tests that GET /blocks/ is not reachable with bad id\n        "}, "setup": {"duration": 0.0004532337188720703, "outcome": "passed"}, "call": {"duration": 0.0004711151123046875, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_block.py", "lineno": 254, "message": "IndexError: list index out of range"}, "traceback": [{"path": "get/test_rest_api_get_block.py", "lineno": 254, "message": "IndexError"}], "log": [{"name": "test_rest_api_get_block", "msg": "Starting test for block with invalid start parameter", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_block.py", "filename": "test_rest_api_get_block.py", "module": "test_rest_api_get_block", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 250, "funcName": "test_api_get_block_list_invalid_start", "created": 1552989092.285982, "msecs": 285.9818935394287, "relativeCreated": 1213143.4025764465, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:32"}], "longrepr": "self = <test_rest_api_get_block.TestBlockList object at 0x7fd599ac3d30>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_get_block_list_invalid_start(self, setup):\n        \"\"\"Tests that GET /blocks is unreachable with invalid start parameter\n        \"\"\"\n        LOGGER.info(\"Starting test for block with invalid start parameter\")\n        address = setup['address']\n        block_ids   =  setup['block_ids']\n        expected_head = setup['expected_head']\n>       expected_id = block_ids[0]\nE       IndexError: list index out of range\n\nget/test_rest_api_get_block.py:254: IndexError"}, "teardown": {"duration": 0.000278472900390625, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_api_get_block_list_invalid_limit", "lineno": 266, "outcome": "failed", "keywords": ["TestBlockList", "api_test", "get/test_rest_api_get_block.py", "fourth", "block", "run", "test_api_get_block_list_invalid_limit", "get", "()"], "metadata": {"0": "Tests the block list by submitting intkey batches\n        ", "1": "Tests that GET /blocks is reachable with head parameter \n        ", "2": "Tests that GET /blocks is unreachable with bad head parameter \n        ", "3": "Tests that GET /blocks is reachable with id as parameter \n        ", "4": "Tests that GET /blocks is unreachable with bad id parameter \n        ", "5": "Tests GET /blocks is reachable using paging parameters \n        ", "6": "Tests GET /batches is reachable with limit\n        ", "7": "Tests that GET /blocks is unreachable with invalid start parameter \n        ", "8": "Tests that GET /blocks is unreachable with bad limit parameter \n        ", "9": "verifies that GET /blocks when reversed\n        ", "10": "Verify the GET/ block link  value\n        ", "11": "Tests/ validate the block key parameters like data, head, link and paging               \n        ", "12": "Tests the each batch id length should be 128 hex character long \n        ", "13": "Tests the first block id length should be 128 hex character long \n        ", "14": "Tests that allow max post batches in block\nHandled max 100 batches post in block and handle for extra batch", "15": "Tests that head signature of each batch of the block \nshould be not none ", "16": "Test batch transaction family version should be present \nfor each transaction header", "17": "Test batch input and output content should be same for\neach batch and unique from other", "18": "Tests that signer public key is calculated for a block\nproperly", "19": "Tests blocks count from block list \n        ", "20": "Tests that head signature of each batch of the block\nshould be not none", "21": "Tests that GET /blocks/  is reachable with block id \n        ", "22": "Tests that GET /blocks/ is not reachable with bad id\n        "}, "setup": {"duration": 0.0004582405090332031, "outcome": "passed"}, "call": {"duration": 0.0004858970642089844, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_block.py", "lineno": 274, "message": "IndexError: list index out of range"}, "traceback": [{"path": "get/test_rest_api_get_block.py", "lineno": 274, "message": "IndexError"}], "log": [{"name": "test_rest_api_get_block", "msg": "Starting test for block with bad limit parameter", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_block.py", "filename": "test_rest_api_get_block.py", "module": "test_rest_api_get_block", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 270, "funcName": "test_api_get_block_list_invalid_limit", "created": 1552989092.2958395, "msecs": 295.8395481109619, "relativeCreated": 1213153.260231018, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:32"}], "longrepr": "self = <test_rest_api_get_block.TestBlockList object at 0x7fd599b14320>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_get_block_list_invalid_limit(self, setup):\n        \"\"\"Tests that GET /blocks is unreachable with bad limit parameter\n        \"\"\"\n        LOGGER.info(\"Starting test for block with bad limit parameter\")\n        address = setup['address']\n        block_ids = setup['block_ids']\n        expected_head = setup['expected_head']\n>       expected_id = block_ids[0]\nE       IndexError: list index out of range\n\nget/test_rest_api_get_block.py:274: IndexError"}, "teardown": {"duration": 0.00022864341735839844, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_api_get_block_list_reversed", "lineno": 286, "outcome": "failed", "keywords": ["TestBlockList", "api_test", "get/test_rest_api_get_block.py", "run", "get", "block", "fourth", "test_api_get_block_list_reversed", "()"], "metadata": {"0": "Tests the block list by submitting intkey batches\n        ", "1": "Tests that GET /blocks is reachable with head parameter \n        ", "2": "Tests that GET /blocks is unreachable with bad head parameter \n        ", "3": "Tests that GET /blocks is reachable with id as parameter \n        ", "4": "Tests that GET /blocks is unreachable with bad id parameter \n        ", "5": "Tests GET /blocks is reachable using paging parameters \n        ", "6": "Tests GET /batches is reachable with limit\n        ", "7": "Tests that GET /blocks is unreachable with invalid start parameter \n        ", "8": "Tests that GET /blocks is unreachable with bad limit parameter \n        ", "9": "verifies that GET /blocks when reversed\n        ", "10": "Verify the GET/ block link  value\n        ", "11": "Tests/ validate the block key parameters like data, head, link and paging               \n        ", "12": "Tests the each batch id length should be 128 hex character long \n        ", "13": "Tests the first block id length should be 128 hex character long \n        ", "14": "Tests that allow max post batches in block\nHandled max 100 batches post in block and handle for extra batch", "15": "Tests that head signature of each batch of the block \nshould be not none ", "16": "Test batch transaction family version should be present \nfor each transaction header", "17": "Test batch input and output content should be same for\neach batch and unique from other", "18": "Tests that signer public key is calculated for a block\nproperly", "19": "Tests blocks count from block list \n        ", "20": "Tests that head signature of each batch of the block\nshould be not none", "21": "Tests that GET /blocks/  is reachable with block id \n        ", "22": "Tests that GET /blocks/ is not reachable with bad id\n        "}, "setup": {"duration": 0.0004477500915527344, "outcome": "passed"}, "call": {"duration": 0.00046181678771972656, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_block.py", "lineno": 294, "message": "IndexError: list index out of range"}, "traceback": [{"path": "get/test_rest_api_get_block.py", "lineno": 294, "message": "IndexError"}], "log": [{"name": "test_rest_api_get_block", "msg": "Starting test for blocks with reversed list", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_block.py", "filename": "test_rest_api_get_block.py", "module": "test_rest_api_get_block", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 290, "funcName": "test_api_get_block_list_reversed", "created": 1552989092.3058405, "msecs": 305.84049224853516, "relativeCreated": 1213163.2611751556, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:32"}], "longrepr": "self = <test_rest_api_get_block.TestBlockList object at 0x7fd599a607f0>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_get_block_list_reversed(self, setup):\n        \"\"\"verifies that GET /blocks when reversed\n        \"\"\"\n        LOGGER.info(\"Starting test for blocks with reversed list\")\n        address = setup['address']\n        block_ids = setup['block_ids']\n        expected_head = setup['expected_head']\n>       expected_id = block_ids[0]\nE       IndexError: list index out of range\n\nget/test_rest_api_get_block.py:294: IndexError"}, "teardown": {"duration": 0.00024056434631347656, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_api_get_block_link_val", "lineno": 309, "outcome": "passed", "keywords": ["TestBlockList", "api_test", "get/test_rest_api_get_block.py", "run", "block", "fourth", "get", "test_api_get_block_link_val", "()"], "metadata": {"0": "Tests the block list by submitting intkey batches\n        ", "1": "Tests that GET /blocks is reachable with head parameter \n        ", "2": "Tests that GET /blocks is unreachable with bad head parameter \n        ", "3": "Tests that GET /blocks is reachable with id as parameter \n        ", "4": "Tests that GET /blocks is unreachable with bad id parameter \n        ", "5": "Tests GET /blocks is reachable using paging parameters \n        ", "6": "Tests GET /batches is reachable with limit\n        ", "7": "Tests that GET /blocks is unreachable with invalid start parameter \n        ", "8": "Tests that GET /blocks is unreachable with bad limit parameter \n        ", "9": "verifies that GET /blocks when reversed\n        ", "10": "Verify the GET/ block link  value\n        ", "11": "Tests/ validate the block key parameters like data, head, link and paging               \n        ", "12": "Tests the each batch id length should be 128 hex character long \n        ", "13": "Tests the first block id length should be 128 hex character long \n        ", "14": "Tests that allow max post batches in block\nHandled max 100 batches post in block and handle for extra batch", "15": "Tests that head signature of each batch of the block \nshould be not none ", "16": "Test batch transaction family version should be present \nfor each transaction header", "17": "Test batch input and output content should be same for\neach batch and unique from other", "18": "Tests that signer public key is calculated for a block\nproperly", "19": "Tests blocks count from block list \n        ", "20": "Tests that head signature of each batch of the block\nshould be not none", "21": "Tests that GET /blocks/  is reachable with block id \n        ", "22": "Tests that GET /blocks/ is not reachable with bad id\n        "}, "setup": {"duration": 0.0004565715789794922, "outcome": "passed"}, "call": {"duration": 0.020668983459472656, "outcome": "passed"}, "teardown": {"duration": 0.00024700164794921875, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_api_get_block_key_params", "lineno": 328, "outcome": "passed", "keywords": ["TestBlockList", "test_api_get_block_key_params", "get/test_rest_api_get_block.py", "run", "block", "api_test", "fourth", "get", "()"], "metadata": {"0": "Tests the block list by submitting intkey batches\n        ", "1": "Tests that GET /blocks is reachable with head parameter \n        ", "2": "Tests that GET /blocks is unreachable with bad head parameter \n        ", "3": "Tests that GET /blocks is reachable with id as parameter \n        ", "4": "Tests that GET /blocks is unreachable with bad id parameter \n        ", "5": "Tests GET /blocks is reachable using paging parameters \n        ", "6": "Tests GET /batches is reachable with limit\n        ", "7": "Tests that GET /blocks is unreachable with invalid start parameter \n        ", "8": "Tests that GET /blocks is unreachable with bad limit parameter \n        ", "9": "verifies that GET /blocks when reversed\n        ", "10": "Verify the GET/ block link  value\n        ", "11": "Tests/ validate the block key parameters like data, head, link and paging               \n        ", "12": "Tests the each batch id length should be 128 hex character long \n        ", "13": "Tests the first block id length should be 128 hex character long \n        ", "14": "Tests that allow max post batches in block\nHandled max 100 batches post in block and handle for extra batch", "15": "Tests that head signature of each batch of the block \nshould be not none ", "16": "Test batch transaction family version should be present \nfor each transaction header", "17": "Test batch input and output content should be same for\neach batch and unique from other", "18": "Tests that signer public key is calculated for a block\nproperly", "19": "Tests blocks count from block list \n        ", "20": "Tests that head signature of each batch of the block\nshould be not none", "21": "Tests that GET /blocks/  is reachable with block id \n        ", "22": "Tests that GET /blocks/ is not reachable with bad id\n        "}, "setup": {"duration": 0.0004487037658691406, "outcome": "passed"}, "call": {"duration": 0.02044367790222168, "outcome": "passed"}, "teardown": {"duration": 0.0002524852752685547, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_api_get_each_block_batch_id_length", "lineno": 344, "outcome": "passed", "keywords": ["TestBlockList", "api_test", "get/test_rest_api_get_block.py", "run", "get", "block", "fourth", "test_api_get_each_block_batch_id_length", "()"], "metadata": {"0": "Tests the block list by submitting intkey batches\n        ", "1": "Tests that GET /blocks is reachable with head parameter \n        ", "2": "Tests that GET /blocks is unreachable with bad head parameter \n        ", "3": "Tests that GET /blocks is reachable with id as parameter \n        ", "4": "Tests that GET /blocks is unreachable with bad id parameter \n        ", "5": "Tests GET /blocks is reachable using paging parameters \n        ", "6": "Tests GET /batches is reachable with limit\n        ", "7": "Tests that GET /blocks is unreachable with invalid start parameter \n        ", "8": "Tests that GET /blocks is unreachable with bad limit parameter \n        ", "9": "verifies that GET /blocks when reversed\n        ", "10": "Verify the GET/ block link  value\n        ", "11": "Tests/ validate the block key parameters like data, head, link and paging               \n        ", "12": "Tests the each batch id length should be 128 hex character long \n        ", "13": "Tests the first block id length should be 128 hex character long \n        ", "14": "Tests that allow max post batches in block\nHandled max 100 batches post in block and handle for extra batch", "15": "Tests that head signature of each batch of the block \nshould be not none ", "16": "Test batch transaction family version should be present \nfor each transaction header", "17": "Test batch input and output content should be same for\neach batch and unique from other", "18": "Tests that signer public key is calculated for a block\nproperly", "19": "Tests blocks count from block list \n        ", "20": "Tests that head signature of each batch of the block\nshould be not none", "21": "Tests that GET /blocks/  is reachable with block id \n        ", "22": "Tests that GET /blocks/ is not reachable with bad id\n        "}, "setup": {"duration": 0.0004608631134033203, "outcome": "passed"}, "call": {"duration": 0.020533323287963867, "outcome": "passed"}, "teardown": {"duration": 0.00025343894958496094, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_api_get_first_block_id_length", "lineno": 360, "outcome": "passed", "keywords": ["TestBlockList", "api_test", "get/test_rest_api_get_block.py", "run", "block", "test_api_get_first_block_id_length", "fourth", "get", "()"], "metadata": {"0": "Tests the block list by submitting intkey batches\n        ", "1": "Tests that GET /blocks is reachable with head parameter \n        ", "2": "Tests that GET /blocks is unreachable with bad head parameter \n        ", "3": "Tests that GET /blocks is reachable with id as parameter \n        ", "4": "Tests that GET /blocks is unreachable with bad id parameter \n        ", "5": "Tests GET /blocks is reachable using paging parameters \n        ", "6": "Tests GET /batches is reachable with limit\n        ", "7": "Tests that GET /blocks is unreachable with invalid start parameter \n        ", "8": "Tests that GET /blocks is unreachable with bad limit parameter \n        ", "9": "verifies that GET /blocks when reversed\n        ", "10": "Verify the GET/ block link  value\n        ", "11": "Tests/ validate the block key parameters like data, head, link and paging               \n        ", "12": "Tests the each batch id length should be 128 hex character long \n        ", "13": "Tests the first block id length should be 128 hex character long \n        ", "14": "Tests that allow max post batches in block\nHandled max 100 batches post in block and handle for extra batch", "15": "Tests that head signature of each batch of the block \nshould be not none ", "16": "Test batch transaction family version should be present \nfor each transaction header", "17": "Test batch input and output content should be same for\neach batch and unique from other", "18": "Tests that signer public key is calculated for a block\nproperly", "19": "Tests blocks count from block list \n        ", "20": "Tests that head signature of each batch of the block\nshould be not none", "21": "Tests that GET /blocks/  is reachable with block id \n        ", "22": "Tests that GET /blocks/ is not reachable with bad id\n        "}, "setup": {"duration": 0.000453948974609375, "outcome": "passed"}, "call": {"duration": 0.06452417373657227, "outcome": "passed"}, "teardown": {"duration": 0.0002722740173339844, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_rest_api_check_post_max_batches", "lineno": 378, "outcome": "passed", "keywords": ["TestBlockList", "()", "api_test", "get/test_rest_api_get_block.py", "run", "block", "fourth", "get", "test_rest_api_check_post_max_batches"], "metadata": {"0": "Tests the block list by submitting intkey batches\n        ", "1": "Tests that GET /blocks is reachable with head parameter \n        ", "2": "Tests that GET /blocks is unreachable with bad head parameter \n        ", "3": "Tests that GET /blocks is reachable with id as parameter \n        ", "4": "Tests that GET /blocks is unreachable with bad id parameter \n        ", "5": "Tests GET /blocks is reachable using paging parameters \n        ", "6": "Tests GET /batches is reachable with limit\n        ", "7": "Tests that GET /blocks is unreachable with invalid start parameter \n        ", "8": "Tests that GET /blocks is unreachable with bad limit parameter \n        ", "9": "verifies that GET /blocks when reversed\n        ", "10": "Verify the GET/ block link  value\n        ", "11": "Tests/ validate the block key parameters like data, head, link and paging               \n        ", "12": "Tests the each batch id length should be 128 hex character long \n        ", "13": "Tests the first block id length should be 128 hex character long \n        ", "14": "Tests that allow max post batches in block\nHandled max 100 batches post in block and handle for extra batch", "15": "Tests that head signature of each batch of the block \nshould be not none ", "16": "Test batch transaction family version should be present \nfor each transaction header", "17": "Test batch input and output content should be same for\neach batch and unique from other", "18": "Tests that signer public key is calculated for a block\nproperly", "19": "Tests blocks count from block list \n        ", "20": "Tests that head signature of each batch of the block\nshould be not none", "21": "Tests that GET /blocks/  is reachable with block id \n        ", "22": "Tests that GET /blocks/ is not reachable with bad id\n        "}, "setup": {"duration": 0.0004913806915283203, "outcome": "passed"}, "call": {"duration": 0.020194053649902344, "outcome": "passed"}, "teardown": {"duration": 0.000247955322265625, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_rest_api_check_head_signature", "lineno": 396, "outcome": "passed", "keywords": ["TestBlockList", "api_test", "test_rest_api_check_head_signature", "run", "block", "get/test_rest_api_get_block.py", "fourth", "get", "()"], "metadata": {"0": "Tests the block list by submitting intkey batches\n        ", "1": "Tests that GET /blocks is reachable with head parameter \n        ", "2": "Tests that GET /blocks is unreachable with bad head parameter \n        ", "3": "Tests that GET /blocks is reachable with id as parameter \n        ", "4": "Tests that GET /blocks is unreachable with bad id parameter \n        ", "5": "Tests GET /blocks is reachable using paging parameters \n        ", "6": "Tests GET /batches is reachable with limit\n        ", "7": "Tests that GET /blocks is unreachable with invalid start parameter \n        ", "8": "Tests that GET /blocks is unreachable with bad limit parameter \n        ", "9": "verifies that GET /blocks when reversed\n        ", "10": "Verify the GET/ block link  value\n        ", "11": "Tests/ validate the block key parameters like data, head, link and paging               \n        ", "12": "Tests the each batch id length should be 128 hex character long \n        ", "13": "Tests the first block id length should be 128 hex character long \n        ", "14": "Tests that allow max post batches in block\nHandled max 100 batches post in block and handle for extra batch", "15": "Tests that head signature of each batch of the block \nshould be not none ", "16": "Test batch transaction family version should be present \nfor each transaction header", "17": "Test batch input and output content should be same for\neach batch and unique from other", "18": "Tests that signer public key is calculated for a block\nproperly", "19": "Tests blocks count from block list \n        ", "20": "Tests that head signature of each batch of the block\nshould be not none", "21": "Tests that GET /blocks/  is reachable with block id \n        ", "22": "Tests that GET /blocks/ is not reachable with bad id\n        "}, "setup": {"duration": 0.0004546642303466797, "outcome": "passed"}, "call": {"duration": 0.019940853118896484, "outcome": "passed"}, "teardown": {"duration": 0.0002703666687011719, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_rest_api_check_family_version", "lineno": 414, "outcome": "passed", "keywords": ["TestBlockList", "api_test", "get/test_rest_api_get_block.py", "run", "test_rest_api_check_family_version", "block", "fourth", "get", "()"], "metadata": {"0": "Tests the block list by submitting intkey batches\n        ", "1": "Tests that GET /blocks is reachable with head parameter \n        ", "2": "Tests that GET /blocks is unreachable with bad head parameter \n        ", "3": "Tests that GET /blocks is reachable with id as parameter \n        ", "4": "Tests that GET /blocks is unreachable with bad id parameter \n        ", "5": "Tests GET /blocks is reachable using paging parameters \n        ", "6": "Tests GET /batches is reachable with limit\n        ", "7": "Tests that GET /blocks is unreachable with invalid start parameter \n        ", "8": "Tests that GET /blocks is unreachable with bad limit parameter \n        ", "9": "verifies that GET /blocks when reversed\n        ", "10": "Verify the GET/ block link  value\n        ", "11": "Tests/ validate the block key parameters like data, head, link and paging               \n        ", "12": "Tests the each batch id length should be 128 hex character long \n        ", "13": "Tests the first block id length should be 128 hex character long \n        ", "14": "Tests that allow max post batches in block\nHandled max 100 batches post in block and handle for extra batch", "15": "Tests that head signature of each batch of the block \nshould be not none ", "16": "Test batch transaction family version should be present \nfor each transaction header", "17": "Test batch input and output content should be same for\neach batch and unique from other", "18": "Tests that signer public key is calculated for a block\nproperly", "19": "Tests blocks count from block list \n        ", "20": "Tests that head signature of each batch of the block\nshould be not none", "21": "Tests that GET /blocks/  is reachable with block id \n        ", "22": "Tests that GET /blocks/ is not reachable with bad id\n        "}, "setup": {"duration": 0.0004677772521972656, "outcome": "passed"}, "call": {"duration": 0.0201871395111084, "outcome": "passed"}, "teardown": {"duration": 0.0002639293670654297, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_rest_api_check_input_output_content", "lineno": 431, "outcome": "passed", "keywords": ["TestBlockList", "()", "api_test", "get/test_rest_api_get_block.py", "run", "block", "fourth", "get", "test_rest_api_check_input_output_content"], "metadata": {"0": "Tests the block list by submitting intkey batches\n        ", "1": "Tests that GET /blocks is reachable with head parameter \n        ", "2": "Tests that GET /blocks is unreachable with bad head parameter \n        ", "3": "Tests that GET /blocks is reachable with id as parameter \n        ", "4": "Tests that GET /blocks is unreachable with bad id parameter \n        ", "5": "Tests GET /blocks is reachable using paging parameters \n        ", "6": "Tests GET /batches is reachable with limit\n        ", "7": "Tests that GET /blocks is unreachable with invalid start parameter \n        ", "8": "Tests that GET /blocks is unreachable with bad limit parameter \n        ", "9": "verifies that GET /blocks when reversed\n        ", "10": "Verify the GET/ block link  value\n        ", "11": "Tests/ validate the block key parameters like data, head, link and paging               \n        ", "12": "Tests the each batch id length should be 128 hex character long \n        ", "13": "Tests the first block id length should be 128 hex character long \n        ", "14": "Tests that allow max post batches in block\nHandled max 100 batches post in block and handle for extra batch", "15": "Tests that head signature of each batch of the block \nshould be not none ", "16": "Test batch transaction family version should be present \nfor each transaction header", "17": "Test batch input and output content should be same for\neach batch and unique from other", "18": "Tests that signer public key is calculated for a block\nproperly", "19": "Tests blocks count from block list \n        ", "20": "Tests that head signature of each batch of the block\nshould be not none", "21": "Tests that GET /blocks/  is reachable with block id \n        ", "22": "Tests that GET /blocks/ is not reachable with bad id\n        "}, "setup": {"duration": 0.00047469139099121094, "outcome": "passed"}, "call": {"duration": 0.020051956176757812, "outcome": "passed"}, "teardown": {"duration": 0.00025200843811035156, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_rest_api_check_signer_public_key", "lineno": 449, "outcome": "passed", "keywords": ["TestBlockList", "()", "api_test", "get/test_rest_api_get_block.py", "run", "block", "fourth", "get", "test_rest_api_check_signer_public_key"], "metadata": {"0": "Tests the block list by submitting intkey batches\n        ", "1": "Tests that GET /blocks is reachable with head parameter \n        ", "2": "Tests that GET /blocks is unreachable with bad head parameter \n        ", "3": "Tests that GET /blocks is reachable with id as parameter \n        ", "4": "Tests that GET /blocks is unreachable with bad id parameter \n        ", "5": "Tests GET /blocks is reachable using paging parameters \n        ", "6": "Tests GET /batches is reachable with limit\n        ", "7": "Tests that GET /blocks is unreachable with invalid start parameter \n        ", "8": "Tests that GET /blocks is unreachable with bad limit parameter \n        ", "9": "verifies that GET /blocks when reversed\n        ", "10": "Verify the GET/ block link  value\n        ", "11": "Tests/ validate the block key parameters like data, head, link and paging               \n        ", "12": "Tests the each batch id length should be 128 hex character long \n        ", "13": "Tests the first block id length should be 128 hex character long \n        ", "14": "Tests that allow max post batches in block\nHandled max 100 batches post in block and handle for extra batch", "15": "Tests that head signature of each batch of the block \nshould be not none ", "16": "Test batch transaction family version should be present \nfor each transaction header", "17": "Test batch input and output content should be same for\neach batch and unique from other", "18": "Tests that signer public key is calculated for a block\nproperly", "19": "Tests blocks count from block list \n        ", "20": "Tests that head signature of each batch of the block\nshould be not none", "21": "Tests that GET /blocks/  is reachable with block id \n        ", "22": "Tests that GET /blocks/ is not reachable with bad id\n        "}, "setup": {"duration": 0.0004856586456298828, "outcome": "passed"}, "call": {"duration": 0.0203244686126709, "outcome": "passed"}, "teardown": {"duration": 0.00025534629821777344, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_rest_api_check_blocks_count", "lineno": 465, "outcome": "passed", "keywords": ["TestBlockList", "api_test", "get/test_rest_api_get_block.py", "run", "block", "test_rest_api_check_blocks_count", "fourth", "get", "()"], "metadata": {"0": "Tests the block list by submitting intkey batches\n        ", "1": "Tests that GET /blocks is reachable with head parameter \n        ", "2": "Tests that GET /blocks is unreachable with bad head parameter \n        ", "3": "Tests that GET /blocks is reachable with id as parameter \n        ", "4": "Tests that GET /blocks is unreachable with bad id parameter \n        ", "5": "Tests GET /blocks is reachable using paging parameters \n        ", "6": "Tests GET /batches is reachable with limit\n        ", "7": "Tests that GET /blocks is unreachable with invalid start parameter \n        ", "8": "Tests that GET /blocks is unreachable with bad limit parameter \n        ", "9": "verifies that GET /blocks when reversed\n        ", "10": "Verify the GET/ block link  value\n        ", "11": "Tests/ validate the block key parameters like data, head, link and paging               \n        ", "12": "Tests the each batch id length should be 128 hex character long \n        ", "13": "Tests the first block id length should be 128 hex character long \n        ", "14": "Tests that allow max post batches in block\nHandled max 100 batches post in block and handle for extra batch", "15": "Tests that head signature of each batch of the block \nshould be not none ", "16": "Test batch transaction family version should be present \nfor each transaction header", "17": "Test batch input and output content should be same for\neach batch and unique from other", "18": "Tests that signer public key is calculated for a block\nproperly", "19": "Tests blocks count from block list \n        ", "20": "Tests that head signature of each batch of the block\nshould be not none", "21": "Tests that GET /blocks/  is reachable with block id \n        ", "22": "Tests that GET /blocks/ is not reachable with bad id\n        "}, "setup": {"duration": 0.00045561790466308594, "outcome": "passed"}, "call": {"duration": 0.020492076873779297, "outcome": "passed"}, "teardown": {"duration": 0.0002593994140625, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockList::test_rest_api_blk_content_head_signature", "lineno": 480, "outcome": "passed", "keywords": ["test_rest_api_blk_content_head_signature", "TestBlockList", "api_test", "get/test_rest_api_get_block.py", "run", "block", "fourth", "get", "()"], "metadata": {"0": "Tests the block list by submitting intkey batches\n        ", "1": "Tests that GET /blocks is reachable with head parameter \n        ", "2": "Tests that GET /blocks is unreachable with bad head parameter \n        ", "3": "Tests that GET /blocks is reachable with id as parameter \n        ", "4": "Tests that GET /blocks is unreachable with bad id parameter \n        ", "5": "Tests GET /blocks is reachable using paging parameters \n        ", "6": "Tests GET /batches is reachable with limit\n        ", "7": "Tests that GET /blocks is unreachable with invalid start parameter \n        ", "8": "Tests that GET /blocks is unreachable with bad limit parameter \n        ", "9": "verifies that GET /blocks when reversed\n        ", "10": "Verify the GET/ block link  value\n        ", "11": "Tests/ validate the block key parameters like data, head, link and paging               \n        ", "12": "Tests the each batch id length should be 128 hex character long \n        ", "13": "Tests the first block id length should be 128 hex character long \n        ", "14": "Tests that allow max post batches in block\nHandled max 100 batches post in block and handle for extra batch", "15": "Tests that head signature of each batch of the block \nshould be not none ", "16": "Test batch transaction family version should be present \nfor each transaction header", "17": "Test batch input and output content should be same for\neach batch and unique from other", "18": "Tests that signer public key is calculated for a block\nproperly", "19": "Tests blocks count from block list \n        ", "20": "Tests that head signature of each batch of the block\nshould be not none", "21": "Tests that GET /blocks/  is reachable with block id \n        ", "22": "Tests that GET /blocks/ is not reachable with bad id\n        "}, "setup": {"duration": 0.00048732757568359375, "outcome": "passed"}, "call": {"duration": 0.06322717666625977, "outcome": "passed"}, "teardown": {"duration": 0.0002684593200683594, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockGet::test_api_get_block_id", "lineno": 501, "outcome": "failed", "keywords": ["api_test", "get/test_rest_api_get_block.py", "run", "get", "block", "fourth", "test_api_get_block_id", "TestBlockGet", "()"], "metadata": {"0": "Tests the block list by submitting intkey batches\n        ", "1": "Tests that GET /blocks is reachable with head parameter \n        ", "2": "Tests that GET /blocks is unreachable with bad head parameter \n        ", "3": "Tests that GET /blocks is reachable with id as parameter \n        ", "4": "Tests that GET /blocks is unreachable with bad id parameter \n        ", "5": "Tests GET /blocks is reachable using paging parameters \n        ", "6": "Tests GET /batches is reachable with limit\n        ", "7": "Tests that GET /blocks is unreachable with invalid start parameter \n        ", "8": "Tests that GET /blocks is unreachable with bad limit parameter \n        ", "9": "verifies that GET /blocks when reversed\n        ", "10": "Verify the GET/ block link  value\n        ", "11": "Tests/ validate the block key parameters like data, head, link and paging               \n        ", "12": "Tests the each batch id length should be 128 hex character long \n        ", "13": "Tests the first block id length should be 128 hex character long \n        ", "14": "Tests that allow max post batches in block\nHandled max 100 batches post in block and handle for extra batch", "15": "Tests that head signature of each batch of the block \nshould be not none ", "16": "Test batch transaction family version should be present \nfor each transaction header", "17": "Test batch input and output content should be same for\neach batch and unique from other", "18": "Tests that signer public key is calculated for a block\nproperly", "19": "Tests blocks count from block list \n        ", "20": "Tests that head signature of each batch of the block\nshould be not none", "21": "Tests that GET /blocks/  is reachable with block id \n        ", "22": "Tests that GET /blocks/ is not reachable with bad id\n        "}, "setup": {"duration": 0.0004754066467285156, "outcome": "passed"}, "call": {"duration": 0.0005114078521728516, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_block.py", "lineno": 508, "message": "IndexError: list index out of range"}, "traceback": [{"path": "get/test_rest_api_get_block.py", "lineno": 508, "message": "IndexError"}], "log": [{"name": "test_rest_api_get_block", "msg": "Starting test for blocks/{block_id}", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_block.py", "filename": "test_rest_api_get_block.py", "module": "test_rest_api_get_block", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 505, "funcName": "test_api_get_block_id", "created": 1552989092.6436126, "msecs": 643.6126232147217, "relativeCreated": 1213501.0333061218, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:32"}], "longrepr": "self = <test_rest_api_get_block.TestBlockGet object at 0x7fd599b79b70>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_get_block_id(self, setup):\n        \"\"\"Tests that GET /blocks/  is reachable with block id\n        \"\"\"\n        LOGGER.info(\"Starting test for blocks/{block_id}\")\n        signer_key = setup['signer_key']\n        expected_head = setup['expected_head']\n>       expected_id  = setup['block_ids'][0]\nE       IndexError: list index out of range\n\nget/test_rest_api_get_block.py:508: IndexError"}, "teardown": {"duration": 0.00023436546325683594, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_block.py::TestBlockGet::test_api_get_bad_block_id", "lineno": 526, "outcome": "passed", "keywords": ["api_test", "get/test_rest_api_get_block.py", "run", "get", "block", "fourth", "test_api_get_bad_block_id", "TestBlockGet", "()"], "metadata": {"0": "Tests the block list by submitting intkey batches\n        ", "1": "Tests that GET /blocks is reachable with head parameter \n        ", "2": "Tests that GET /blocks is unreachable with bad head parameter \n        ", "3": "Tests that GET /blocks is reachable with id as parameter \n        ", "4": "Tests that GET /blocks is unreachable with bad id parameter \n        ", "5": "Tests GET /blocks is reachable using paging parameters \n        ", "6": "Tests GET /batches is reachable with limit\n        ", "7": "Tests that GET /blocks is unreachable with invalid start parameter \n        ", "8": "Tests that GET /blocks is unreachable with bad limit parameter \n        ", "9": "verifies that GET /blocks when reversed\n        ", "10": "Verify the GET/ block link  value\n        ", "11": "Tests/ validate the block key parameters like data, head, link and paging               \n        ", "12": "Tests the each batch id length should be 128 hex character long \n        ", "13": "Tests the first block id length should be 128 hex character long \n        ", "14": "Tests that allow max post batches in block\nHandled max 100 batches post in block and handle for extra batch", "15": "Tests that head signature of each batch of the block \nshould be not none ", "16": "Test batch transaction family version should be present \nfor each transaction header", "17": "Test batch input and output content should be same for\neach batch and unique from other", "18": "Tests that signer public key is calculated for a block\nproperly", "19": "Tests blocks count from block list \n        ", "20": "Tests that head signature of each batch of the block\nshould be not none", "21": "Tests that GET /blocks/  is reachable with block id \n        ", "22": "Tests that GET /blocks/ is not reachable with bad id\n        "}, "setup": {"duration": 0.00041747093200683594, "outcome": "passed"}, "call": {"duration": 0.015090227127075195, "outcome": "passed", "log": [{"name": "test_rest_api_get_block", "msg": "Starting test for blocks/{bad_block_id}", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_block.py", "filename": "test_rest_api_get_block.py", "module": "test_rest_api_get_block", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 530, "funcName": "test_api_get_bad_block_id", "created": 1552989092.6535194, "msecs": 653.5193920135498, "relativeCreated": 1213510.9400749207, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:32"}]}, "teardown": {"duration": 0.0002319812774658203, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList::test_api_get_reciept_invalid_id", "lineno": 57, "outcome": "passed", "keywords": ["()", "fifth", "run", "TestReceiptsList", "test_api_get_reciept_invalid_id", "get/test_rest_api_get_receipts.py", "api_test", "get", "receipts"], "metadata": {"0": "Tests the reciepts after submitting invalid transaction\n        ", "1": "Test the get reciepts for multiple transaction.\n        ", "2": "Tests get reciepts response for single transaction", "3": "Test post reciepts response for single transaction", "4": "test reciepts post for invalid transaction", "5": "Test the post reciepts response for multiple transaction.\n       "}, "setup": {"duration": 0.0004012584686279297, "outcome": "passed"}, "call": {"duration": 0.015395879745483398, "outcome": "passed"}, "teardown": {"duration": 0.00024318695068359375, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList::test_api_get_reciepts_multiple_transactions", "lineno": 73, "outcome": "failed", "keywords": ["()", "fifth", "run", "TestReceiptsList", "test_api_get_reciepts_multiple_transactions", "get/test_rest_api_get_receipts.py", "api_test", "get", "receipts"], "metadata": {"0": "Tests the reciepts after submitting invalid transaction\n        ", "1": "Test the get reciepts for multiple transaction.\n        ", "2": "Tests get reciepts response for single transaction", "3": "Test post reciepts response for single transaction", "4": "test reciepts post for invalid transaction", "5": "Test the post reciepts response for multiple transaction.\n       "}, "setup": {"duration": 0.0004150867462158203, "outcome": "passed"}, "call": {"duration": 0.0039060115814208984, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_receipts.py", "lineno": 96, "message": "KeyError: 'data'"}, "traceback": [{"path": "get/test_rest_api_get_receipts.py", "lineno": 96, "message": "KeyError"}], "longrepr": "self = <test_rest_api_get_receipts.TestReceiptsList object at 0x7fd599aaea20>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_get_reciepts_multiple_transactions(self, setup):\n        \"\"\"Test the get reciepts for multiple transaction.\n        \"\"\"\n        transaction_list=\"\"\n        expected_txns = setup['expected_txns']\n        address = setup['address']\n        print(expected_txns)\n    \n        for txn in expected_txns:\n            transaction_list=txn+\",\"+transaction_list\n    \n        trans_list = str(transaction_list)[:-1]\n        params={'id':trans_list}\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.get(url='{}/receipts'.format(address),params=params) as data:\n                    response = await data.json()\n        except aiohttp.client_exceptions.ClientResponseError as error:\n            LOGGER.info(\"Rest Api is Unreachable\")\n    \n    \n>       for res,txn in zip(response['data'],reversed(expected_txns)):\nE       KeyError: 'data'\n\nget/test_rest_api_get_receipts.py:96: KeyError"}, "teardown": {"duration": 0.0002353191375732422, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList::test_api_get_reciepts_single_transactions", "lineno": 98, "outcome": "passed", "keywords": ["()", "test_api_get_reciepts_single_transactions", "fifth", "run", "TestReceiptsList", "get/test_rest_api_get_receipts.py", "api_test", "get", "receipts"], "metadata": {"0": "Tests the reciepts after submitting invalid transaction\n        ", "1": "Test the get reciepts for multiple transaction.\n        ", "2": "Tests get reciepts response for single transaction", "3": "Test post reciepts response for single transaction", "4": "test reciepts post for invalid transaction", "5": "Test the post reciepts response for multiple transaction.\n       "}, "setup": {"duration": 0.00039839744567871094, "outcome": "passed"}, "call": {"duration": 0.01676464080810547, "outcome": "passed"}, "teardown": {"duration": 0.0002346038818359375, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList::test_api_post_reciepts_single_transactions", "lineno": 113, "outcome": "passed", "keywords": ["()", "api_test", "fifth", "run", "TestReceiptsList", "get/test_rest_api_get_receipts.py", "test_api_post_reciepts_single_transactions", "get", "receipts"], "metadata": {"0": "Tests the reciepts after submitting invalid transaction\n        ", "1": "Test the get reciepts for multiple transaction.\n        ", "2": "Tests get reciepts response for single transaction", "3": "Test post reciepts response for single transaction", "4": "test reciepts post for invalid transaction", "5": "Test the post reciepts response for multiple transaction.\n       "}, "setup": {"duration": 0.00041222572326660156, "outcome": "passed"}, "call": {"duration": 0.016729116439819336, "outcome": "passed"}, "teardown": {"duration": 0.00023865699768066406, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList::test_api_post_reciepts_invalid_transactions", "lineno": 130, "outcome": "passed", "keywords": ["()", "fifth", "run", "TestReceiptsList", "get/test_rest_api_get_receipts.py", "api_test", "get", "test_api_post_reciepts_invalid_transactions", "receipts"], "metadata": {"0": "Tests the reciepts after submitting invalid transaction\n        ", "1": "Test the get reciepts for multiple transaction.\n        ", "2": "Tests get reciepts response for single transaction", "3": "Test post reciepts response for single transaction", "4": "test reciepts post for invalid transaction", "5": "Test the post reciepts response for multiple transaction.\n       "}, "setup": {"duration": 0.00042724609375, "outcome": "passed"}, "call": {"duration": 0.014824151992797852, "outcome": "passed"}, "teardown": {"duration": 0.0002396106719970703, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_receipts.py::TestReceiptsList::test_api_post_reciepts_multiple_transactions", "lineno": 146, "outcome": "failed", "keywords": ["()", "test_api_post_reciepts_multiple_transactions", "fifth", "run", "TestReceiptsList", "get/test_rest_api_get_receipts.py", "api_test", "get", "receipts"], "metadata": {"0": "Tests the reciepts after submitting invalid transaction\n        ", "1": "Test the get reciepts for multiple transaction.\n        ", "2": "Tests get reciepts response for single transaction", "3": "Test post reciepts response for single transaction", "4": "test reciepts post for invalid transaction", "5": "Test the post reciepts response for multiple transaction.\n       "}, "setup": {"duration": 0.0004112720489501953, "outcome": "passed"}, "call": {"duration": 0.003792285919189453, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/get/test_rest_api_get_receipts.py", "lineno": 163, "message": "KeyError: 'data'"}, "traceback": [{"path": "get/test_rest_api_get_receipts.py", "lineno": 163, "message": "KeyError"}], "longrepr": "self = <test_rest_api_get_receipts.TestReceiptsList object at 0x7fd599a9c470>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_post_reciepts_multiple_transactions(self, setup):\n       \"\"\"Test the post reciepts response for multiple transaction.\n       \"\"\"\n       address = setup['address']\n       expected_txns = setup['expected_txns']\n       json_list=json.dumps(expected_txns).encode()\n       headers = {'content-type': 'application/json'}\n    \n       try:\n        async with aiohttp.ClientSession() as session:\n            async with session.post(url='{}/receipts'.format(address),\n                                    data=json_list,headers=headers) as data:\n                response = await data.json()\n       except aiohttp.client_exceptions.ClientResponseError as error:\n        LOGGER.info(error)\n    \n>      for res,txn in zip(response['data'], expected_txns):\nE      KeyError: 'data'\n\nget/test_rest_api_get_receipts.py:163: KeyError"}, "teardown": {"duration": 0.00025963783264160156, "outcome": "passed"}}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_set_inc_txn_dep", "lineno": 102, "outcome": "failed", "keywords": ["test_set_inc_txn_dep", "run", "TestPostTansactionDependencies", "api_test", "dep_txns/test_rest_api_dep_txns.py", "sixth", "()", "dependent"], "metadata": {"0": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "1": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                                                             \n3. Create third Transaction for decrement with first and second Transaction as dependecies                                                            \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "2": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "3": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "4": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies\n3. Create third Transaction for increment with first and second Transaction as dependecies                                                                                                                \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "5": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single and same  dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "6": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with invalid Transaction as dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "7": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment reverse dependency                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "8": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies                                                                                                          \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This should be an invalid transaction. The third txn will be in PENDING state", "9": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies with different key                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This shoud be an invalid transaction. The trird txn will be in PENDING state", "10": "1. Create first Transaction for set with max value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "11": "1. Create first invalid Transaction for set with negative value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first invalid Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "12": "1. Create first Transaction for set                                                                                                                                                                                                                   \n2. Create second dependent Transaction for increment and make the address invalid with first Transaction as dependency     \n3. Create batch ,post batch and check the response status\n4. The second transaction will be an invalid transaction\n5. Create the third transaction for decrement with first and second as dependency \n6. Create a batch and post batch\nVerify the transaction responses. The first one will be COMMITTED and second one shoud be an invalid transaction. The third txn will be with error code 17 and Validator Timed Out", "13": "1.Create 5 independent Transactions for set\n2.Create second dependent transaction for set with 5 independent transactions as dependency\n3.Create third dependent Transaction for increment with second dependent Transaction as dependency     \n4.Create a batch for all the dependent transaction and post batch\n5.Check for the status\n6.Now create the batch for independent transactions and post batch\n7. Check for the response status of both independent and dependent transactions", "14": "1.Create a dependent transactions for increment\n2.Create a dependent transaction for set for the same key with first transaction as dependent                                                                                                                                                \n3.Create batch and post the first transaction(increment) first and check the response status\n4.Post the second transaction(set)  and check the response status", "15": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, fourth is depend on third and fifth is depend on fourth\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be COMMITTED.", "16": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, \nfourth is depend on third and fifth is depend on fourth. Fourth one will be an invalid txn\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be INVALID.", "17": "1.Create first batch having 3 transactions.\n2.Make third transaction invalid from first  batch.\n3.Create second batch having 2 transactions \n4.Make transaction from second batch dependent on transaction from first batch.\n5.post batch and check for the status.\n6.Create third batch having 2 transaction.\n7.Make transaction from third batch dependent on transaction from second batch.\n8.post batch and check for the status."}, "setup": {"duration": 0.0005321502685546875, "outcome": "passed"}, "call": {"duration": 300.0217981338501, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "lineno": 176, "message": "KeyError: 'data'"}, "traceback": [{"path": "dep_txns/test_rest_api_dep_txns.py", "lineno": 176, "message": "KeyError"}], "log": [{"name": "test_rest_api_dep_txns", "msg": "Starting test for batch post", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 110, "funcName": "test_set_inc_txn_dep", "created": 1552989092.7578914, "msecs": 757.8914165496826, "relativeCreated": 1213615.3120994568, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:32"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with set operations", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 121, "funcName": "test_set_inc_txn_dep", "created": 1552989092.7603493, "msecs": 760.3492736816406, "relativeCreated": 1213617.7699565887, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:32"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with inc operations with dependent transactions as first transaction", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 135, "funcName": "test_set_inc_txn_dep", "created": 1552989092.7610488, "msecs": 761.0487937927246, "relativeCreated": 1213618.4694766998, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:32"}, {"name": "test_rest_api_dep_txns", "msg": "Creating batches for transactions 1trn/batch", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 147, "funcName": "test_set_inc_txn_dep", "created": 1552989092.761332, "msecs": 761.3320350646973, "relativeCreated": 1213618.7527179718, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:32"}, {"name": "test_rest_api_dep_txns", "msg": "Submitting batches to the handlers", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 162, "funcName": "test_set_inc_txn_dep", "created": 1552989092.761921, "msecs": 761.9209289550781, "relativeCreated": 1213619.3416118622, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:21:32"}, {"name": "test_rest_api_dep_txns", "msg": "Verifying the responses status", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 173, "funcName": "test_set_inc_txn_dep", "created": 1552989392.778412, "msecs": 778.4121036529541, "relativeCreated": 1513635.83278656, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:26:32"}], "longrepr": "self = <test_rest_api_dep_txns.TestPostTansactionDependencies object at 0x7fd599af8e10>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_set_inc_txn_dep(self, setup):\n        \"\"\"\"1. Create first Transaction for set\n            2. Create second Transaction for increment with first Transaction as dependecies\n            3. Create Batch\n            4. Call POST /batches \"\n            Verify the transactions\n        \"\"\"\n        LOGGER.info('Starting test for batch post')\n    \n        signer = get_signer()\n        expected_trxn_ids  = []\n        expected_batch_ids = []\n        address = _get_client_address()\n        url='{}/batches'.format(address)\n        tasks=[]\n    \n        name = random.choice(\"abcdefghijklmnopqrstuv\")\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction_dep(\"set\", [] , name, 50, signer),]\n        for txn in txns:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxn_ids.append(trxn_id)\n    \n    \n        LOGGER.info(\"Creating intkey transactions with inc operations with dependent transactions as first transaction\")\n        trxn_ids = expected_trxn_ids\n        txns.append(create_intkey_transaction_dep(\"inc\", trxn_ids , name, 20, signer))\n        for txn in txns:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxn_ids.append(trxn_id)\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            data = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = data['header_signature']\n            expected_batch_ids.append(batch_id)\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                for batch in post_batch_list:\n                    task = asyncio.ensure_future(async_post_batch(url,session,data=batch))\n                    tasks.append(task)\n                responses = await asyncio.gather(*tasks)\n        except aiohttp.client_exceptions.ClientResponseError as error:\n            LOGGER.info(\"Rest Api is Unreachable\")\n    \n        LOGGER.info(\"Verifying the responses status\")\n    \n        for response in responses:\n>           batch_id = response['data'][0]['id']\nE           KeyError: 'data'\n\ndep_txns/test_rest_api_dep_txns.py:176: KeyError"}, "teardown": {"duration": 0.0002875328063964844, "outcome": "passed"}}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_rest_api_double_dep_txns", "lineno": 200, "outcome": "failed", "keywords": ["run", "TestPostTansactionDependencies", "api_test", "test_rest_api_double_dep_txns", "dep_txns/test_rest_api_dep_txns.py", "sixth", "()", "dependent"], "metadata": {"0": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "1": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                                                             \n3. Create third Transaction for decrement with first and second Transaction as dependecies                                                            \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "2": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "3": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "4": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies\n3. Create third Transaction for increment with first and second Transaction as dependecies                                                                                                                \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "5": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single and same  dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "6": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with invalid Transaction as dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "7": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment reverse dependency                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "8": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies                                                                                                          \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This should be an invalid transaction. The third txn will be in PENDING state", "9": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies with different key                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This shoud be an invalid transaction. The trird txn will be in PENDING state", "10": "1. Create first Transaction for set with max value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "11": "1. Create first invalid Transaction for set with negative value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first invalid Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "12": "1. Create first Transaction for set                                                                                                                                                                                                                   \n2. Create second dependent Transaction for increment and make the address invalid with first Transaction as dependency     \n3. Create batch ,post batch and check the response status\n4. The second transaction will be an invalid transaction\n5. Create the third transaction for decrement with first and second as dependency \n6. Create a batch and post batch\nVerify the transaction responses. The first one will be COMMITTED and second one shoud be an invalid transaction. The third txn will be with error code 17 and Validator Timed Out", "13": "1.Create 5 independent Transactions for set\n2.Create second dependent transaction for set with 5 independent transactions as dependency\n3.Create third dependent Transaction for increment with second dependent Transaction as dependency     \n4.Create a batch for all the dependent transaction and post batch\n5.Check for the status\n6.Now create the batch for independent transactions and post batch\n7. Check for the response status of both independent and dependent transactions", "14": "1.Create a dependent transactions for increment\n2.Create a dependent transaction for set for the same key with first transaction as dependent                                                                                                                                                \n3.Create batch and post the first transaction(increment) first and check the response status\n4.Post the second transaction(set)  and check the response status", "15": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, fourth is depend on third and fifth is depend on fourth\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be COMMITTED.", "16": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, \nfourth is depend on third and fifth is depend on fourth. Fourth one will be an invalid txn\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be INVALID.", "17": "1.Create first batch having 3 transactions.\n2.Make third transaction invalid from first  batch.\n3.Create second batch having 2 transactions \n4.Make transaction from second batch dependent on transaction from first batch.\n5.post batch and check for the status.\n6.Create third batch having 2 transaction.\n7.Make transaction from third batch dependent on transaction from second batch.\n8.post batch and check for the status."}, "setup": {"duration": 0.0005397796630859375, "outcome": "passed"}, "call": {"duration": 300.0299186706543, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "lineno": 286, "message": "KeyError: 'data'"}, "traceback": [{"path": "dep_txns/test_rest_api_dep_txns.py", "lineno": 286, "message": "KeyError"}], "log": [{"name": "test_rest_api_dep_txns", "msg": "Starting test for batch post", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 209, "funcName": "test_rest_api_double_dep_txns", "created": 1552989392.8083677, "msecs": 808.3677291870117, "relativeCreated": 1513665.788412094, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:26:32"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with set operations", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 219, "funcName": "test_rest_api_double_dep_txns", "created": 1552989392.8108468, "msecs": 810.8468055725098, "relativeCreated": 1513668.2674884796, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:26:32"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with inc operations with dependent transactions as first transaction", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 233, "funcName": "test_rest_api_double_dep_txns", "created": 1552989392.8115392, "msecs": 811.5391731262207, "relativeCreated": 1513668.9598560333, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:26:32"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with inc operations with dependent transactions as first and second transaction", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 245, "funcName": "test_rest_api_double_dep_txns", "created": 1552989392.8118174, "msecs": 811.8174076080322, "relativeCreated": 1513669.2380905151, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:26:32"}, {"name": "test_rest_api_dep_txns", "msg": "Creating batches for transactions 1trn/batch", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 257, "funcName": "test_rest_api_double_dep_txns", "created": 1552989392.8120773, "msecs": 812.0772838592529, "relativeCreated": 1513669.4979667664, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:26:32"}, {"name": "test_rest_api_dep_txns", "msg": "Submitting batches to the handlers", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 272, "funcName": "test_rest_api_double_dep_txns", "created": 1552989392.8127925, "msecs": 812.7925395965576, "relativeCreated": 1513670.2132225037, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:26:32"}, {"name": "test_rest_api_dep_txns", "msg": "Verifying the responses status", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 283, "funcName": "test_rest_api_double_dep_txns", "created": 1552989692.837348, "msecs": 837.3479843139648, "relativeCreated": 1813694.768667221, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:31:32"}], "longrepr": "self = <test_rest_api_dep_txns.TestPostTansactionDependencies object at 0x7fd599a37e48>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_rest_api_double_dep_txns(self, setup):\n        \"\"\"1. Create first Transaction for set\n        2. Create second Transaction for increment with first Transaction as dependecies\n        3. Create third Transaction for decrement with first and second Transaction as dependecies\n        4. Create Batch\n        5. Call POST /batches\n        Verify the transactions\n        \"\"\"\n        LOGGER.info('Starting test for batch post')\n    \n        signer = get_signer()\n        expected_trxn_ids  = []\n        expected_batch_ids = []\n        address = _get_client_address()\n        url='{}/batches'.format(address)\n        tasks=[]\n        name = random.choice(\"abcdefghijklmnopqrstuv\")\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction_dep(\"set\", [] , name, 50, signer),]\n        for txn in txns:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxn_ids.append(trxn_id)\n    \n    \n        LOGGER.info(\"Creating intkey transactions with inc operations with dependent transactions as first transaction\")\n        trxn_ids = expected_trxn_ids\n        txns.append(create_intkey_transaction_dep(\"inc\", trxn_ids , name, 20, signer))\n        for txn in txns:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxn_ids.append(trxn_id)\n    \n        LOGGER.info(\"Creating intkey transactions with inc operations with dependent transactions as first and second transaction\")\n        trxn_ids = expected_trxn_ids\n        txns.append(create_intkey_transaction_dep(\"dec\", trxn_ids , name, 50, signer))\n        for txn in txns:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxn_ids.append(trxn_id)\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            data = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = data['header_signature']\n            expected_batch_ids.append(batch_id)\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                for batch in post_batch_list:\n                    task = asyncio.ensure_future(async_post_batch(url,session,data=batch))\n                    tasks.append(task)\n                responses = await asyncio.gather(*tasks)\n        except aiohttp.client_exceptions.ClientResponseError as error:\n            LOGGER.info(\"Rest Api is Unreachable\")\n    \n        LOGGER.info(\"Verifying the responses status\")\n    \n        for response in responses:\n>           batch_id = response['data'][0]['id']\nE           KeyError: 'data'\n\ndep_txns/test_rest_api_dep_txns.py:286: KeyError"}, "teardown": {"duration": 0.0003020763397216797, "outcome": "passed"}}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_single_set_dep_txns", "lineno": 310, "outcome": "failed", "keywords": ["run", "TestPostTansactionDependencies", "api_test", "test_single_set_dep_txns", "dep_txns/test_rest_api_dep_txns.py", "sixth", "()", "dependent"], "metadata": {"0": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "1": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                                                             \n3. Create third Transaction for decrement with first and second Transaction as dependecies                                                            \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "2": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "3": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "4": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies\n3. Create third Transaction for increment with first and second Transaction as dependecies                                                                                                                \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "5": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single and same  dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "6": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with invalid Transaction as dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "7": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment reverse dependency                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "8": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies                                                                                                          \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This should be an invalid transaction. The third txn will be in PENDING state", "9": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies with different key                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This shoud be an invalid transaction. The trird txn will be in PENDING state", "10": "1. Create first Transaction for set with max value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "11": "1. Create first invalid Transaction for set with negative value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first invalid Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "12": "1. Create first Transaction for set                                                                                                                                                                                                                   \n2. Create second dependent Transaction for increment and make the address invalid with first Transaction as dependency     \n3. Create batch ,post batch and check the response status\n4. The second transaction will be an invalid transaction\n5. Create the third transaction for decrement with first and second as dependency \n6. Create a batch and post batch\nVerify the transaction responses. The first one will be COMMITTED and second one shoud be an invalid transaction. The third txn will be with error code 17 and Validator Timed Out", "13": "1.Create 5 independent Transactions for set\n2.Create second dependent transaction for set with 5 independent transactions as dependency\n3.Create third dependent Transaction for increment with second dependent Transaction as dependency     \n4.Create a batch for all the dependent transaction and post batch\n5.Check for the status\n6.Now create the batch for independent transactions and post batch\n7. Check for the response status of both independent and dependent transactions", "14": "1.Create a dependent transactions for increment\n2.Create a dependent transaction for set for the same key with first transaction as dependent                                                                                                                                                \n3.Create batch and post the first transaction(increment) first and check the response status\n4.Post the second transaction(set)  and check the response status", "15": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, fourth is depend on third and fifth is depend on fourth\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be COMMITTED.", "16": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, \nfourth is depend on third and fifth is depend on fourth. Fourth one will be an invalid txn\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be INVALID.", "17": "1.Create first batch having 3 transactions.\n2.Make third transaction invalid from first  batch.\n3.Create second batch having 2 transactions \n4.Make transaction from second batch dependent on transaction from first batch.\n5.post batch and check for the status.\n6.Create third batch having 2 transaction.\n7.Make transaction from third batch dependent on transaction from second batch.\n8.post batch and check for the status."}, "setup": {"duration": 0.0005834102630615234, "outcome": "passed"}, "call": {"duration": 300.0408396720886, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "lineno": 392, "message": "KeyError: 'data'"}, "traceback": [{"path": "dep_txns/test_rest_api_dep_txns.py", "lineno": 392, "message": "KeyError"}], "log": [{"name": "test_rest_api_dep_txns", "msg": "Starting test for batch post", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 318, "funcName": "test_single_set_dep_txns", "created": 1552989692.8658042, "msecs": 865.8041954040527, "relativeCreated": 1813723.2248783112, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:31:32"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with set operations", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 334, "funcName": "test_single_set_dep_txns", "created": 1552989692.87665, "msecs": 876.6500949859619, "relativeCreated": 1813734.070777893, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:31:32"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with inc operations with dependent transactions as first transaction", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 348, "funcName": "test_single_set_dep_txns", "created": 1552989692.8773413, "msecs": 877.3412704467773, "relativeCreated": 1813734.7619533539, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:31:32"}, {"name": "test_rest_api_dep_txns", "msg": "Creating batches for transactions 1trn/batch", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 363, "funcName": "test_single_set_dep_txns", "created": 1552989692.8854856, "msecs": 885.4856491088867, "relativeCreated": 1813742.906332016, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:31:32"}, {"name": "test_rest_api_dep_txns", "msg": "Submitting batches to the handlers", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 378, "funcName": "test_single_set_dep_txns", "created": 1552989692.886107, "msecs": 886.1069679260254, "relativeCreated": 1813743.5276508331, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:31:32"}, {"name": "test_rest_api_dep_txns", "msg": "Verifying the responses status", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 389, "funcName": "test_single_set_dep_txns", "created": 1552989992.9050004, "msecs": 905.0004482269287, "relativeCreated": 2113762.421131134, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:36:32"}], "longrepr": "self = <test_rest_api_dep_txns.TestPostTansactionDependencies object at 0x7fd599aae2e8>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_single_set_dep_txns(self, setup):\n        \"\"\"\"1. Create first Transaction for set\n            2. Create second Transaction for increment with single dependecies\n            3. Create Batch\n            4. Call POST /batches \"\n            Verify the transactions\n        \"\"\"\n        LOGGER.info('Starting test for batch post')\n    \n        signer = get_signer()\n        expected_trxn_ids  = []\n        expected_batch_ids = []\n        address = _get_client_address()\n        url='{}/batches'.format(address)\n        tasks=[]\n        t = datetime.datetime.now()\n        date = t.strftime('%H%M%S')\n        words = random_word_list(100)\n        name=random.choice(words)\n    \n        #name=random.choice('123456734558909877')\n    \n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction_dep(\"set\", [] , name, 50, signer),]\n        for txn in txns:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxn_ids.append(trxn_id)\n    \n    \n        LOGGER.info(\"Creating intkey transactions with inc operations with dependent transactions as first transaction\")\n        trxn_ids = expected_trxn_ids\n        words = random_word_list(100)\n        name=random.choice(words)\n        #name=random.choice('123456734558909877')\n        txns.append(create_intkey_transaction_dep(\"set\",trxn_ids, name, 20, signer))\n        for txn in txns:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxn_ids.append(trxn_id)\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            data = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = data['header_signature']\n            expected_batch_ids.append(batch_id)\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                for batch in post_batch_list:\n                    task = asyncio.ensure_future(async_post_batch(url,session,data=batch))\n                    tasks.append(task)\n                responses = await asyncio.gather(*tasks)\n        except aiohttp.client_exceptions.ClientResponseError as error:\n            LOGGER.info(\"Rest Api is Unreachable\")\n    \n        LOGGER.info(\"Verifying the responses status\")\n    \n        for response in responses:\n>           batch_id = response['data'][0]['id']\nE           KeyError: 'data'\n\ndep_txns/test_rest_api_dep_txns.py:392: KeyError"}, "teardown": {"duration": 0.0002880096435546875, "outcome": "passed"}}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_rest_api_single_set_dec_txns", "lineno": 421, "outcome": "failed", "keywords": ["run", "TestPostTansactionDependencies", "test_rest_api_single_set_dec_txns", "api_test", "dep_txns/test_rest_api_dep_txns.py", "sixth", "()", "dependent"], "metadata": {"0": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "1": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                                                             \n3. Create third Transaction for decrement with first and second Transaction as dependecies                                                            \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "2": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "3": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "4": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies\n3. Create third Transaction for increment with first and second Transaction as dependecies                                                                                                                \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "5": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single and same  dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "6": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with invalid Transaction as dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "7": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment reverse dependency                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "8": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies                                                                                                          \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This should be an invalid transaction. The third txn will be in PENDING state", "9": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies with different key                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This shoud be an invalid transaction. The trird txn will be in PENDING state", "10": "1. Create first Transaction for set with max value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "11": "1. Create first invalid Transaction for set with negative value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first invalid Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "12": "1. Create first Transaction for set                                                                                                                                                                                                                   \n2. Create second dependent Transaction for increment and make the address invalid with first Transaction as dependency     \n3. Create batch ,post batch and check the response status\n4. The second transaction will be an invalid transaction\n5. Create the third transaction for decrement with first and second as dependency \n6. Create a batch and post batch\nVerify the transaction responses. The first one will be COMMITTED and second one shoud be an invalid transaction. The third txn will be with error code 17 and Validator Timed Out", "13": "1.Create 5 independent Transactions for set\n2.Create second dependent transaction for set with 5 independent transactions as dependency\n3.Create third dependent Transaction for increment with second dependent Transaction as dependency     \n4.Create a batch for all the dependent transaction and post batch\n5.Check for the status\n6.Now create the batch for independent transactions and post batch\n7. Check for the response status of both independent and dependent transactions", "14": "1.Create a dependent transactions for increment\n2.Create a dependent transaction for set for the same key with first transaction as dependent                                                                                                                                                \n3.Create batch and post the first transaction(increment) first and check the response status\n4.Post the second transaction(set)  and check the response status", "15": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, fourth is depend on third and fifth is depend on fourth\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be COMMITTED.", "16": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, \nfourth is depend on third and fifth is depend on fourth. Fourth one will be an invalid txn\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be INVALID.", "17": "1.Create first batch having 3 transactions.\n2.Make third transaction invalid from first  batch.\n3.Create second batch having 2 transactions \n4.Make transaction from second batch dependent on transaction from first batch.\n5.post batch and check for the status.\n6.Create third batch having 2 transaction.\n7.Make transaction from third batch dependent on transaction from second batch.\n8.post batch and check for the status."}, "setup": {"duration": 0.0005424022674560547, "outcome": "passed"}, "call": {"duration": 270.4733636379242, "outcome": "failed", "crash": {"path": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "lineno": 503, "message": "KeyError: 'data'"}, "traceback": [{"path": "dep_txns/test_rest_api_dep_txns.py", "lineno": 503, "message": "KeyError"}], "log": [{"name": "test_rest_api_dep_txns", "msg": "Starting test for batch post", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 429, "funcName": "test_rest_api_single_set_dec_txns", "created": 1552989992.9358692, "msecs": 935.8692169189453, "relativeCreated": 2113793.289899826, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:36:32"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with set operations", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 445, "funcName": "test_rest_api_single_set_dec_txns", "created": 1552989992.9467716, "msecs": 946.7716217041016, "relativeCreated": 2113804.192304611, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:36:32"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with inc operations with dependent transactions as first transaction", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 459, "funcName": "test_rest_api_single_set_dec_txns", "created": 1552989992.9474504, "msecs": 947.4503993988037, "relativeCreated": 2113804.871082306, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:36:32"}, {"name": "test_rest_api_dep_txns", "msg": "Creating batches for transactions 1trn/batch", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 472, "funcName": "test_rest_api_single_set_dec_txns", "created": 1552989992.9477243, "msecs": 947.7243423461914, "relativeCreated": 2113805.1450252533, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:36:32"}, {"name": "test_rest_api_dep_txns", "msg": "Submitting batches to the handlers", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 487, "funcName": "test_rest_api_single_set_dec_txns", "created": 1552989992.9482577, "msecs": 948.2576847076416, "relativeCreated": 2113805.6783676147, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:36:32"}, {"name": "test_rest_api_dep_txns", "msg": "Verifying the responses status", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 498, "funcName": "test_rest_api_single_set_dec_txns", "created": 1552990263.4083238, "msecs": 408.3237648010254, "relativeCreated": 2384265.744447708, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:41:03"}], "longrepr": "self = <test_rest_api_dep_txns.TestPostTansactionDependencies object at 0x7fd599b17da0>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_rest_api_single_set_dec_txns(self, setup):\n        \"\"\"\"1. Create first Transaction for set\n            2. Create second Transaction for decrement with single dependecies\n            3. Create Batch\n            4. Call POST /batches \"\n            Verify the transactions\n        \"\"\"\n        LOGGER.info('Starting test for batch post')\n    \n        signer = get_signer()\n        expected_trxn_ids  = []\n        expected_batch_ids = []\n        address = _get_client_address()\n        url='{}/batches'.format(address)\n        tasks=[]\n        t = datetime.datetime.now()\n        date = t.strftime('%H%M%S')\n        words = random_word_list(100)\n        name=random.choice(words)\n    \n        #name=random.choice('123456734558909877yuyiipp879798788')\n    \n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction_dep(\"set\", [] , name, 50, signer),]\n        for txn in txns:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxn_ids.append(trxn_id)\n    \n    \n        LOGGER.info(\"Creating intkey transactions with inc operations with dependent transactions as first transaction\")\n        trxn_ids = expected_trxn_ids\n        #name=random.choice('123456734558909877')\n        txns.append(create_intkey_transaction_dep(\"dec\",trxn_ids , name, 60, signer))\n        for txn in txns:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxn_ids.append(trxn_id)\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            data = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = data['header_signature']\n            expected_batch_ids.append(batch_id)\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                for batch in post_batch_list:\n                    task = asyncio.ensure_future(async_post_batch(url,session,data=batch))\n                    tasks.append(task)\n                responses = await asyncio.gather(*tasks)\n        except aiohttp.client_exceptions.ClientResponseError as error:\n            LOGGER.info(\"Rest Api is Unreachable\")\n    \n        LOGGER.info(\"Verifying the responses status\")\n    \n        for response in responses:\n            #batch_id = response['data'][0]['id']\n    \n>           if response['data'][0]['status'] == 'COMMITTED':\nE           KeyError: 'data'\n\ndep_txns/test_rest_api_dep_txns.py:503: KeyError"}, "teardown": {"duration": 0.00029206275939941406, "outcome": "passed"}}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_rest_api_set_inc_inc_Txns_Dep", "lineno": 522, "outcome": "failed", "keywords": ["test_rest_api_set_inc_inc_Txns_Dep", "run", "TestPostTansactionDependencies", "api_test", "dep_txns/test_rest_api_dep_txns.py", "sixth", "()", "dependent"], "metadata": {"0": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "1": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                                                             \n3. Create third Transaction for decrement with first and second Transaction as dependecies                                                            \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "2": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "3": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "4": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies\n3. Create third Transaction for increment with first and second Transaction as dependecies                                                                                                                \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "5": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single and same  dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "6": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with invalid Transaction as dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "7": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment reverse dependency                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "8": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies                                                                                                          \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This should be an invalid transaction. The third txn will be in PENDING state", "9": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies with different key                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This shoud be an invalid transaction. The trird txn will be in PENDING state", "10": "1. Create first Transaction for set with max value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "11": "1. Create first invalid Transaction for set with negative value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first invalid Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "12": "1. Create first Transaction for set                                                                                                                                                                                                                   \n2. Create second dependent Transaction for increment and make the address invalid with first Transaction as dependency     \n3. Create batch ,post batch and check the response status\n4. The second transaction will be an invalid transaction\n5. Create the third transaction for decrement with first and second as dependency \n6. Create a batch and post batch\nVerify the transaction responses. The first one will be COMMITTED and second one shoud be an invalid transaction. The third txn will be with error code 17 and Validator Timed Out", "13": "1.Create 5 independent Transactions for set\n2.Create second dependent transaction for set with 5 independent transactions as dependency\n3.Create third dependent Transaction for increment with second dependent Transaction as dependency     \n4.Create a batch for all the dependent transaction and post batch\n5.Check for the status\n6.Now create the batch for independent transactions and post batch\n7. Check for the response status of both independent and dependent transactions", "14": "1.Create a dependent transactions for increment\n2.Create a dependent transaction for set for the same key with first transaction as dependent                                                                                                                                                \n3.Create batch and post the first transaction(increment) first and check the response status\n4.Post the second transaction(set)  and check the response status", "15": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, fourth is depend on third and fifth is depend on fourth\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be COMMITTED.", "16": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, \nfourth is depend on third and fifth is depend on fourth. Fourth one will be an invalid txn\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be INVALID.", "17": "1.Create first batch having 3 transactions.\n2.Make third transaction invalid from first  batch.\n3.Create second batch having 2 transactions \n4.Make transaction from second batch dependent on transaction from first batch.\n5.post batch and check for the status.\n6.Create third batch having 2 transaction.\n7.Make transaction from third batch dependent on transaction from second batch.\n8.post batch and check for the status."}, "setup": {"duration": 0.0005645751953125, "outcome": "passed"}, "call": {"duration": 144.29517316818237, "outcome": "failed", "crash": {"path": "/usr/lib/python3/dist-packages/aiohttp/streams.py", "lineno": 533, "message": "aiohttp.client_exceptions.ServerDisconnectedError: None"}, "traceback": [{"path": "dep_txns/test_rest_api_dep_txns.py", "lineno": 601, "message": ""}, {"path": "dep_txns/test_rest_api_dep_txns.py", "lineno": 69, "message": "in async_post_batch"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 779, "message": "in __aenter__"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 331, "message": "in _request"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client_reqrep.py", "lineno": 678, "message": "in start"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/streams.py", "lineno": 533, "message": "ServerDisconnectedError"}], "log": [{"name": "test_rest_api_dep_txns", "msg": "Starting test for batch post", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 531, "funcName": "test_rest_api_set_inc_inc_Txns_Dep", "created": 1552990263.4358292, "msecs": 435.82916259765625, "relativeCreated": 2384293.2498455048, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:41:03"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with set operations", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 541, "funcName": "test_rest_api_set_inc_inc_Txns_Dep", "created": 1552990263.438334, "msecs": 438.33398818969727, "relativeCreated": 2384295.754671097, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:41:03"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with inc operations with dependent transactions as first transaction", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 555, "funcName": "test_rest_api_set_inc_inc_Txns_Dep", "created": 1552990263.4390283, "msecs": 439.028263092041, "relativeCreated": 2384296.448945999, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:41:03"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with inc operations with dependent transactions as second transaction", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 567, "funcName": "test_rest_api_set_inc_inc_Txns_Dep", "created": 1552990263.4393027, "msecs": 439.3026828765869, "relativeCreated": 2384296.7233657837, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:41:03"}, {"name": "test_rest_api_dep_txns", "msg": "Creating batches for transactions 1trn/batch", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 579, "funcName": "test_rest_api_set_inc_inc_Txns_Dep", "created": 1552990263.439563, "msecs": 439.5630359649658, "relativeCreated": 2384296.983718872, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:41:03"}, {"name": "test_rest_api_dep_txns", "msg": "Submitting batches to the handlers", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 594, "funcName": "test_rest_api_set_inc_inc_Txns_Dep", "created": 1552990263.440276, "msecs": 440.2759075164795, "relativeCreated": 2384297.6965904236, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:41:03"}], "longrepr": "self = <test_rest_api_dep_txns.TestPostTansactionDependencies object at 0x7fd599b17b38>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_rest_api_set_inc_inc_Txns_Dep(self, setup):\n        \"\"\"1. Create first Transaction for set\n        2. Create second Transaction for increment with first Transaction as dependecies\n        3. Create third Transaction for increment with first and second Transaction as dependecies\n        4. Create Batch\n        5. Call POST /batches\n        Verify the transactions\n        \"\"\"\n        LOGGER.info('Starting test for batch post')\n    \n        signer = get_signer()\n        expected_trxn_ids  = []\n        expected_batch_ids = []\n        address = _get_client_address()\n        url='{}/batches'.format(address)\n        tasks=[]\n        name = random.choice(\"abcdefghijklmnopqrstuv\")\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction_dep(\"set\", [] , name, 50, signer),]\n        for txn in txns:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxn_ids.append(trxn_id)\n    \n    \n        LOGGER.info(\"Creating intkey transactions with inc operations with dependent transactions as first transaction\")\n        trxn_ids = expected_trxn_ids\n        txns.append(create_intkey_transaction_dep(\"inc\", trxn_ids , name, 20, signer))\n        for txn in txns:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxn_ids.append(trxn_id)\n    \n        LOGGER.info(\"Creating intkey transactions with inc operations with dependent transactions as second transaction\")\n        trxn_ids = list(set(expected_trxn_ids))\n        txns.append(create_intkey_transaction_dep(\"inc\", trxn_ids , name, 50, signer))\n        for txn in txns:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxn_ids.append(trxn_id)\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            data = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = data['header_signature']\n            expected_batch_ids.append(batch_id)\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                for batch in post_batch_list:\n                    task = asyncio.ensure_future(async_post_batch(url,session,data=batch))\n                    tasks.append(task)\n>               responses = await asyncio.gather(*tasks)\n\ndep_txns/test_rest_api_dep_txns.py:601: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ndep_txns/test_rest_api_dep_txns.py:69: in async_post_batch\n    async with session.post(url,data=data,headers=headers) as response:\n/usr/lib/python3/dist-packages/aiohttp/client.py:779: in __aenter__\n    self._resp = await self._coro\n/usr/lib/python3/dist-packages/aiohttp/client.py:331: in _request\n    await resp.start(conn, read_until_eof)\n/usr/lib/python3/dist-packages/aiohttp/client_reqrep.py:678: in start\n    (message, payload) = await self._protocol.read()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <aiohttp.client_proto.ResponseHandler object at 0x7fd599b145f8>\n\n    async def read(self):\n        if not self._buffer and not self._eof:\n            assert not self._waiter\n            self._waiter = self._loop.create_future()\n            try:\n>               await self._waiter\nE               aiohttp.client_exceptions.ServerDisconnectedError: None\n\n/usr/lib/python3/dist-packages/aiohttp/streams.py:533: ServerDisconnectedError"}, "teardown": {"duration": 0.00046706199645996094, "outcome": "passed"}}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_rest_api_single_set_dec_same_txns", "lineno": 632, "outcome": "failed", "keywords": ["run", "test_rest_api_single_set_dec_same_txns", "TestPostTansactionDependencies", "api_test", "dep_txns/test_rest_api_dep_txns.py", "sixth", "()", "dependent"], "metadata": {"0": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "1": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                                                             \n3. Create third Transaction for decrement with first and second Transaction as dependecies                                                            \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "2": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "3": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "4": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies\n3. Create third Transaction for increment with first and second Transaction as dependecies                                                                                                                \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "5": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single and same  dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "6": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with invalid Transaction as dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "7": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment reverse dependency                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "8": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies                                                                                                          \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This should be an invalid transaction. The third txn will be in PENDING state", "9": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies with different key                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This shoud be an invalid transaction. The trird txn will be in PENDING state", "10": "1. Create first Transaction for set with max value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "11": "1. Create first invalid Transaction for set with negative value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first invalid Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "12": "1. Create first Transaction for set                                                                                                                                                                                                                   \n2. Create second dependent Transaction for increment and make the address invalid with first Transaction as dependency     \n3. Create batch ,post batch and check the response status\n4. The second transaction will be an invalid transaction\n5. Create the third transaction for decrement with first and second as dependency \n6. Create a batch and post batch\nVerify the transaction responses. The first one will be COMMITTED and second one shoud be an invalid transaction. The third txn will be with error code 17 and Validator Timed Out", "13": "1.Create 5 independent Transactions for set\n2.Create second dependent transaction for set with 5 independent transactions as dependency\n3.Create third dependent Transaction for increment with second dependent Transaction as dependency     \n4.Create a batch for all the dependent transaction and post batch\n5.Check for the status\n6.Now create the batch for independent transactions and post batch\n7. Check for the response status of both independent and dependent transactions", "14": "1.Create a dependent transactions for increment\n2.Create a dependent transaction for set for the same key with first transaction as dependent                                                                                                                                                \n3.Create batch and post the first transaction(increment) first and check the response status\n4.Post the second transaction(set)  and check the response status", "15": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, fourth is depend on third and fifth is depend on fourth\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be COMMITTED.", "16": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, \nfourth is depend on third and fifth is depend on fourth. Fourth one will be an invalid txn\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be INVALID.", "17": "1.Create first batch having 3 transactions.\n2.Make third transaction invalid from first  batch.\n3.Create second batch having 2 transactions \n4.Make transaction from second batch dependent on transaction from first batch.\n5.post batch and check for the status.\n6.Create third batch having 2 transaction.\n7.Make transaction from third batch dependent on transaction from second batch.\n8.post batch and check for the status."}, "setup": {"duration": 0.0009946823120117188, "outcome": "passed"}, "call": {"duration": 0.01685786247253418, "outcome": "failed", "crash": {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]"}, "traceback": [{"path": "dep_txns/test_rest_api_dep_txns.py", "lineno": 705, "message": ""}, {"path": "dep_txns/test_rest_api_dep_txns.py", "lineno": 69, "message": "in async_post_batch"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 779, "message": "in __aenter__"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 319, "message": "in _request"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 418, "message": "in connect"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 736, "message": "in _create_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 855, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 838, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "ClientConnectorError"}], "log": [{"name": "test_rest_api_dep_txns", "msg": "Starting test for batch post", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 640, "funcName": "test_rest_api_single_set_dec_same_txns", "created": 1552990407.833853, "msecs": 833.853006362915, "relativeCreated": 2528691.27368927, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:27"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with set operations", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 656, "funcName": "test_rest_api_single_set_dec_same_txns", "created": 1552990407.846786, "msecs": 846.7860221862793, "relativeCreated": 2528704.2067050934, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:27"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with inc operations with dependent transactions as first transaction", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 670, "funcName": "test_rest_api_single_set_dec_same_txns", "created": 1552990407.8474693, "msecs": 847.4693298339844, "relativeCreated": 2528704.890012741, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:27"}, {"name": "test_rest_api_dep_txns", "msg": "Creating batches for transactions 1trn/batch", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 683, "funcName": "test_rest_api_single_set_dec_same_txns", "created": 1552990407.8477523, "msecs": 847.7523326873779, "relativeCreated": 2528705.1730155945, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:27"}, {"name": "test_rest_api_dep_txns", "msg": "Submitting batches to the handlers", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 698, "funcName": "test_rest_api_single_set_dec_same_txns", "created": 1552990407.8482916, "msecs": 848.2916355133057, "relativeCreated": 2528705.7123184204, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:27"}], "longrepr": "self = <aiohttp.connector.TCPConnector object at 0x7fd599902f60>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd599902048>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n>           return await self._loop.create_connection(*args, **kwargs)\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:800: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n                    yield from self.sock_connect(sock, address)\n                except OSError as exc:\n                    if sock is not None:\n                        sock.close()\n                    exceptions.append(exc)\n                except:\n                    if sock is not None:\n                        sock.close()\n                    raise\n                else:\n                    break\n            else:\n                if len(exceptions) == 1:\n>                   raise exceptions[0]\n\n/usr/lib/python3.6/asyncio/base_events.py:783: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n>                   yield from self.sock_connect(sock, address)\n\n/usr/lib/python3.6/asyncio/base_events.py:770: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>, sock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>\naddress = ('192.168.1.23', 8008)\n\n    @coroutine\n    def sock_connect(self, sock, address):\n        \"\"\"Connect to a remote socket at address.\n    \n        This method is a coroutine.\n        \"\"\"\n        if self._debug and sock.gettimeout() != 0:\n            raise ValueError(\"the socket must be non-blocking\")\n    \n        if not hasattr(socket, 'AF_UNIX') or sock.family != socket.AF_UNIX:\n            resolved = base_events._ensure_resolved(\n                address, family=sock.family, proto=sock.proto, loop=self)\n            if not resolved.done():\n                yield from resolved\n            _, _, _, _, address = resolved.result()[0]\n    \n        fut = self.create_future()\n        self._sock_connect(fut, sock, address)\n>       return (yield from fut)\n\n/usr/lib/python3.6/asyncio/selector_events.py:450: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nfut = <Future finished exception=ConnectionRefusedError(111, \"Connect call failed ('192.168.1.23', 8008)\")>\nsock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>, address = ('192.168.1.23', 8008)\n\n    def _sock_connect_cb(self, fut, sock, address):\n        if fut.cancelled():\n            return\n    \n        try:\n            err = sock.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)\n            if err != 0:\n                # Jump to any except clause below.\n>               raise OSError(err, 'Connect call failed %s' % (address,))\nE               ConnectionRefusedError: [Errno 111] Connect call failed ('192.168.1.23', 8008)\n\n/usr/lib/python3.6/asyncio/selector_events.py:480: ConnectionRefusedError\n\nThe above exception was the direct cause of the following exception:\n\nself = <test_rest_api_dep_txns.TestPostTansactionDependencies object at 0x7fd599aae588>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_rest_api_single_set_dec_same_txns(self, setup):\n        \"\"\"\"1. Create first Transaction for set\n            2. Create second Transaction for decrement with single and same  dependencies\n            3. Create Batch\n            4. Call POST /batches \"\n            Verify the transactions\n        \"\"\"\n        LOGGER.info('Starting test for batch post')\n    \n        signer = get_signer()\n        expected_trxn_ids  = []\n        expected_batch_ids = []\n        address = _get_client_address()\n        url='{}/batches'.format(address)\n        tasks=[]\n        t = datetime.datetime.now()\n        date = t.strftime('%H%M%S')\n        words = random_word_list(100)\n        name=random.choice(words)\n    \n        #name=random.choice('123456734558909877yuyiipp879798788')\n    \n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction_dep(\"set\", [] , name, 50, signer),]\n        for txn in txns:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxn_ids.append(trxn_id)\n    \n    \n        LOGGER.info(\"Creating intkey transactions with inc operations with dependent transactions as first transaction\")\n        trxn_ids = expected_trxn_ids\n        #name=random.choice('123456734558909877')\n        txns.append(create_intkey_transaction_dep(\"dec\",trxn_ids , name, 50, signer))\n        for txn in txns:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxn_ids.append(trxn_id)\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            data = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = data['header_signature']\n            expected_batch_ids.append(batch_id)\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                for batch in post_batch_list:\n                    task = asyncio.ensure_future(async_post_batch(url,session,data=batch))\n                    tasks.append(task)\n>               responses = await asyncio.gather(*tasks)\n\ndep_txns/test_rest_api_dep_txns.py:705: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ndep_txns/test_rest_api_dep_txns.py:69: in async_post_batch\n    async with session.post(url,data=data,headers=headers) as response:\n/usr/lib/python3/dist-packages/aiohttp/client.py:779: in __aenter__\n    self._resp = await self._coro\n/usr/lib/python3/dist-packages/aiohttp/client.py:319: in _request\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:418: in connect\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:736: in _create_connection\n    traces=None\n/usr/lib/python3/dist-packages/aiohttp/connector.py:855: in _create_direct_connection\n    raise last_exc\n/usr/lib/python3/dist-packages/aiohttp/connector.py:838: in _create_direct_connection\n    req=req, client_error=client_error)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <aiohttp.connector.TCPConnector object at 0x7fd599902f60>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd599902048>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n            return await self._loop.create_connection(*args, **kwargs)\n        except certificate_errors as exc:\n            raise ClientConnectorCertificateError(\n                req.connection_key, exc) from exc\n        except ssl_errors as exc:\n            raise ClientConnectorSSLError(req.connection_key, exc) from exc\n        except OSError as exc:\n>           raise client_error(req.connection_key, exc) from exc\nE           aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:807: ClientConnectorError"}, "teardown": {"duration": 0.0004935264587402344, "outcome": "passed"}}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_rest_api_single_set_dec_invalid_txns_id", "lineno": 741, "outcome": "failed", "keywords": ["run", "TestPostTansactionDependencies", "api_test", "dep_txns/test_rest_api_dep_txns.py", "test_rest_api_single_set_dec_invalid_txns_id", "sixth", "()", "dependent"], "metadata": {"0": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "1": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                                                             \n3. Create third Transaction for decrement with first and second Transaction as dependecies                                                            \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "2": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "3": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "4": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies\n3. Create third Transaction for increment with first and second Transaction as dependecies                                                                                                                \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "5": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single and same  dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "6": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with invalid Transaction as dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "7": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment reverse dependency                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "8": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies                                                                                                          \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This should be an invalid transaction. The third txn will be in PENDING state", "9": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies with different key                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This shoud be an invalid transaction. The trird txn will be in PENDING state", "10": "1. Create first Transaction for set with max value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "11": "1. Create first invalid Transaction for set with negative value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first invalid Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "12": "1. Create first Transaction for set                                                                                                                                                                                                                   \n2. Create second dependent Transaction for increment and make the address invalid with first Transaction as dependency     \n3. Create batch ,post batch and check the response status\n4. The second transaction will be an invalid transaction\n5. Create the third transaction for decrement with first and second as dependency \n6. Create a batch and post batch\nVerify the transaction responses. The first one will be COMMITTED and second one shoud be an invalid transaction. The third txn will be with error code 17 and Validator Timed Out", "13": "1.Create 5 independent Transactions for set\n2.Create second dependent transaction for set with 5 independent transactions as dependency\n3.Create third dependent Transaction for increment with second dependent Transaction as dependency     \n4.Create a batch for all the dependent transaction and post batch\n5.Check for the status\n6.Now create the batch for independent transactions and post batch\n7. Check for the response status of both independent and dependent transactions", "14": "1.Create a dependent transactions for increment\n2.Create a dependent transaction for set for the same key with first transaction as dependent                                                                                                                                                \n3.Create batch and post the first transaction(increment) first and check the response status\n4.Post the second transaction(set)  and check the response status", "15": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, fourth is depend on third and fifth is depend on fourth\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be COMMITTED.", "16": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, \nfourth is depend on third and fifth is depend on fourth. Fourth one will be an invalid txn\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be INVALID.", "17": "1.Create first batch having 3 transactions.\n2.Make third transaction invalid from first  batch.\n3.Create second batch having 2 transactions \n4.Make transaction from second batch dependent on transaction from first batch.\n5.post batch and check for the status.\n6.Create third batch having 2 transaction.\n7.Make transaction from third batch dependent on transaction from second batch.\n8.post batch and check for the status."}, "setup": {"duration": 0.0005903244018554688, "outcome": "passed"}, "call": {"duration": 0.014443397521972656, "outcome": "failed", "crash": {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]"}, "traceback": [{"path": "dep_txns/test_rest_api_dep_txns.py", "lineno": 814, "message": ""}, {"path": "dep_txns/test_rest_api_dep_txns.py", "lineno": 69, "message": "in async_post_batch"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 779, "message": "in __aenter__"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 319, "message": "in _request"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 418, "message": "in connect"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 736, "message": "in _create_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 855, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 838, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "ClientConnectorError"}], "log": [{"name": "test_rest_api_dep_txns", "msg": "Starting test for batch post", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 749, "funcName": "test_rest_api_single_set_dec_invalid_txns_id", "created": 1552990408.0109456, "msecs": 10.945558547973633, "relativeCreated": 2528868.366241455, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with set operations", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 765, "funcName": "test_rest_api_single_set_dec_invalid_txns_id", "created": 1552990408.021655, "msecs": 21.65508270263672, "relativeCreated": 2528879.0757656097, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with inc operations with dependent transactions as first transaction", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 779, "funcName": "test_rest_api_single_set_dec_invalid_txns_id", "created": 1552990408.0223544, "msecs": 22.3543643951416, "relativeCreated": 2528879.7750473022, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Creating batches for transactions 1trn/batch", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 792, "funcName": "test_rest_api_single_set_dec_invalid_txns_id", "created": 1552990408.022637, "msecs": 22.636890411376953, "relativeCreated": 2528880.0575733185, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Submitting batches to the handlers", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 807, "funcName": "test_rest_api_single_set_dec_invalid_txns_id", "created": 1552990408.0231755, "msecs": 23.175477981567383, "relativeCreated": 2528880.5961608887, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}], "longrepr": "self = <aiohttp.connector.TCPConnector object at 0x7fd5998b61d0>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd5998b6ac8>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n>           return await self._loop.create_connection(*args, **kwargs)\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:800: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n                    yield from self.sock_connect(sock, address)\n                except OSError as exc:\n                    if sock is not None:\n                        sock.close()\n                    exceptions.append(exc)\n                except:\n                    if sock is not None:\n                        sock.close()\n                    raise\n                else:\n                    break\n            else:\n                if len(exceptions) == 1:\n>                   raise exceptions[0]\n\n/usr/lib/python3.6/asyncio/base_events.py:783: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n>                   yield from self.sock_connect(sock, address)\n\n/usr/lib/python3.6/asyncio/base_events.py:770: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>, sock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>\naddress = ('192.168.1.23', 8008)\n\n    @coroutine\n    def sock_connect(self, sock, address):\n        \"\"\"Connect to a remote socket at address.\n    \n        This method is a coroutine.\n        \"\"\"\n        if self._debug and sock.gettimeout() != 0:\n            raise ValueError(\"the socket must be non-blocking\")\n    \n        if not hasattr(socket, 'AF_UNIX') or sock.family != socket.AF_UNIX:\n            resolved = base_events._ensure_resolved(\n                address, family=sock.family, proto=sock.proto, loop=self)\n            if not resolved.done():\n                yield from resolved\n            _, _, _, _, address = resolved.result()[0]\n    \n        fut = self.create_future()\n        self._sock_connect(fut, sock, address)\n>       return (yield from fut)\n\n/usr/lib/python3.6/asyncio/selector_events.py:450: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nfut = <Future finished exception=ConnectionRefusedError(111, \"Connect call failed ('192.168.1.23', 8008)\")>\nsock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>, address = ('192.168.1.23', 8008)\n\n    def _sock_connect_cb(self, fut, sock, address):\n        if fut.cancelled():\n            return\n    \n        try:\n            err = sock.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)\n            if err != 0:\n                # Jump to any except clause below.\n>               raise OSError(err, 'Connect call failed %s' % (address,))\nE               ConnectionRefusedError: [Errno 111] Connect call failed ('192.168.1.23', 8008)\n\n/usr/lib/python3.6/asyncio/selector_events.py:480: ConnectionRefusedError\n\nThe above exception was the direct cause of the following exception:\n\nself = <test_rest_api_dep_txns.TestPostTansactionDependencies object at 0x7fd59979cef0>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_rest_api_single_set_dec_invalid_txns_id(self, setup):\n        \"\"\"\"1. Create first Transaction for set\n            2. Create second Transaction for decrement with invalid Transaction as dependencies\n            3. Create Batch\n            4. Call POST /batches \"\n            Verify the transactions\n        \"\"\"\n        LOGGER.info('Starting test for batch post')\n    \n        signer = get_signer()\n        expected_trxn_ids  = []\n        expected_batch_ids = []\n        address = _get_client_address()\n        url='{}/batches'.format(address)\n        tasks=[]\n        t = datetime.datetime.now()\n        date = t.strftime('%H%M%S')\n        words = random_word_list(100)\n        name=random.choice(words)\n    \n        #name=random.choice('123456734558909877yuyiipp879798788')\n    \n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction_dep(\"set\", [] , name, 50, signer),]\n        for txn in txns:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxn_ids.append(trxn_id)\n    \n    \n        LOGGER.info(\"Creating intkey transactions with inc operations with dependent transactions as first transaction\")\n        trxn_ids = expected_trxn_ids\n        #name=random.choice('123456734558909877')\n        txns.append(create_intkey_transaction_dep(\"dec\",[u'bbbbbb'] , name, 50, signer))\n        for txn in txns:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxn_ids.append(trxn_id)\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            data = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = data['header_signature']\n            expected_batch_ids.append(batch_id)\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                for batch in post_batch_list:\n                    task = asyncio.ensure_future(async_post_batch(url,session,data=batch))\n                    tasks.append(task)\n>               responses = await asyncio.gather(*tasks)\n\ndep_txns/test_rest_api_dep_txns.py:814: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ndep_txns/test_rest_api_dep_txns.py:69: in async_post_batch\n    async with session.post(url,data=data,headers=headers) as response:\n/usr/lib/python3/dist-packages/aiohttp/client.py:779: in __aenter__\n    self._resp = await self._coro\n/usr/lib/python3/dist-packages/aiohttp/client.py:319: in _request\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:418: in connect\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:736: in _create_connection\n    traces=None\n/usr/lib/python3/dist-packages/aiohttp/connector.py:855: in _create_direct_connection\n    raise last_exc\n/usr/lib/python3/dist-packages/aiohttp/connector.py:838: in _create_direct_connection\n    req=req, client_error=client_error)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <aiohttp.connector.TCPConnector object at 0x7fd5998b61d0>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd5998b6ac8>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n            return await self._loop.create_connection(*args, **kwargs)\n        except certificate_errors as exc:\n            raise ClientConnectorCertificateError(\n                req.connection_key, exc) from exc\n        except ssl_errors as exc:\n            raise ClientConnectorSSLError(req.connection_key, exc) from exc\n        except OSError as exc:\n>           raise client_error(req.connection_key, exc) from exc\nE           aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:807: ClientConnectorError"}, "teardown": {"duration": 0.00027680397033691406, "outcome": "passed"}}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_single_set_dep_reverse", "lineno": 849, "outcome": "failed", "keywords": ["run", "TestPostTansactionDependencies", "api_test", "dep_txns/test_rest_api_dep_txns.py", "sixth", "test_single_set_dep_reverse", "()", "dependent"], "metadata": {"0": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "1": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                                                             \n3. Create third Transaction for decrement with first and second Transaction as dependecies                                                            \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "2": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "3": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "4": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies\n3. Create third Transaction for increment with first and second Transaction as dependecies                                                                                                                \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "5": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single and same  dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "6": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with invalid Transaction as dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "7": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment reverse dependency                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "8": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies                                                                                                          \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This should be an invalid transaction. The third txn will be in PENDING state", "9": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies with different key                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This shoud be an invalid transaction. The trird txn will be in PENDING state", "10": "1. Create first Transaction for set with max value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "11": "1. Create first invalid Transaction for set with negative value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first invalid Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "12": "1. Create first Transaction for set                                                                                                                                                                                                                   \n2. Create second dependent Transaction for increment and make the address invalid with first Transaction as dependency     \n3. Create batch ,post batch and check the response status\n4. The second transaction will be an invalid transaction\n5. Create the third transaction for decrement with first and second as dependency \n6. Create a batch and post batch\nVerify the transaction responses. The first one will be COMMITTED and second one shoud be an invalid transaction. The third txn will be with error code 17 and Validator Timed Out", "13": "1.Create 5 independent Transactions for set\n2.Create second dependent transaction for set with 5 independent transactions as dependency\n3.Create third dependent Transaction for increment with second dependent Transaction as dependency     \n4.Create a batch for all the dependent transaction and post batch\n5.Check for the status\n6.Now create the batch for independent transactions and post batch\n7. Check for the response status of both independent and dependent transactions", "14": "1.Create a dependent transactions for increment\n2.Create a dependent transaction for set for the same key with first transaction as dependent                                                                                                                                                \n3.Create batch and post the first transaction(increment) first and check the response status\n4.Post the second transaction(set)  and check the response status", "15": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, fourth is depend on third and fifth is depend on fourth\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be COMMITTED.", "16": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, \nfourth is depend on third and fifth is depend on fourth. Fourth one will be an invalid txn\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be INVALID.", "17": "1.Create first batch having 3 transactions.\n2.Make third transaction invalid from first  batch.\n3.Create second batch having 2 transactions \n4.Make transaction from second batch dependent on transaction from first batch.\n5.post batch and check for the status.\n6.Create third batch having 2 transaction.\n7.Make transaction from third batch dependent on transaction from second batch.\n8.post batch and check for the status."}, "setup": {"duration": 0.0005381107330322266, "outcome": "passed"}, "call": {"duration": 0.021382570266723633, "outcome": "failed", "crash": {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]"}, "traceback": [{"path": "dep_txns/test_rest_api_dep_txns.py", "lineno": 923, "message": ""}, {"path": "dep_txns/test_rest_api_dep_txns.py", "lineno": 69, "message": "in async_post_batch"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 779, "message": "in __aenter__"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 319, "message": "in _request"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 418, "message": "in connect"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 736, "message": "in _create_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 855, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 838, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "ClientConnectorError"}], "log": [{"name": "test_rest_api_dep_txns", "msg": "Starting test for batch post", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 857, "funcName": "test_single_set_dep_reverse", "created": 1552990408.1789827, "msecs": 178.98273468017578, "relativeCreated": 2529036.4034175873, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with set operations", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 873, "funcName": "test_single_set_dep_reverse", "created": 1552990408.1898453, "msecs": 189.84532356262207, "relativeCreated": 2529047.2660064697, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with inc operations with dependent transactions as first transaction", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 887, "funcName": "test_single_set_dep_reverse", "created": 1552990408.1905444, "msecs": 190.54436683654785, "relativeCreated": 2529047.9650497437, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Creating batches for transactions 1trn/batch", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 902, "funcName": "test_single_set_dep_reverse", "created": 1552990408.197921, "msecs": 197.9210376739502, "relativeCreated": 2529055.341720581, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Submitting batches to the handlers", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 917, "funcName": "test_single_set_dep_reverse", "created": 1552990408.1985404, "msecs": 198.54044914245605, "relativeCreated": 2529055.9611320496, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}], "longrepr": "self = <aiohttp.connector.TCPConnector object at 0x7fd599794358>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd599794710>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n>           return await self._loop.create_connection(*args, **kwargs)\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:800: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n                    yield from self.sock_connect(sock, address)\n                except OSError as exc:\n                    if sock is not None:\n                        sock.close()\n                    exceptions.append(exc)\n                except:\n                    if sock is not None:\n                        sock.close()\n                    raise\n                else:\n                    break\n            else:\n                if len(exceptions) == 1:\n>                   raise exceptions[0]\n\n/usr/lib/python3.6/asyncio/base_events.py:783: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n>                   yield from self.sock_connect(sock, address)\n\n/usr/lib/python3.6/asyncio/base_events.py:770: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>, sock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>\naddress = ('192.168.1.23', 8008)\n\n    @coroutine\n    def sock_connect(self, sock, address):\n        \"\"\"Connect to a remote socket at address.\n    \n        This method is a coroutine.\n        \"\"\"\n        if self._debug and sock.gettimeout() != 0:\n            raise ValueError(\"the socket must be non-blocking\")\n    \n        if not hasattr(socket, 'AF_UNIX') or sock.family != socket.AF_UNIX:\n            resolved = base_events._ensure_resolved(\n                address, family=sock.family, proto=sock.proto, loop=self)\n            if not resolved.done():\n                yield from resolved\n            _, _, _, _, address = resolved.result()[0]\n    \n        fut = self.create_future()\n        self._sock_connect(fut, sock, address)\n>       return (yield from fut)\n\n/usr/lib/python3.6/asyncio/selector_events.py:450: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nfut = <Future finished exception=ConnectionRefusedError(111, \"Connect call failed ('192.168.1.23', 8008)\")>\nsock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>, address = ('192.168.1.23', 8008)\n\n    def _sock_connect_cb(self, fut, sock, address):\n        if fut.cancelled():\n            return\n    \n        try:\n            err = sock.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)\n            if err != 0:\n                # Jump to any except clause below.\n>               raise OSError(err, 'Connect call failed %s' % (address,))\nE               ConnectionRefusedError: [Errno 111] Connect call failed ('192.168.1.23', 8008)\n\n/usr/lib/python3.6/asyncio/selector_events.py:480: ConnectionRefusedError\n\nThe above exception was the direct cause of the following exception:\n\nself = <test_rest_api_dep_txns.TestPostTansactionDependencies object at 0x7fd599b0c550>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_single_set_dep_reverse(self, setup):\n         \"\"\"\"1. Create first Transaction for set\n             2. Create second Transaction for increment reverse dependency\n             3. Create Batch\n             4. Call POST /batches \"\n             Verify the transactions\n         \"\"\"\n         LOGGER.info('Starting test for batch post')\n    \n         signer = get_signer()\n         expected_trxn_ids  = []\n         expected_batch_ids = []\n         address = _get_client_address()\n         url='{}/batches'.format(address)\n         tasks=[]\n         t = datetime.datetime.now()\n         date = t.strftime('%H%M%S')\n         words = random_word_list(100)\n         name=random.choice(words)\n    \n         #name=random.choice('123456734558909877')\n    \n    \n         LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n         txns = [\n             create_intkey_transaction_dep(\"set\", [] , name, 5, signer),]\n         for txn in txns:\n             data = MessageToDict(\n                     txn,\n                     including_default_value_fields=True,\n                     preserving_proto_field_name=True)\n    \n             trxn_id = data['header_signature']\n             expected_trxn_ids.append(trxn_id)\n    \n    \n         LOGGER.info(\"Creating intkey transactions with inc operations with dependent transactions as first transaction\")\n         trxn_ids = expected_trxn_ids\n         words = random_word_list(100)\n         name=random.choice(words)\n         #name=random.choice('123456734558909877')\n         txns.append(create_intkey_transaction_dep(\"set\",trxn_ids, name, 2, signer))\n         for txn in txns:\n             data = MessageToDict(\n                     txn,\n                     including_default_value_fields=True,\n                     preserving_proto_field_name=True)\n    \n             trxn_id = data['header_signature']\n             expected_trxn_ids.append(trxn_id)\n    \n         LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n         batches = [create_batch([txn], signer) for txn in txns[::-1]]\n    \n         for batch in batches:\n             data = MessageToDict(\n                     batch,\n                     including_default_value_fields=True,\n                     preserving_proto_field_name=True)\n    \n             batch_id = data['header_signature']\n             expected_batch_ids.append(batch_id)\n    \n         post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n         LOGGER.info(\"Submitting batches to the handlers\")\n    \n         try:\n             async with aiohttp.ClientSession() as session:\n                 for batch in post_batch_list:\n                     task = asyncio.ensure_future(async_post_batch(url,session,data=batch))\n>                    response = await asyncio.gather(task)\n\ndep_txns/test_rest_api_dep_txns.py:923: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ndep_txns/test_rest_api_dep_txns.py:69: in async_post_batch\n    async with session.post(url,data=data,headers=headers) as response:\n/usr/lib/python3/dist-packages/aiohttp/client.py:779: in __aenter__\n    self._resp = await self._coro\n/usr/lib/python3/dist-packages/aiohttp/client.py:319: in _request\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:418: in connect\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:736: in _create_connection\n    traces=None\n/usr/lib/python3/dist-packages/aiohttp/connector.py:855: in _create_direct_connection\n    raise last_exc\n/usr/lib/python3/dist-packages/aiohttp/connector.py:838: in _create_direct_connection\n    req=req, client_error=client_error)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <aiohttp.connector.TCPConnector object at 0x7fd599794358>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd599794710>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n            return await self._loop.create_connection(*args, **kwargs)\n        except certificate_errors as exc:\n            raise ClientConnectorCertificateError(\n                req.connection_key, exc) from exc\n        except ssl_errors as exc:\n            raise ClientConnectorSSLError(req.connection_key, exc) from exc\n        except OSError as exc:\n>           raise client_error(req.connection_key, exc) from exc\nE           aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:807: ClientConnectorError"}, "teardown": {"duration": 0.00030541419982910156, "outcome": "passed"}}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_valid_set_invalid_inc_txn_dep", "lineno": 955, "outcome": "failed", "keywords": ["run", "TestPostTansactionDependencies", "api_test", "test_valid_set_invalid_inc_txn_dep", "dep_txns/test_rest_api_dep_txns.py", "sixth", "()", "dependent"], "metadata": {"0": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "1": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                                                             \n3. Create third Transaction for decrement with first and second Transaction as dependecies                                                            \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "2": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "3": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "4": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies\n3. Create third Transaction for increment with first and second Transaction as dependecies                                                                                                                \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "5": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single and same  dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "6": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with invalid Transaction as dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "7": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment reverse dependency                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "8": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies                                                                                                          \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This should be an invalid transaction. The third txn will be in PENDING state", "9": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies with different key                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This shoud be an invalid transaction. The trird txn will be in PENDING state", "10": "1. Create first Transaction for set with max value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "11": "1. Create first invalid Transaction for set with negative value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first invalid Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "12": "1. Create first Transaction for set                                                                                                                                                                                                                   \n2. Create second dependent Transaction for increment and make the address invalid with first Transaction as dependency     \n3. Create batch ,post batch and check the response status\n4. The second transaction will be an invalid transaction\n5. Create the third transaction for decrement with first and second as dependency \n6. Create a batch and post batch\nVerify the transaction responses. The first one will be COMMITTED and second one shoud be an invalid transaction. The third txn will be with error code 17 and Validator Timed Out", "13": "1.Create 5 independent Transactions for set\n2.Create second dependent transaction for set with 5 independent transactions as dependency\n3.Create third dependent Transaction for increment with second dependent Transaction as dependency     \n4.Create a batch for all the dependent transaction and post batch\n5.Check for the status\n6.Now create the batch for independent transactions and post batch\n7. Check for the response status of both independent and dependent transactions", "14": "1.Create a dependent transactions for increment\n2.Create a dependent transaction for set for the same key with first transaction as dependent                                                                                                                                                \n3.Create batch and post the first transaction(increment) first and check the response status\n4.Post the second transaction(set)  and check the response status", "15": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, fourth is depend on third and fifth is depend on fourth\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be COMMITTED.", "16": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, \nfourth is depend on third and fifth is depend on fourth. Fourth one will be an invalid txn\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be INVALID.", "17": "1.Create first batch having 3 transactions.\n2.Make third transaction invalid from first  batch.\n3.Create second batch having 2 transactions \n4.Make transaction from second batch dependent on transaction from first batch.\n5.post batch and check for the status.\n6.Create third batch having 2 transaction.\n7.Make transaction from third batch dependent on transaction from second batch.\n8.post batch and check for the status."}, "setup": {"duration": 0.0005538463592529297, "outcome": "passed"}, "call": {"duration": 0.014555215835571289, "outcome": "failed", "crash": {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]"}, "traceback": [{"path": "dep_txns/test_rest_api_dep_txns.py", "lineno": 1021, "message": ""}, {"path": "dep_txns/test_rest_api_dep_txns.py", "lineno": 69, "message": "in async_post_batch"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 779, "message": "in __aenter__"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 319, "message": "in _request"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 418, "message": "in connect"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 736, "message": "in _create_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 855, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 838, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "ClientConnectorError"}], "log": [{"name": "test_rest_api_dep_txns", "msg": "Starting test for batch post", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 963, "funcName": "test_valid_set_invalid_inc_txn_dep", "created": 1552990408.3341432, "msecs": 334.14316177368164, "relativeCreated": 2529191.563844681, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with set operations", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 974, "funcName": "test_valid_set_invalid_inc_txn_dep", "created": 1552990408.3449483, "msecs": 344.94829177856445, "relativeCreated": 2529202.3689746857, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Creating invalid intkey transactions with inc operations with dependent transactions as first transaction", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 987, "funcName": "test_valid_set_invalid_inc_txn_dep", "created": 1552990408.3456326, "msecs": 345.63255310058594, "relativeCreated": 2529203.0532360077, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Creating batches for transactions 1trn/batch", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 999, "funcName": "test_valid_set_invalid_inc_txn_dep", "created": 1552990408.3459222, "msecs": 345.92223167419434, "relativeCreated": 2529203.3429145813, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Submitting batches to the handlers", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1014, "funcName": "test_valid_set_invalid_inc_txn_dep", "created": 1552990408.3464663, "msecs": 346.4663028717041, "relativeCreated": 2529203.886985779, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}], "longrepr": "self = <aiohttp.connector.TCPConnector object at 0x7fd599625f60>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd599625828>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n>           return await self._loop.create_connection(*args, **kwargs)\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:800: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n                    yield from self.sock_connect(sock, address)\n                except OSError as exc:\n                    if sock is not None:\n                        sock.close()\n                    exceptions.append(exc)\n                except:\n                    if sock is not None:\n                        sock.close()\n                    raise\n                else:\n                    break\n            else:\n                if len(exceptions) == 1:\n>                   raise exceptions[0]\n\n/usr/lib/python3.6/asyncio/base_events.py:783: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n>                   yield from self.sock_connect(sock, address)\n\n/usr/lib/python3.6/asyncio/base_events.py:770: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>, sock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>\naddress = ('192.168.1.23', 8008)\n\n    @coroutine\n    def sock_connect(self, sock, address):\n        \"\"\"Connect to a remote socket at address.\n    \n        This method is a coroutine.\n        \"\"\"\n        if self._debug and sock.gettimeout() != 0:\n            raise ValueError(\"the socket must be non-blocking\")\n    \n        if not hasattr(socket, 'AF_UNIX') or sock.family != socket.AF_UNIX:\n            resolved = base_events._ensure_resolved(\n                address, family=sock.family, proto=sock.proto, loop=self)\n            if not resolved.done():\n                yield from resolved\n            _, _, _, _, address = resolved.result()[0]\n    \n        fut = self.create_future()\n        self._sock_connect(fut, sock, address)\n>       return (yield from fut)\n\n/usr/lib/python3.6/asyncio/selector_events.py:450: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nfut = <Future finished exception=ConnectionRefusedError(111, \"Connect call failed ('192.168.1.23', 8008)\")>\nsock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>, address = ('192.168.1.23', 8008)\n\n    def _sock_connect_cb(self, fut, sock, address):\n        if fut.cancelled():\n            return\n    \n        try:\n            err = sock.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)\n            if err != 0:\n                # Jump to any except clause below.\n>               raise OSError(err, 'Connect call failed %s' % (address,))\nE               ConnectionRefusedError: [Errno 111] Connect call failed ('192.168.1.23', 8008)\n\n/usr/lib/python3.6/asyncio/selector_events.py:480: ConnectionRefusedError\n\nThe above exception was the direct cause of the following exception:\n\nself = <test_rest_api_dep_txns.TestPostTansactionDependencies object at 0x7fd59962cac8>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_valid_set_invalid_inc_txn_dep(self, setup):\n        \"\"\"1. Create first Transaction for set\n        2. Create second invalid Transaction for increment with first Transaction as dependecies\n        3. Create Batch\n        4. Call POST /batches\n        Verify the transactions. This should be an invalid transaction. The third txn will be in PENDING state\n        \"\"\"\n        LOGGER.info('Starting test for batch post')\n    \n        signer = get_signer()\n        expected_trxn_ids  = []\n        expected_batch_ids = []\n        address = _get_client_address()\n        url='{}/batches'.format(address)\n        tasks=[]\n        words = random_word_list(200)\n        name=random.choice(words)\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction_dep(\"set\", [] , name, 50, signer),]\n        for txn in txns:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxn_ids.append(trxn_id)\n    \n        LOGGER.info(\"Creating invalid intkey transactions with inc operations with dependent transactions as first transaction\")\n        trxn_ids = expected_trxn_ids\n        txns.append(create_intkey_transaction_dep(\"inc\", trxn_ids , name, -1, signer))\n        for txn in txns:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxn_ids.append(trxn_id)\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            data = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = data['header_signature']\n            expected_batch_ids.append(batch_id)\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                for batch in post_batch_list:\n                    task = asyncio.ensure_future(async_post_batch(url,session,data=batch))\n                    tasks.append(task)\n>               responses = await asyncio.gather(*tasks)\n\ndep_txns/test_rest_api_dep_txns.py:1021: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ndep_txns/test_rest_api_dep_txns.py:69: in async_post_batch\n    async with session.post(url,data=data,headers=headers) as response:\n/usr/lib/python3/dist-packages/aiohttp/client.py:779: in __aenter__\n    self._resp = await self._coro\n/usr/lib/python3/dist-packages/aiohttp/client.py:319: in _request\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:418: in connect\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:736: in _create_connection\n    traces=None\n/usr/lib/python3/dist-packages/aiohttp/connector.py:855: in _create_direct_connection\n    raise last_exc\n/usr/lib/python3/dist-packages/aiohttp/connector.py:838: in _create_direct_connection\n    req=req, client_error=client_error)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <aiohttp.connector.TCPConnector object at 0x7fd599625f60>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd599625828>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n            return await self._loop.create_connection(*args, **kwargs)\n        except certificate_errors as exc:\n            raise ClientConnectorCertificateError(\n                req.connection_key, exc) from exc\n        except ssl_errors as exc:\n            raise ClientConnectorSSLError(req.connection_key, exc) from exc\n        except OSError as exc:\n>           raise client_error(req.connection_key, exc) from exc\nE           aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:807: ClientConnectorError"}, "teardown": {"duration": 0.00027751922607421875, "outcome": "passed"}}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_valid_set_invalid_inc_DiffKey_txn_dep", "lineno": 1033, "outcome": "failed", "keywords": ["run", "test_valid_set_invalid_inc_DiffKey_txn_dep", "TestPostTansactionDependencies", "api_test", "dep_txns/test_rest_api_dep_txns.py", "sixth", "()", "dependent"], "metadata": {"0": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "1": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                                                             \n3. Create third Transaction for decrement with first and second Transaction as dependecies                                                            \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "2": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "3": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "4": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies\n3. Create third Transaction for increment with first and second Transaction as dependecies                                                                                                                \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "5": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single and same  dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "6": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with invalid Transaction as dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "7": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment reverse dependency                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "8": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies                                                                                                          \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This should be an invalid transaction. The third txn will be in PENDING state", "9": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies with different key                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This shoud be an invalid transaction. The trird txn will be in PENDING state", "10": "1. Create first Transaction for set with max value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "11": "1. Create first invalid Transaction for set with negative value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first invalid Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "12": "1. Create first Transaction for set                                                                                                                                                                                                                   \n2. Create second dependent Transaction for increment and make the address invalid with first Transaction as dependency     \n3. Create batch ,post batch and check the response status\n4. The second transaction will be an invalid transaction\n5. Create the third transaction for decrement with first and second as dependency \n6. Create a batch and post batch\nVerify the transaction responses. The first one will be COMMITTED and second one shoud be an invalid transaction. The third txn will be with error code 17 and Validator Timed Out", "13": "1.Create 5 independent Transactions for set\n2.Create second dependent transaction for set with 5 independent transactions as dependency\n3.Create third dependent Transaction for increment with second dependent Transaction as dependency     \n4.Create a batch for all the dependent transaction and post batch\n5.Check for the status\n6.Now create the batch for independent transactions and post batch\n7. Check for the response status of both independent and dependent transactions", "14": "1.Create a dependent transactions for increment\n2.Create a dependent transaction for set for the same key with first transaction as dependent                                                                                                                                                \n3.Create batch and post the first transaction(increment) first and check the response status\n4.Post the second transaction(set)  and check the response status", "15": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, fourth is depend on third and fifth is depend on fourth\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be COMMITTED.", "16": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, \nfourth is depend on third and fifth is depend on fourth. Fourth one will be an invalid txn\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be INVALID.", "17": "1.Create first batch having 3 transactions.\n2.Make third transaction invalid from first  batch.\n3.Create second batch having 2 transactions \n4.Make transaction from second batch dependent on transaction from first batch.\n5.post batch and check for the status.\n6.Create third batch having 2 transaction.\n7.Make transaction from third batch dependent on transaction from second batch.\n8.post batch and check for the status."}, "setup": {"duration": 0.0005204677581787109, "outcome": "passed"}, "call": {"duration": 0.014440774917602539, "outcome": "failed", "crash": {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]"}, "traceback": [{"path": "dep_txns/test_rest_api_dep_txns.py", "lineno": 1103, "message": ""}, {"path": "dep_txns/test_rest_api_dep_txns.py", "lineno": 69, "message": "in async_post_batch"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 779, "message": "in __aenter__"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 319, "message": "in _request"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 418, "message": "in connect"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 736, "message": "in _create_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 855, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 838, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "ClientConnectorError"}], "log": [{"name": "test_rest_api_dep_txns", "msg": "Starting test for batch post", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1041, "funcName": "test_valid_set_invalid_inc_DiffKey_txn_dep", "created": 1552990408.5061917, "msecs": 506.1917304992676, "relativeCreated": 2529363.6124134064, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with set operations", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1052, "funcName": "test_valid_set_invalid_inc_DiffKey_txn_dep", "created": 1552990408.5169098, "msecs": 516.9098377227783, "relativeCreated": 2529374.33052063, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Creating invalid intkey transactions with inc operations with dependent transactions as first transaction", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1065, "funcName": "test_valid_set_invalid_inc_DiffKey_txn_dep", "created": 1552990408.5175955, "msecs": 517.5955295562744, "relativeCreated": 2529375.0162124634, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Creating batches for transactions 1trn/batch", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1079, "funcName": "test_valid_set_invalid_inc_DiffKey_txn_dep", "created": 1552990408.517868, "msecs": 517.8680419921875, "relativeCreated": 2529375.2887248993, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Submitting batches to the handlers", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1096, "funcName": "test_valid_set_invalid_inc_DiffKey_txn_dep", "created": 1552990408.5184329, "msecs": 518.4328556060791, "relativeCreated": 2529375.853538513, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}], "longrepr": "self = <aiohttp.connector.TCPConnector object at 0x7fd5998b64e0>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd5998b66a0>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n>           return await self._loop.create_connection(*args, **kwargs)\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:800: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n                    yield from self.sock_connect(sock, address)\n                except OSError as exc:\n                    if sock is not None:\n                        sock.close()\n                    exceptions.append(exc)\n                except:\n                    if sock is not None:\n                        sock.close()\n                    raise\n                else:\n                    break\n            else:\n                if len(exceptions) == 1:\n>                   raise exceptions[0]\n\n/usr/lib/python3.6/asyncio/base_events.py:783: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n>                   yield from self.sock_connect(sock, address)\n\n/usr/lib/python3.6/asyncio/base_events.py:770: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>, sock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>\naddress = ('192.168.1.23', 8008)\n\n    @coroutine\n    def sock_connect(self, sock, address):\n        \"\"\"Connect to a remote socket at address.\n    \n        This method is a coroutine.\n        \"\"\"\n        if self._debug and sock.gettimeout() != 0:\n            raise ValueError(\"the socket must be non-blocking\")\n    \n        if not hasattr(socket, 'AF_UNIX') or sock.family != socket.AF_UNIX:\n            resolved = base_events._ensure_resolved(\n                address, family=sock.family, proto=sock.proto, loop=self)\n            if not resolved.done():\n                yield from resolved\n            _, _, _, _, address = resolved.result()[0]\n    \n        fut = self.create_future()\n        self._sock_connect(fut, sock, address)\n>       return (yield from fut)\n\n/usr/lib/python3.6/asyncio/selector_events.py:450: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nfut = <Future finished exception=ConnectionRefusedError(111, \"Connect call failed ('192.168.1.23', 8008)\")>\nsock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>, address = ('192.168.1.23', 8008)\n\n    def _sock_connect_cb(self, fut, sock, address):\n        if fut.cancelled():\n            return\n    \n        try:\n            err = sock.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)\n            if err != 0:\n                # Jump to any except clause below.\n>               raise OSError(err, 'Connect call failed %s' % (address,))\nE               ConnectionRefusedError: [Errno 111] Connect call failed ('192.168.1.23', 8008)\n\n/usr/lib/python3.6/asyncio/selector_events.py:480: ConnectionRefusedError\n\nThe above exception was the direct cause of the following exception:\n\nself = <test_rest_api_dep_txns.TestPostTansactionDependencies object at 0x7fd599536fd0>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_valid_set_invalid_inc_DiffKey_txn_dep(self, setup):\n        \"\"\"1. Create first Transaction for set\n        2. Create second invalid Transaction for increment with first Transaction as dependecies with different key\n        3. Create Batch\n        4. Call POST /batches\n        Verify the transactions. This shoud be an invalid transaction. The trird txn will be in PENDING state\n        \"\"\"\n        LOGGER.info('Starting test for batch post')\n    \n        signer = get_signer()\n        expected_trxn_ids  = []\n        expected_batch_ids = []\n        address = _get_client_address()\n        url='{}/batches'.format(address)\n        tasks=[]\n        words = random_word_list(200)\n        name=random.choice(words)\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction_dep(\"set\", [] , name, 50, signer),]\n        for txn in txns:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxn_ids.append(trxn_id)\n    \n        LOGGER.info(\"Creating invalid intkey transactions with inc operations with dependent transactions as first transaction\")\n        trxn_ids = expected_trxn_ids\n    \n        name = random.choice(\"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\")\n        txns.append(create_intkey_transaction_dep(\"inc\", trxn_ids , name, -1, signer))\n        for txn in txns:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxn_ids.append(trxn_id)\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            data = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = data['header_signature']\n            expected_batch_ids.append(batch_id)\n    \n    \n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                for batch in post_batch_list:\n                    task = asyncio.ensure_future(async_post_batch(url,session,data=batch))\n                    tasks.append(task)\n>               responses = await asyncio.gather(*tasks)\n\ndep_txns/test_rest_api_dep_txns.py:1103: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ndep_txns/test_rest_api_dep_txns.py:69: in async_post_batch\n    async with session.post(url,data=data,headers=headers) as response:\n/usr/lib/python3/dist-packages/aiohttp/client.py:779: in __aenter__\n    self._resp = await self._coro\n/usr/lib/python3/dist-packages/aiohttp/client.py:319: in _request\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:418: in connect\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:736: in _create_connection\n    traces=None\n/usr/lib/python3/dist-packages/aiohttp/connector.py:855: in _create_direct_connection\n    raise last_exc\n/usr/lib/python3/dist-packages/aiohttp/connector.py:838: in _create_direct_connection\n    req=req, client_error=client_error)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <aiohttp.connector.TCPConnector object at 0x7fd5998b64e0>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd5998b66a0>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n            return await self._loop.create_connection(*args, **kwargs)\n        except certificate_errors as exc:\n            raise ClientConnectorCertificateError(\n                req.connection_key, exc) from exc\n        except ssl_errors as exc:\n            raise ClientConnectorSSLError(req.connection_key, exc) from exc\n        except OSError as exc:\n>           raise client_error(req.connection_key, exc) from exc\nE           aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:807: ClientConnectorError"}, "teardown": {"duration": 0.00029778480529785156, "outcome": "passed"}}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_set_Max_txn_dep", "lineno": 1115, "outcome": "failed", "keywords": ["run", "TestPostTansactionDependencies", "test_set_Max_txn_dep", "api_test", "dep_txns/test_rest_api_dep_txns.py", "sixth", "()", "dependent"], "metadata": {"0": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "1": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                                                             \n3. Create third Transaction for decrement with first and second Transaction as dependecies                                                            \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "2": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "3": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "4": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies\n3. Create third Transaction for increment with first and second Transaction as dependecies                                                                                                                \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "5": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single and same  dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "6": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with invalid Transaction as dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "7": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment reverse dependency                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "8": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies                                                                                                          \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This should be an invalid transaction. The third txn will be in PENDING state", "9": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies with different key                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This shoud be an invalid transaction. The trird txn will be in PENDING state", "10": "1. Create first Transaction for set with max value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "11": "1. Create first invalid Transaction for set with negative value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first invalid Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "12": "1. Create first Transaction for set                                                                                                                                                                                                                   \n2. Create second dependent Transaction for increment and make the address invalid with first Transaction as dependency     \n3. Create batch ,post batch and check the response status\n4. The second transaction will be an invalid transaction\n5. Create the third transaction for decrement with first and second as dependency \n6. Create a batch and post batch\nVerify the transaction responses. The first one will be COMMITTED and second one shoud be an invalid transaction. The third txn will be with error code 17 and Validator Timed Out", "13": "1.Create 5 independent Transactions for set\n2.Create second dependent transaction for set with 5 independent transactions as dependency\n3.Create third dependent Transaction for increment with second dependent Transaction as dependency     \n4.Create a batch for all the dependent transaction and post batch\n5.Check for the status\n6.Now create the batch for independent transactions and post batch\n7. Check for the response status of both independent and dependent transactions", "14": "1.Create a dependent transactions for increment\n2.Create a dependent transaction for set for the same key with first transaction as dependent                                                                                                                                                \n3.Create batch and post the first transaction(increment) first and check the response status\n4.Post the second transaction(set)  and check the response status", "15": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, fourth is depend on third and fifth is depend on fourth\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be COMMITTED.", "16": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, \nfourth is depend on third and fifth is depend on fourth. Fourth one will be an invalid txn\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be INVALID.", "17": "1.Create first batch having 3 transactions.\n2.Make third transaction invalid from first  batch.\n3.Create second batch having 2 transactions \n4.Make transaction from second batch dependent on transaction from first batch.\n5.post batch and check for the status.\n6.Create third batch having 2 transaction.\n7.Make transaction from third batch dependent on transaction from second batch.\n8.post batch and check for the status."}, "setup": {"duration": 0.0005676746368408203, "outcome": "passed"}, "call": {"duration": 0.014402627944946289, "outcome": "failed", "crash": {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]"}, "traceback": [{"path": "dep_txns/test_rest_api_dep_txns.py", "lineno": 1181, "message": ""}, {"path": "dep_txns/test_rest_api_dep_txns.py", "lineno": 69, "message": "in async_post_batch"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 779, "message": "in __aenter__"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 319, "message": "in _request"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 418, "message": "in connect"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 736, "message": "in _create_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 855, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 838, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "ClientConnectorError"}], "log": [{"name": "test_rest_api_dep_txns", "msg": "Starting test for batch post", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1123, "funcName": "test_set_Max_txn_dep", "created": 1552990408.653937, "msecs": 653.9371013641357, "relativeCreated": 2529511.3577842712, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with set operations", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1134, "funcName": "test_set_Max_txn_dep", "created": 1552990408.6646054, "msecs": 664.6053791046143, "relativeCreated": 2529522.0260620117, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Creating invalid intkey transactions with inc operations with dependent transactions as first transaction", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1147, "funcName": "test_set_Max_txn_dep", "created": 1552990408.6653025, "msecs": 665.3025150299072, "relativeCreated": 2529522.723197937, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Creating batches for transactions 1trn/batch", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1159, "funcName": "test_set_Max_txn_dep", "created": 1552990408.6655726, "msecs": 665.5726432800293, "relativeCreated": 2529522.993326187, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Submitting batches to the handlers", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1174, "funcName": "test_set_Max_txn_dep", "created": 1552990408.6661158, "msecs": 666.1157608032227, "relativeCreated": 2529523.5364437103, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}], "longrepr": "self = <aiohttp.connector.TCPConnector object at 0x7fd5997f54e0>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd5997f57f0>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n>           return await self._loop.create_connection(*args, **kwargs)\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:800: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n                    yield from self.sock_connect(sock, address)\n                except OSError as exc:\n                    if sock is not None:\n                        sock.close()\n                    exceptions.append(exc)\n                except:\n                    if sock is not None:\n                        sock.close()\n                    raise\n                else:\n                    break\n            else:\n                if len(exceptions) == 1:\n>                   raise exceptions[0]\n\n/usr/lib/python3.6/asyncio/base_events.py:783: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n>                   yield from self.sock_connect(sock, address)\n\n/usr/lib/python3.6/asyncio/base_events.py:770: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>, sock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>\naddress = ('192.168.1.23', 8008)\n\n    @coroutine\n    def sock_connect(self, sock, address):\n        \"\"\"Connect to a remote socket at address.\n    \n        This method is a coroutine.\n        \"\"\"\n        if self._debug and sock.gettimeout() != 0:\n            raise ValueError(\"the socket must be non-blocking\")\n    \n        if not hasattr(socket, 'AF_UNIX') or sock.family != socket.AF_UNIX:\n            resolved = base_events._ensure_resolved(\n                address, family=sock.family, proto=sock.proto, loop=self)\n            if not resolved.done():\n                yield from resolved\n            _, _, _, _, address = resolved.result()[0]\n    \n        fut = self.create_future()\n        self._sock_connect(fut, sock, address)\n>       return (yield from fut)\n\n/usr/lib/python3.6/asyncio/selector_events.py:450: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nfut = <Future finished exception=ConnectionRefusedError(111, \"Connect call failed ('192.168.1.23', 8008)\")>\nsock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>, address = ('192.168.1.23', 8008)\n\n    def _sock_connect_cb(self, fut, sock, address):\n        if fut.cancelled():\n            return\n    \n        try:\n            err = sock.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)\n            if err != 0:\n                # Jump to any except clause below.\n>               raise OSError(err, 'Connect call failed %s' % (address,))\nE               ConnectionRefusedError: [Errno 111] Connect call failed ('192.168.1.23', 8008)\n\n/usr/lib/python3.6/asyncio/selector_events.py:480: ConnectionRefusedError\n\nThe above exception was the direct cause of the following exception:\n\nself = <test_rest_api_dep_txns.TestPostTansactionDependencies object at 0x7fd5996b7588>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_set_Max_txn_dep(self, setup):\n        \"\"\"1. Create first Transaction for set with max value\n        2. Create second Transaction for increment with first Transaction as dependency\n        3. Create Batch\n        4. Call POST /batches\n        Verify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out\n        \"\"\"\n        LOGGER.info('Starting test for batch post')\n    \n        signer = get_signer()\n        expected_trxn_ids  = []\n        expected_batch_ids = []\n        address = _get_client_address()\n        url='{}/batches'.format(address)\n        tasks=[]\n        words = random_word_list(200)\n        name=random.choice(words)\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction_dep(\"set\", [] , name, 8888888888888888888888888, signer),]\n        for txn in txns:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxn_ids.append(trxn_id)\n    \n        LOGGER.info(\"Creating invalid intkey transactions with inc operations with dependent transactions as first transaction\")\n        trxn_ids = expected_trxn_ids\n        txns.append(create_intkey_transaction_dep(\"inc\", trxn_ids , name, 2, signer))\n        for txn in txns:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxn_ids.append(trxn_id)\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            data = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = data['header_signature']\n            expected_batch_ids.append(batch_id)\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                for batch in post_batch_list:\n                    task = asyncio.ensure_future(async_post_batch(url,session,data=batch))\n                    tasks.append(task)\n>               responses = await asyncio.gather(*tasks)\n\ndep_txns/test_rest_api_dep_txns.py:1181: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ndep_txns/test_rest_api_dep_txns.py:69: in async_post_batch\n    async with session.post(url,data=data,headers=headers) as response:\n/usr/lib/python3/dist-packages/aiohttp/client.py:779: in __aenter__\n    self._resp = await self._coro\n/usr/lib/python3/dist-packages/aiohttp/client.py:319: in _request\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:418: in connect\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:736: in _create_connection\n    traces=None\n/usr/lib/python3/dist-packages/aiohttp/connector.py:855: in _create_direct_connection\n    raise last_exc\n/usr/lib/python3/dist-packages/aiohttp/connector.py:838: in _create_direct_connection\n    req=req, client_error=client_error)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <aiohttp.connector.TCPConnector object at 0x7fd5997f54e0>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd5997f57f0>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n            return await self._loop.create_connection(*args, **kwargs)\n        except certificate_errors as exc:\n            raise ClientConnectorCertificateError(\n                req.connection_key, exc) from exc\n        except ssl_errors as exc:\n            raise ClientConnectorSSLError(req.connection_key, exc) from exc\n        except OSError as exc:\n>           raise client_error(req.connection_key, exc) from exc\nE           aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:807: ClientConnectorError"}, "teardown": {"duration": 0.0002779960632324219, "outcome": "passed"}}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_invalid_set_txn_dep", "lineno": 1195, "outcome": "failed", "keywords": ["run", "TestPostTansactionDependencies", "api_test", "dep_txns/test_rest_api_dep_txns.py", "sixth", "test_invalid_set_txn_dep", "()", "dependent"], "metadata": {"0": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "1": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                                                             \n3. Create third Transaction for decrement with first and second Transaction as dependecies                                                            \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "2": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "3": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "4": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies\n3. Create third Transaction for increment with first and second Transaction as dependecies                                                                                                                \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "5": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single and same  dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "6": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with invalid Transaction as dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "7": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment reverse dependency                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "8": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies                                                                                                          \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This should be an invalid transaction. The third txn will be in PENDING state", "9": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies with different key                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This shoud be an invalid transaction. The trird txn will be in PENDING state", "10": "1. Create first Transaction for set with max value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "11": "1. Create first invalid Transaction for set with negative value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first invalid Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "12": "1. Create first Transaction for set                                                                                                                                                                                                                   \n2. Create second dependent Transaction for increment and make the address invalid with first Transaction as dependency     \n3. Create batch ,post batch and check the response status\n4. The second transaction will be an invalid transaction\n5. Create the third transaction for decrement with first and second as dependency \n6. Create a batch and post batch\nVerify the transaction responses. The first one will be COMMITTED and second one shoud be an invalid transaction. The third txn will be with error code 17 and Validator Timed Out", "13": "1.Create 5 independent Transactions for set\n2.Create second dependent transaction for set with 5 independent transactions as dependency\n3.Create third dependent Transaction for increment with second dependent Transaction as dependency     \n4.Create a batch for all the dependent transaction and post batch\n5.Check for the status\n6.Now create the batch for independent transactions and post batch\n7. Check for the response status of both independent and dependent transactions", "14": "1.Create a dependent transactions for increment\n2.Create a dependent transaction for set for the same key with first transaction as dependent                                                                                                                                                \n3.Create batch and post the first transaction(increment) first and check the response status\n4.Post the second transaction(set)  and check the response status", "15": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, fourth is depend on third and fifth is depend on fourth\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be COMMITTED.", "16": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, \nfourth is depend on third and fifth is depend on fourth. Fourth one will be an invalid txn\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be INVALID.", "17": "1.Create first batch having 3 transactions.\n2.Make third transaction invalid from first  batch.\n3.Create second batch having 2 transactions \n4.Make transaction from second batch dependent on transaction from first batch.\n5.post batch and check for the status.\n6.Create third batch having 2 transaction.\n7.Make transaction from third batch dependent on transaction from second batch.\n8.post batch and check for the status."}, "setup": {"duration": 0.0005359649658203125, "outcome": "passed"}, "call": {"duration": 0.014458179473876953, "outcome": "failed", "crash": {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]"}, "traceback": [{"path": "dep_txns/test_rest_api_dep_txns.py", "lineno": 1261, "message": ""}, {"path": "dep_txns/test_rest_api_dep_txns.py", "lineno": 69, "message": "in async_post_batch"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 779, "message": "in __aenter__"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 319, "message": "in _request"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 418, "message": "in connect"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 736, "message": "in _create_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 855, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 838, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "ClientConnectorError"}], "log": [{"name": "test_rest_api_dep_txns", "msg": "Starting test for batch post", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1203, "funcName": "test_invalid_set_txn_dep", "created": 1552990408.820394, "msecs": 820.3940391540527, "relativeCreated": 2529677.814722061, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with set operations", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1214, "funcName": "test_invalid_set_txn_dep", "created": 1552990408.8311617, "msecs": 831.1617374420166, "relativeCreated": 2529688.582420349, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Creating invalid intkey transactions with inc operations with dependent transactions as first transaction", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1227, "funcName": "test_invalid_set_txn_dep", "created": 1552990408.8318465, "msecs": 831.8464756011963, "relativeCreated": 2529689.2671585083, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Creating batches for transactions 1trn/batch", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1239, "funcName": "test_invalid_set_txn_dep", "created": 1552990408.8321168, "msecs": 832.1168422698975, "relativeCreated": 2529689.537525177, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Submitting batches to the handlers", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1254, "funcName": "test_invalid_set_txn_dep", "created": 1552990408.832656, "msecs": 832.6559066772461, "relativeCreated": 2529690.0765895844, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}], "longrepr": "self = <aiohttp.connector.TCPConnector object at 0x7fd5997ed9e8>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd5997edcf8>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n>           return await self._loop.create_connection(*args, **kwargs)\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:800: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n                    yield from self.sock_connect(sock, address)\n                except OSError as exc:\n                    if sock is not None:\n                        sock.close()\n                    exceptions.append(exc)\n                except:\n                    if sock is not None:\n                        sock.close()\n                    raise\n                else:\n                    break\n            else:\n                if len(exceptions) == 1:\n>                   raise exceptions[0]\n\n/usr/lib/python3.6/asyncio/base_events.py:783: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n>                   yield from self.sock_connect(sock, address)\n\n/usr/lib/python3.6/asyncio/base_events.py:770: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>, sock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>\naddress = ('192.168.1.23', 8008)\n\n    @coroutine\n    def sock_connect(self, sock, address):\n        \"\"\"Connect to a remote socket at address.\n    \n        This method is a coroutine.\n        \"\"\"\n        if self._debug and sock.gettimeout() != 0:\n            raise ValueError(\"the socket must be non-blocking\")\n    \n        if not hasattr(socket, 'AF_UNIX') or sock.family != socket.AF_UNIX:\n            resolved = base_events._ensure_resolved(\n                address, family=sock.family, proto=sock.proto, loop=self)\n            if not resolved.done():\n                yield from resolved\n            _, _, _, _, address = resolved.result()[0]\n    \n        fut = self.create_future()\n        self._sock_connect(fut, sock, address)\n>       return (yield from fut)\n\n/usr/lib/python3.6/asyncio/selector_events.py:450: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nfut = <Future finished exception=ConnectionRefusedError(111, \"Connect call failed ('192.168.1.23', 8008)\")>\nsock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>, address = ('192.168.1.23', 8008)\n\n    def _sock_connect_cb(self, fut, sock, address):\n        if fut.cancelled():\n            return\n    \n        try:\n            err = sock.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)\n            if err != 0:\n                # Jump to any except clause below.\n>               raise OSError(err, 'Connect call failed %s' % (address,))\nE               ConnectionRefusedError: [Errno 111] Connect call failed ('192.168.1.23', 8008)\n\n/usr/lib/python3.6/asyncio/selector_events.py:480: ConnectionRefusedError\n\nThe above exception was the direct cause of the following exception:\n\nself = <test_rest_api_dep_txns.TestPostTansactionDependencies object at 0x7fd5996ab470>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_invalid_set_txn_dep(self, setup):\n        \"\"\"1. Create first invalid Transaction for set with negative value\n        2. Create second Transaction for increment with first invalid Transaction as dependency\n        3. Create Batch\n        4. Call POST /batches\n        Verify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out\n        \"\"\"\n        LOGGER.info('Starting test for batch post')\n    \n        signer = get_signer()\n        expected_trxn_ids  = []\n        expected_batch_ids = []\n        address = _get_client_address()\n        url='{}/batches'.format(address)\n        tasks=[]\n        words = random_word_list(200)\n        name=random.choice(words)\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n    \n        txns = [\n            create_intkey_transaction_dep(\"set\", [] , name, -1, signer),]\n        for txn in txns:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxn_ids.append(trxn_id)\n    \n        LOGGER.info(\"Creating invalid intkey transactions with inc operations with dependent transactions as first transaction\")\n        trxn_ids = expected_trxn_ids\n        txns.append(create_intkey_transaction_dep(\"inc\", trxn_ids , name, 2, signer))\n        for txn in txns:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxn_ids.append(trxn_id)\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            data = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = data['header_signature']\n            expected_batch_ids.append(batch_id)\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                for batch in post_batch_list:\n                    task = asyncio.ensure_future(async_post_batch(url,session,data=batch))\n                    tasks.append(task)\n>               responses = await asyncio.gather(*tasks)\n\ndep_txns/test_rest_api_dep_txns.py:1261: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ndep_txns/test_rest_api_dep_txns.py:69: in async_post_batch\n    async with session.post(url,data=data,headers=headers) as response:\n/usr/lib/python3/dist-packages/aiohttp/client.py:779: in __aenter__\n    self._resp = await self._coro\n/usr/lib/python3/dist-packages/aiohttp/client.py:319: in _request\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:418: in connect\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:736: in _create_connection\n    traces=None\n/usr/lib/python3/dist-packages/aiohttp/connector.py:855: in _create_direct_connection\n    raise last_exc\n/usr/lib/python3/dist-packages/aiohttp/connector.py:838: in _create_direct_connection\n    req=req, client_error=client_error)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <aiohttp.connector.TCPConnector object at 0x7fd5997ed9e8>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd5997edcf8>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n            return await self._loop.create_connection(*args, **kwargs)\n        except certificate_errors as exc:\n            raise ClientConnectorCertificateError(\n                req.connection_key, exc) from exc\n        except ssl_errors as exc:\n            raise ClientConnectorSSLError(req.connection_key, exc) from exc\n        except OSError as exc:\n>           raise client_error(req.connection_key, exc) from exc\nE           aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:807: ClientConnectorError"}, "teardown": {"duration": 0.00030612945556640625, "outcome": "passed"}}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_invalid_Address_txn_dep", "lineno": 1274, "outcome": "failed", "keywords": ["run", "TestPostTansactionDependencies", "api_test", "test_invalid_Address_txn_dep", "dep_txns/test_rest_api_dep_txns.py", "sixth", "()", "dependent"], "metadata": {"0": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "1": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                                                             \n3. Create third Transaction for decrement with first and second Transaction as dependecies                                                            \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "2": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "3": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "4": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies\n3. Create third Transaction for increment with first and second Transaction as dependecies                                                                                                                \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "5": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single and same  dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "6": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with invalid Transaction as dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "7": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment reverse dependency                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "8": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies                                                                                                          \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This should be an invalid transaction. The third txn will be in PENDING state", "9": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies with different key                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This shoud be an invalid transaction. The trird txn will be in PENDING state", "10": "1. Create first Transaction for set with max value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "11": "1. Create first invalid Transaction for set with negative value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first invalid Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "12": "1. Create first Transaction for set                                                                                                                                                                                                                   \n2. Create second dependent Transaction for increment and make the address invalid with first Transaction as dependency     \n3. Create batch ,post batch and check the response status\n4. The second transaction will be an invalid transaction\n5. Create the third transaction for decrement with first and second as dependency \n6. Create a batch and post batch\nVerify the transaction responses. The first one will be COMMITTED and second one shoud be an invalid transaction. The third txn will be with error code 17 and Validator Timed Out", "13": "1.Create 5 independent Transactions for set\n2.Create second dependent transaction for set with 5 independent transactions as dependency\n3.Create third dependent Transaction for increment with second dependent Transaction as dependency     \n4.Create a batch for all the dependent transaction and post batch\n5.Check for the status\n6.Now create the batch for independent transactions and post batch\n7. Check for the response status of both independent and dependent transactions", "14": "1.Create a dependent transactions for increment\n2.Create a dependent transaction for set for the same key with first transaction as dependent                                                                                                                                                \n3.Create batch and post the first transaction(increment) first and check the response status\n4.Post the second transaction(set)  and check the response status", "15": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, fourth is depend on third and fifth is depend on fourth\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be COMMITTED.", "16": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, \nfourth is depend on third and fifth is depend on fourth. Fourth one will be an invalid txn\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be INVALID.", "17": "1.Create first batch having 3 transactions.\n2.Make third transaction invalid from first  batch.\n3.Create second batch having 2 transactions \n4.Make transaction from second batch dependent on transaction from first batch.\n5.post batch and check for the status.\n6.Create third batch having 2 transaction.\n7.Make transaction from third batch dependent on transaction from second batch.\n8.post batch and check for the status."}, "setup": {"duration": 0.0005750656127929688, "outcome": "passed"}, "call": {"duration": 0.012587308883666992, "outcome": "failed", "log": [{"name": "test_rest_api_dep_txns", "msg": "Starting test for batch post", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1284, "funcName": "test_invalid_Address_txn_dep", "created": 1552990408.968736, "msecs": 968.735933303833, "relativeCreated": 2529826.156616211, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with set operations", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1295, "funcName": "test_invalid_Address_txn_dep", "created": 1552990408.9796371, "msecs": 979.6371459960938, "relativeCreated": 2529837.057828903, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Creating invalid intkey transactions with inc operations with dependent transactions as first transaction", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1308, "funcName": "test_invalid_Address_txn_dep", "created": 1552990408.9803114, "msecs": 980.311393737793, "relativeCreated": 2529837.732076645, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Creating batches for transactions 1trn/batch", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1320, "funcName": "test_invalid_Address_txn_dep", "created": 1552990408.9805877, "msecs": 980.5877208709717, "relativeCreated": 2529838.008403778, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}], "longrepr": "Fixture \"post_batch_txn\" called directly. Fixtures are not meant to be called directly,\nbut are created automatically when test functions request them as parameters.\nSee https://docs.pytest.org/en/latest/fixture.html for more information about fixtures, and\nhttps://docs.pytest.org/en/latest/deprecations.html#calling-fixtures-directly about how to update your code."}, "teardown": {"duration": 0.0003070831298828125, "outcome": "passed"}}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_Multiple_Indep_Txn_txn_dep", "lineno": 1377, "outcome": "failed", "keywords": ["run", "TestPostTansactionDependencies", "api_test", "test_Multiple_Indep_Txn_txn_dep", "dep_txns/test_rest_api_dep_txns.py", "sixth", "()", "dependent"], "metadata": {"0": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "1": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                                                             \n3. Create third Transaction for decrement with first and second Transaction as dependecies                                                            \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "2": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "3": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "4": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies\n3. Create third Transaction for increment with first and second Transaction as dependecies                                                                                                                \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "5": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single and same  dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "6": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with invalid Transaction as dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "7": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment reverse dependency                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "8": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies                                                                                                          \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This should be an invalid transaction. The third txn will be in PENDING state", "9": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies with different key                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This shoud be an invalid transaction. The trird txn will be in PENDING state", "10": "1. Create first Transaction for set with max value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "11": "1. Create first invalid Transaction for set with negative value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first invalid Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "12": "1. Create first Transaction for set                                                                                                                                                                                                                   \n2. Create second dependent Transaction for increment and make the address invalid with first Transaction as dependency     \n3. Create batch ,post batch and check the response status\n4. The second transaction will be an invalid transaction\n5. Create the third transaction for decrement with first and second as dependency \n6. Create a batch and post batch\nVerify the transaction responses. The first one will be COMMITTED and second one shoud be an invalid transaction. The third txn will be with error code 17 and Validator Timed Out", "13": "1.Create 5 independent Transactions for set\n2.Create second dependent transaction for set with 5 independent transactions as dependency\n3.Create third dependent Transaction for increment with second dependent Transaction as dependency     \n4.Create a batch for all the dependent transaction and post batch\n5.Check for the status\n6.Now create the batch for independent transactions and post batch\n7. Check for the response status of both independent and dependent transactions", "14": "1.Create a dependent transactions for increment\n2.Create a dependent transaction for set for the same key with first transaction as dependent                                                                                                                                                \n3.Create batch and post the first transaction(increment) first and check the response status\n4.Post the second transaction(set)  and check the response status", "15": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, fourth is depend on third and fifth is depend on fourth\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be COMMITTED.", "16": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, \nfourth is depend on third and fifth is depend on fourth. Fourth one will be an invalid txn\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be INVALID.", "17": "1.Create first batch having 3 transactions.\n2.Make third transaction invalid from first  batch.\n3.Create second batch having 2 transactions \n4.Make transaction from second batch dependent on transaction from first batch.\n5.post batch and check for the status.\n6.Create third batch having 2 transaction.\n7.Make transaction from third batch dependent on transaction from second batch.\n8.post batch and check for the status."}, "setup": {"duration": 0.0005848407745361328, "outcome": "passed"}, "call": {"duration": 0.04743695259094238, "outcome": "failed", "log": [{"name": "test_rest_api_dep_txns", "msg": "Starting test for batch post", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1387, "funcName": "test_Multiple_Indep_Txn_txn_dep", "created": 1552990408.9835365, "msecs": 983.5364818572998, "relativeCreated": 2529840.9571647644, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with set operations", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1403, "funcName": "test_Multiple_Indep_Txn_txn_dep", "created": 1552990408.9941792, "msecs": 994.1792488098145, "relativeCreated": 2529851.599931717, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:28"}, {"name": "test_rest_api_dep_txns", "msg": "Creating invalid intkey transactions with inc operations with dependent transactions as first transaction", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1433, "funcName": "test_Multiple_Indep_Txn_txn_dep", "created": 1552990409.029955, "msecs": 29.954910278320312, "relativeCreated": 2529887.3755931854, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:29"}], "longrepr": "Fixture \"post_batch_txn\" called directly. Fixtures are not meant to be called directly,\nbut are created automatically when test functions request them as parameters.\nSee https://docs.pytest.org/en/latest/fixture.html for more information about fixtures, and\nhttps://docs.pytest.org/en/latest/deprecations.html#calling-fixtures-directly about how to update your code."}, "teardown": {"duration": 0.00029587745666503906, "outcome": "passed"}}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_inc_first_txn_dep", "lineno": 1484, "outcome": "failed", "keywords": ["run", "TestPostTansactionDependencies", "test_inc_first_txn_dep", "api_test", "dep_txns/test_rest_api_dep_txns.py", "sixth", "()", "dependent"], "metadata": {"0": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "1": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                                                             \n3. Create third Transaction for decrement with first and second Transaction as dependecies                                                            \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "2": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "3": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "4": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies\n3. Create third Transaction for increment with first and second Transaction as dependecies                                                                                                                \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "5": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single and same  dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "6": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with invalid Transaction as dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "7": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment reverse dependency                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "8": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies                                                                                                          \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This should be an invalid transaction. The third txn will be in PENDING state", "9": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies with different key                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This shoud be an invalid transaction. The trird txn will be in PENDING state", "10": "1. Create first Transaction for set with max value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "11": "1. Create first invalid Transaction for set with negative value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first invalid Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "12": "1. Create first Transaction for set                                                                                                                                                                                                                   \n2. Create second dependent Transaction for increment and make the address invalid with first Transaction as dependency     \n3. Create batch ,post batch and check the response status\n4. The second transaction will be an invalid transaction\n5. Create the third transaction for decrement with first and second as dependency \n6. Create a batch and post batch\nVerify the transaction responses. The first one will be COMMITTED and second one shoud be an invalid transaction. The third txn will be with error code 17 and Validator Timed Out", "13": "1.Create 5 independent Transactions for set\n2.Create second dependent transaction for set with 5 independent transactions as dependency\n3.Create third dependent Transaction for increment with second dependent Transaction as dependency     \n4.Create a batch for all the dependent transaction and post batch\n5.Check for the status\n6.Now create the batch for independent transactions and post batch\n7. Check for the response status of both independent and dependent transactions", "14": "1.Create a dependent transactions for increment\n2.Create a dependent transaction for set for the same key with first transaction as dependent                                                                                                                                                \n3.Create batch and post the first transaction(increment) first and check the response status\n4.Post the second transaction(set)  and check the response status", "15": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, fourth is depend on third and fifth is depend on fourth\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be COMMITTED.", "16": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, \nfourth is depend on third and fifth is depend on fourth. Fourth one will be an invalid txn\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be INVALID.", "17": "1.Create first batch having 3 transactions.\n2.Make third transaction invalid from first  batch.\n3.Create second batch having 2 transactions \n4.Make transaction from second batch dependent on transaction from first batch.\n5.post batch and check for the status.\n6.Create third batch having 2 transaction.\n7.Make transaction from third batch dependent on transaction from second batch.\n8.post batch and check for the status."}, "setup": {"duration": 0.0005779266357421875, "outcome": "passed"}, "call": {"duration": 0.012136697769165039, "outcome": "failed", "log": [{"name": "test_rest_api_dep_txns", "msg": "Starting test for batch post", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1492, "funcName": "test_inc_first_txn_dep", "created": 1552990409.0330877, "msecs": 33.087730407714844, "relativeCreated": 2529890.508413315, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:29"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with inc operations", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1504, "funcName": "test_inc_first_txn_dep", "created": 1552990409.0437624, "msecs": 43.7624454498291, "relativeCreated": 2529901.183128357, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:29"}, {"name": "test_rest_api_dep_txns", "msg": "Creating batches for transactions 1trn/batch", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1518, "funcName": "test_inc_first_txn_dep", "created": 1552990409.0444415, "msecs": 44.44146156311035, "relativeCreated": 2529901.86214447, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:29"}], "longrepr": "Fixture \"post_batch_txn\" called directly. Fixtures are not meant to be called directly,\nbut are created automatically when test functions request them as parameters.\nSee https://docs.pytest.org/en/latest/fixture.html for more information about fixtures, and\nhttps://docs.pytest.org/en/latest/deprecations.html#calling-fixtures-directly about how to update your code."}, "teardown": {"duration": 0.0006983280181884766, "outcome": "passed"}}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_Multiple_dep_Txn_Consecutive_dep", "lineno": 1575, "outcome": "failed", "keywords": ["run", "test_Multiple_dep_Txn_Consecutive_dep", "TestPostTansactionDependencies", "api_test", "dep_txns/test_rest_api_dep_txns.py", "sixth", "()", "dependent"], "metadata": {"0": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "1": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                                                             \n3. Create third Transaction for decrement with first and second Transaction as dependecies                                                            \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "2": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "3": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "4": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies\n3. Create third Transaction for increment with first and second Transaction as dependecies                                                                                                                \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "5": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single and same  dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "6": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with invalid Transaction as dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "7": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment reverse dependency                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "8": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies                                                                                                          \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This should be an invalid transaction. The third txn will be in PENDING state", "9": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies with different key                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This shoud be an invalid transaction. The trird txn will be in PENDING state", "10": "1. Create first Transaction for set with max value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "11": "1. Create first invalid Transaction for set with negative value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first invalid Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "12": "1. Create first Transaction for set                                                                                                                                                                                                                   \n2. Create second dependent Transaction for increment and make the address invalid with first Transaction as dependency     \n3. Create batch ,post batch and check the response status\n4. The second transaction will be an invalid transaction\n5. Create the third transaction for decrement with first and second as dependency \n6. Create a batch and post batch\nVerify the transaction responses. The first one will be COMMITTED and second one shoud be an invalid transaction. The third txn will be with error code 17 and Validator Timed Out", "13": "1.Create 5 independent Transactions for set\n2.Create second dependent transaction for set with 5 independent transactions as dependency\n3.Create third dependent Transaction for increment with second dependent Transaction as dependency     \n4.Create a batch for all the dependent transaction and post batch\n5.Check for the status\n6.Now create the batch for independent transactions and post batch\n7. Check for the response status of both independent and dependent transactions", "14": "1.Create a dependent transactions for increment\n2.Create a dependent transaction for set for the same key with first transaction as dependent                                                                                                                                                \n3.Create batch and post the first transaction(increment) first and check the response status\n4.Post the second transaction(set)  and check the response status", "15": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, fourth is depend on third and fifth is depend on fourth\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be COMMITTED.", "16": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, \nfourth is depend on third and fifth is depend on fourth. Fourth one will be an invalid txn\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be INVALID.", "17": "1.Create first batch having 3 transactions.\n2.Make third transaction invalid from first  batch.\n3.Create second batch having 2 transactions \n4.Make transaction from second batch dependent on transaction from first batch.\n5.post batch and check for the status.\n6.Create third batch having 2 transaction.\n7.Make transaction from third batch dependent on transaction from second batch.\n8.post batch and check for the status."}, "setup": {"duration": 0.0005762577056884766, "outcome": "passed"}, "call": {"duration": 0.012784242630004883, "outcome": "failed", "log": [{"name": "test_rest_api_dep_txns", "msg": "Starting test for batch post", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1583, "funcName": "test_Multiple_dep_Txn_Consecutive_dep", "created": 1552990409.0477104, "msecs": 47.710418701171875, "relativeCreated": 2529905.1311016083, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:29"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with set operations", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1595, "funcName": "test_Multiple_dep_Txn_Consecutive_dep", "created": 1552990409.0583665, "msecs": 58.36653709411621, "relativeCreated": 2529915.787220001, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:29"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with set operations with dependent transactions as first transaction", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1609, "funcName": "test_Multiple_dep_Txn_Consecutive_dep", "created": 1552990409.0590453, "msecs": 59.04531478881836, "relativeCreated": 2529916.465997696, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:29"}], "longrepr": "Fixture \"post_batch_txn\" called directly. Fixtures are not meant to be called directly,\nbut are created automatically when test functions request them as parameters.\nSee https://docs.pytest.org/en/latest/fixture.html for more information about fixtures, and\nhttps://docs.pytest.org/en/latest/deprecations.html#calling-fixtures-directly about how to update your code."}, "teardown": {"duration": 0.00030493736267089844, "outcome": "passed"}}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_Multiple_invalid_dep_Txn_Consecutive_dep", "lineno": 1678, "outcome": "failed", "keywords": ["run", "TestPostTansactionDependencies", "api_test", "test_Multiple_invalid_dep_Txn_Consecutive_dep", "dep_txns/test_rest_api_dep_txns.py", "sixth", "()", "dependent"], "metadata": {"0": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "1": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                                                             \n3. Create third Transaction for decrement with first and second Transaction as dependecies                                                            \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "2": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "3": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "4": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies\n3. Create third Transaction for increment with first and second Transaction as dependecies                                                                                                                \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "5": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single and same  dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "6": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with invalid Transaction as dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "7": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment reverse dependency                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "8": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies                                                                                                          \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This should be an invalid transaction. The third txn will be in PENDING state", "9": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies with different key                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This shoud be an invalid transaction. The trird txn will be in PENDING state", "10": "1. Create first Transaction for set with max value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "11": "1. Create first invalid Transaction for set with negative value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first invalid Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "12": "1. Create first Transaction for set                                                                                                                                                                                                                   \n2. Create second dependent Transaction for increment and make the address invalid with first Transaction as dependency     \n3. Create batch ,post batch and check the response status\n4. The second transaction will be an invalid transaction\n5. Create the third transaction for decrement with first and second as dependency \n6. Create a batch and post batch\nVerify the transaction responses. The first one will be COMMITTED and second one shoud be an invalid transaction. The third txn will be with error code 17 and Validator Timed Out", "13": "1.Create 5 independent Transactions for set\n2.Create second dependent transaction for set with 5 independent transactions as dependency\n3.Create third dependent Transaction for increment with second dependent Transaction as dependency     \n4.Create a batch for all the dependent transaction and post batch\n5.Check for the status\n6.Now create the batch for independent transactions and post batch\n7. Check for the response status of both independent and dependent transactions", "14": "1.Create a dependent transactions for increment\n2.Create a dependent transaction for set for the same key with first transaction as dependent                                                                                                                                                \n3.Create batch and post the first transaction(increment) first and check the response status\n4.Post the second transaction(set)  and check the response status", "15": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, fourth is depend on third and fifth is depend on fourth\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be COMMITTED.", "16": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, \nfourth is depend on third and fifth is depend on fourth. Fourth one will be an invalid txn\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be INVALID.", "17": "1.Create first batch having 3 transactions.\n2.Make third transaction invalid from first  batch.\n3.Create second batch having 2 transactions \n4.Make transaction from second batch dependent on transaction from first batch.\n5.post batch and check for the status.\n6.Create third batch having 2 transaction.\n7.Make transaction from third batch dependent on transaction from second batch.\n8.post batch and check for the status."}, "setup": {"duration": 0.0006082057952880859, "outcome": "passed"}, "call": {"duration": 0.012825965881347656, "outcome": "failed", "log": [{"name": "test_rest_api_dep_txns", "msg": "Starting test for batch post", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1687, "funcName": "test_Multiple_invalid_dep_Txn_Consecutive_dep", "created": 1552990409.0627217, "msecs": 62.72172927856445, "relativeCreated": 2529920.1424121857, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:29"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with set operations", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1699, "funcName": "test_Multiple_invalid_dep_Txn_Consecutive_dep", "created": 1552990409.0733678, "msecs": 73.36783409118652, "relativeCreated": 2529930.7885169983, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:29"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with set operations with dependent transactions as first transaction", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1713, "funcName": "test_Multiple_invalid_dep_Txn_Consecutive_dep", "created": 1552990409.0740647, "msecs": 74.06473159790039, "relativeCreated": 2529931.485414505, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:29"}], "longrepr": "Fixture \"post_batch_txn\" called directly. Fixtures are not meant to be called directly,\nbut are created automatically when test functions request them as parameters.\nSee https://docs.pytest.org/en/latest/fixture.html for more information about fixtures, and\nhttps://docs.pytest.org/en/latest/deprecations.html#calling-fixtures-directly about how to update your code."}, "teardown": {"duration": 0.0002982616424560547, "outcome": "passed"}}, {"nodeid": "dep_txns/test_rest_api_dep_txns.py::TestPostTansactionDependencies::test_separate_batch_txn_dep", "lineno": 1782, "outcome": "failed", "keywords": ["run", "TestPostTansactionDependencies", "api_test", "test_separate_batch_txn_dep", "dep_txns/test_rest_api_dep_txns.py", "sixth", "()", "dependent"], "metadata": {"0": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "1": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies                                                             \n3. Create third Transaction for decrement with first and second Transaction as dependecies                                                            \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "2": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "3": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single dependecies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "4": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment with first Transaction as dependecies\n3. Create third Transaction for increment with first and second Transaction as dependecies                                                                                                                \n4. Create Batch                                                                                                                                   \n5. Call POST /batches\nVerify the transactions", "5": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with single and same  dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "6": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for decrement with invalid Transaction as dependencies                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "7": "\"1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second Transaction for increment reverse dependency                           \n3. Create Batch                                                                                                                                   \n4. Call POST /batches \"\nVerify the transactions", "8": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies                                                                                                          \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This should be an invalid transaction. The third txn will be in PENDING state", "9": "1. Create first Transaction for set                                                                                                                                                                                                                      \n2. Create second invalid Transaction for increment with first Transaction as dependecies with different key                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. This shoud be an invalid transaction. The trird txn will be in PENDING state", "10": "1. Create first Transaction for set with max value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "11": "1. Create first invalid Transaction for set with negative value                                                                                                                                                                                                                   \n2. Create second Transaction for increment with first invalid Transaction as dependency                                                                                                      \n3. Create Batch                                                                                                                                   \n4. Call POST /batches\nVerify the transactions. The first one shoud be an invalid transaction. The second txn will be with error code 17 and Validator Timed Out", "12": "1. Create first Transaction for set                                                                                                                                                                                                                   \n2. Create second dependent Transaction for increment and make the address invalid with first Transaction as dependency     \n3. Create batch ,post batch and check the response status\n4. The second transaction will be an invalid transaction\n5. Create the third transaction for decrement with first and second as dependency \n6. Create a batch and post batch\nVerify the transaction responses. The first one will be COMMITTED and second one shoud be an invalid transaction. The third txn will be with error code 17 and Validator Timed Out", "13": "1.Create 5 independent Transactions for set\n2.Create second dependent transaction for set with 5 independent transactions as dependency\n3.Create third dependent Transaction for increment with second dependent Transaction as dependency     \n4.Create a batch for all the dependent transaction and post batch\n5.Check for the status\n6.Now create the batch for independent transactions and post batch\n7. Check for the response status of both independent and dependent transactions", "14": "1.Create a dependent transactions for increment\n2.Create a dependent transaction for set for the same key with first transaction as dependent                                                                                                                                                \n3.Create batch and post the first transaction(increment) first and check the response status\n4.Post the second transaction(set)  and check the response status", "15": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, fourth is depend on third and fifth is depend on fourth\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be COMMITTED.", "16": "1.Create 5 dependent transactions for set and second one is depend on first, third is depend on second, \nfourth is depend on third and fifth is depend on fourth. Fourth one will be an invalid txn\n2. Create a batch and post the fourth and fifth transactions.\n3. Check the response status. It should not be COMMITTED.\n4. Create batch and post first, second and third transactions and check the response status. It should be COMMITTED.\n5. Now check the response for the fourth and fifth transaction. It should be INVALID.", "17": "1.Create first batch having 3 transactions.\n2.Make third transaction invalid from first  batch.\n3.Create second batch having 2 transactions \n4.Make transaction from second batch dependent on transaction from first batch.\n5.post batch and check for the status.\n6.Create third batch having 2 transaction.\n7.Make transaction from third batch dependent on transaction from second batch.\n8.post batch and check for the status."}, "setup": {"duration": 0.0005812644958496094, "outcome": "passed"}, "call": {"duration": 0.012488603591918945, "outcome": "failed", "log": [{"name": "test_rest_api_dep_txns", "msg": "Starting test for batch post", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1794, "funcName": "test_separate_batch_txn_dep", "created": 1552990409.0777006, "msecs": 77.70061492919922, "relativeCreated": 2529935.1212978363, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:29"}, {"name": "test_rest_api_dep_txns", "msg": "Creating intkey transactions with set operations for first batch having one invalid transaction", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1807, "funcName": "test_separate_batch_txn_dep", "created": 1552990409.0884113, "msecs": 88.41133117675781, "relativeCreated": 2529945.832014084, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:29"}, {"name": "test_rest_api_dep_txns", "msg": "Creating first batch to the handlers", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/dep_txns/test_rest_api_dep_txns.py", "filename": "test_rest_api_dep_txns.py", "module": "test_rest_api_dep_txns", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 1824, "funcName": "test_separate_batch_txn_dep", "created": 1552990409.0893977, "msecs": 89.39766883850098, "relativeCreated": 2529946.8183517456, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:29"}], "longrepr": "Fixture \"post_batch_txn\" called directly. Fixtures are not meant to be called directly,\nbut are created automatically when test functions request them as parameters.\nSee https://docs.pytest.org/en/latest/fixture.html for more information about fixtures, and\nhttps://docs.pytest.org/en/latest/deprecations.html#calling-fixtures-directly about how to update your code."}, "teardown": {"duration": 0.0003230571746826172, "outcome": "passed"}}, {"nodeid": "get/test_rest_api_get_peers.py::TestPeerList::test_api_get_peer_list", "lineno": 49, "outcome": "failed", "keywords": ["get/test_rest_api_get_peers.py", "TestPeerList", "()", "api_test", "get", "test_api_get_peer_list", "peers"], "metadata": {"0": "This class tests the peer list with different parameters\n        "}, "setup": {"duration": 0.0008707046508789062, "outcome": "passed"}, "call": {"duration": 0.0012421607971191406, "outcome": "failed", "crash": {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]"}, "traceback": [{"path": "get/test_rest_api_get_peers.py", "lineno": 59, "message": ""}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 779, "message": "in __aenter__"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 319, "message": "in _request"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 418, "message": "in connect"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 736, "message": "in _create_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 855, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 838, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "ClientConnectorError"}], "longrepr": "self = <aiohttp.connector.TCPConnector object at 0x7fd5997b48d0>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd5997b46d8>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n>           return await self._loop.create_connection(*args, **kwargs)\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:800: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n                    yield from self.sock_connect(sock, address)\n                except OSError as exc:\n                    if sock is not None:\n                        sock.close()\n                    exceptions.append(exc)\n                except:\n                    if sock is not None:\n                        sock.close()\n                    raise\n                else:\n                    break\n            else:\n                if len(exceptions) == 1:\n>                   raise exceptions[0]\n\n/usr/lib/python3.6/asyncio/base_events.py:783: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n>                   yield from self.sock_connect(sock, address)\n\n/usr/lib/python3.6/asyncio/base_events.py:770: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>, sock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>\naddress = ('192.168.1.23', 8008)\n\n    @coroutine\n    def sock_connect(self, sock, address):\n        \"\"\"Connect to a remote socket at address.\n    \n        This method is a coroutine.\n        \"\"\"\n        if self._debug and sock.gettimeout() != 0:\n            raise ValueError(\"the socket must be non-blocking\")\n    \n        if not hasattr(socket, 'AF_UNIX') or sock.family != socket.AF_UNIX:\n            resolved = base_events._ensure_resolved(\n                address, family=sock.family, proto=sock.proto, loop=self)\n            if not resolved.done():\n                yield from resolved\n            _, _, _, _, address = resolved.result()[0]\n    \n        fut = self.create_future()\n        self._sock_connect(fut, sock, address)\n>       return (yield from fut)\n\n/usr/lib/python3.6/asyncio/selector_events.py:450: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nfut = <Future finished exception=ConnectionRefusedError(111, \"Connect call failed ('192.168.1.23', 8008)\")>\nsock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>, address = ('192.168.1.23', 8008)\n\n    def _sock_connect_cb(self, fut, sock, address):\n        if fut.cancelled():\n            return\n    \n        try:\n            err = sock.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)\n            if err != 0:\n                # Jump to any except clause below.\n>               raise OSError(err, 'Connect call failed %s' % (address,))\nE               ConnectionRefusedError: [Errno 111] Connect call failed ('192.168.1.23', 8008)\n\n/usr/lib/python3.6/asyncio/selector_events.py:480: ConnectionRefusedError\n\nThe above exception was the direct cause of the following exception:\n\nself = <test_rest_api_get_peers.TestPeerList object at 0x7fd599a63a20>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_get_peer_list(self, setup):\n    \n        \"\"\"This class tests the peer list with different parameters\n        \"\"\"\n        address = setup['address']\n        expected_link = '{}/peers'.format(address)\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n>               async with session.get(url='{}/peers'.format(address)) as data:\n\nget/test_rest_api_get_peers.py:59: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/usr/lib/python3/dist-packages/aiohttp/client.py:779: in __aenter__\n    self._resp = await self._coro\n/usr/lib/python3/dist-packages/aiohttp/client.py:319: in _request\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:418: in connect\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:736: in _create_connection\n    traces=None\n/usr/lib/python3/dist-packages/aiohttp/connector.py:855: in _create_direct_connection\n    raise last_exc\n/usr/lib/python3/dist-packages/aiohttp/connector.py:838: in _create_direct_connection\n    req=req, client_error=client_error)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <aiohttp.connector.TCPConnector object at 0x7fd5997b48d0>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd5997b46d8>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n            return await self._loop.create_connection(*args, **kwargs)\n        except certificate_errors as exc:\n            raise ClientConnectorCertificateError(\n                req.connection_key, exc) from exc\n        except ssl_errors as exc:\n            raise ClientConnectorSSLError(req.connection_key, exc) from exc\n        except OSError as exc:\n>           raise client_error(req.connection_key, exc) from exc\nE           aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:807: ClientConnectorError"}, "teardown": {"duration": 0.00026679039001464844, "outcome": "passed"}}, {"nodeid": "post/test_rest_api_post.py::TestPostList::test_rest_api_post_batch", "lineno": 124, "outcome": "failed", "keywords": ["TestPostList", "run", "post/test_rest_api_post.py", "post", "last", "api_test", "test_rest_api_post_batch", "()"], "metadata": {"0": "Tests that transactions are submitted and committed for\neach block that are created by submitting intkey batches\nwith set operations", "1": "\"Tests rest api by posting no batches\n        ", "2": "Tests rest api by posting with bad protobuf\n        ", "3": "Tests rest api by posting with wrong header\n        ", "4": "Tests the rest-api by submitting multiple transactions with same key\n        ", "5": "Tests rest-api state by submitting multiple\ntransactions in multiple batches", "6": "Tests rest-api state by submitting\ntransactions in empty transaction list", "7": "Tests rest-api state by submitting \ntransactions with different signer ", "8": "Tests rest-api state by submitting\ntransactions with no endpoint", "9": "Tests rest-api state by submitting invalid \ntransactions with invalid address ", "10": "Tests rest-api state by submitting invalid \ntransactions with minimum address length ", "11": "Tests rest-api state by submitting invalid \ntransactions with maximum address length ", "12": "Tests rest-api state by submitting valid \ntransactions with invalid transactions", "13": "Tests rest-api state by submitting invalid \ntransactions with valid transactions", "14": "Tests rest-api state by submitting invalid \ntransactions with same transactions", "15": "Tests rest-api state by submitting invalid \ntransactions with commit transactions", "16": "Tests rest-api state by submitting invalid \ntransactions with invalid bad  address ", "17": "Tests rest-api state by submitting invalid \ntransactions with invalid family name"}, "setup": {"duration": 0.00044226646423339844, "outcome": "passed"}, "call": {"duration": 0.013703107833862305, "outcome": "failed", "crash": {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]"}, "traceback": [{"path": "post/test_rest_api_post.py", "lineno": 175, "message": ""}, {"path": "post/test_rest_api_post.py", "lineno": 93, "message": "in async_post_batch"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 779, "message": "in __aenter__"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 319, "message": "in _request"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 418, "message": "in connect"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 736, "message": "in _create_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 855, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 838, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "ClientConnectorError"}], "log": [{"name": "test_rest_api_post", "msg": "Starting test for batch post", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/post/test_rest_api_post.py", "filename": "test_rest_api_post.py", "module": "test_rest_api_post", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 130, "funcName": "test_rest_api_post_batch", "created": 1552990409.212722, "msecs": 212.7220630645752, "relativeCreated": 2530070.1427459717, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:29"}, {"name": "test_rest_api_post", "msg": "Creating intkey transactions with set operations", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/post/test_rest_api_post.py", "filename": "test_rest_api_post.py", "module": "test_rest_api_post", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 139, "funcName": "test_rest_api_post_batch", "created": 1552990409.2154264, "msecs": 215.42644500732422, "relativeCreated": 2530072.8471279144, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:29"}, {"name": "test_rest_api_post", "msg": "Creating batches for transactions 1trn/batch", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/post/test_rest_api_post.py", "filename": "test_rest_api_post.py", "module": "test_rest_api_post", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 153, "funcName": "test_rest_api_post_batch", "created": 1552990409.224172, "msecs": 224.17211532592773, "relativeCreated": 2530081.592798233, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:29"}, {"name": "test_rest_api_post", "msg": "Submitting batches to the handlers", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/post/test_rest_api_post.py", "filename": "test_rest_api_post.py", "module": "test_rest_api_post", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 168, "funcName": "test_rest_api_post_batch", "created": 1552990409.2245908, "msecs": 224.59077835083008, "relativeCreated": 2530082.011461258, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:29"}], "longrepr": "self = <aiohttp.connector.TCPConnector object at 0x7fd59980e518>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd59980e860>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n>           return await self._loop.create_connection(*args, **kwargs)\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:800: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n                    yield from self.sock_connect(sock, address)\n                except OSError as exc:\n                    if sock is not None:\n                        sock.close()\n                    exceptions.append(exc)\n                except:\n                    if sock is not None:\n                        sock.close()\n                    raise\n                else:\n                    break\n            else:\n                if len(exceptions) == 1:\n>                   raise exceptions[0]\n\n/usr/lib/python3.6/asyncio/base_events.py:783: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n>                   yield from self.sock_connect(sock, address)\n\n/usr/lib/python3.6/asyncio/base_events.py:770: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>, sock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>\naddress = ('192.168.1.23', 8008)\n\n    @coroutine\n    def sock_connect(self, sock, address):\n        \"\"\"Connect to a remote socket at address.\n    \n        This method is a coroutine.\n        \"\"\"\n        if self._debug and sock.gettimeout() != 0:\n            raise ValueError(\"the socket must be non-blocking\")\n    \n        if not hasattr(socket, 'AF_UNIX') or sock.family != socket.AF_UNIX:\n            resolved = base_events._ensure_resolved(\n                address, family=sock.family, proto=sock.proto, loop=self)\n            if not resolved.done():\n                yield from resolved\n            _, _, _, _, address = resolved.result()[0]\n    \n        fut = self.create_future()\n        self._sock_connect(fut, sock, address)\n>       return (yield from fut)\n\n/usr/lib/python3.6/asyncio/selector_events.py:450: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nfut = <Future finished exception=ConnectionRefusedError(111, \"Connect call failed ('192.168.1.23', 8008)\")>\nsock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>, address = ('192.168.1.23', 8008)\n\n    def _sock_connect_cb(self, fut, sock, address):\n        if fut.cancelled():\n            return\n    \n        try:\n            err = sock.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)\n            if err != 0:\n                # Jump to any except clause below.\n>               raise OSError(err, 'Connect call failed %s' % (address,))\nE               ConnectionRefusedError: [Errno 111] Connect call failed ('192.168.1.23', 8008)\n\n/usr/lib/python3.6/asyncio/selector_events.py:480: ConnectionRefusedError\n\nThe above exception was the direct cause of the following exception:\n\nself = <test_rest_api_post.TestPostList object at 0x7fd59994ea20>\n\n    async def test_rest_api_post_batch(self):\n        \"\"\"Tests that transactions are submitted and committed for\n        each block that are created by submitting intkey batches\n        with set operations\n        \"\"\"\n        LOGGER.info('Starting test for batch post')\n    \n        signer = get_signer()\n        expected_trxn_ids  = []\n        expected_batch_ids = []\n        address = _get_client_address()\n        url='{}/batches'.format(address)\n        tasks=[]\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxn_ids.append(trxn_id)\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            data = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = data['header_signature']\n            expected_batch_ids.append(batch_id)\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                for batch in post_batch_list:\n                    task = asyncio.ensure_future(async_post_batch(url,session,data=batch))\n                    tasks.append(task)\n>               responses = await asyncio.gather(*tasks)\n\npost/test_rest_api_post.py:175: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npost/test_rest_api_post.py:93: in async_post_batch\n    async with session.post(url,data=data,headers=headers) as response:\n/usr/lib/python3/dist-packages/aiohttp/client.py:779: in __aenter__\n    self._resp = await self._coro\n/usr/lib/python3/dist-packages/aiohttp/client.py:319: in _request\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:418: in connect\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:736: in _create_connection\n    traces=None\n/usr/lib/python3/dist-packages/aiohttp/connector.py:855: in _create_direct_connection\n    raise last_exc\n/usr/lib/python3/dist-packages/aiohttp/connector.py:838: in _create_direct_connection\n    req=req, client_error=client_error)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <aiohttp.connector.TCPConnector object at 0x7fd59980e518>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd59980e860>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n            return await self._loop.create_connection(*args, **kwargs)\n        except certificate_errors as exc:\n            raise ClientConnectorCertificateError(\n                req.connection_key, exc) from exc\n        except ssl_errors as exc:\n            raise ClientConnectorSSLError(req.connection_key, exc) from exc\n        except OSError as exc:\n>           raise client_error(req.connection_key, exc) from exc\nE           aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:807: ClientConnectorError"}, "teardown": {"duration": 0.0003142356872558594, "outcome": "passed"}}, {"nodeid": "post/test_rest_api_post.py::TestPostList::test_rest_api_no_batches", "lineno": 206, "outcome": "failed", "keywords": ["TestPostList", "run", "post/test_rest_api_post.py", "post", "last", "api_test", "()", "test_rest_api_no_batches"], "metadata": {"0": "Tests that transactions are submitted and committed for\neach block that are created by submitting intkey batches\nwith set operations", "1": "\"Tests rest api by posting no batches\n        ", "2": "Tests rest api by posting with bad protobuf\n        ", "3": "Tests rest api by posting with wrong header\n        ", "4": "Tests the rest-api by submitting multiple transactions with same key\n        ", "5": "Tests rest-api state by submitting multiple\ntransactions in multiple batches", "6": "Tests rest-api state by submitting\ntransactions in empty transaction list", "7": "Tests rest-api state by submitting \ntransactions with different signer ", "8": "Tests rest-api state by submitting\ntransactions with no endpoint", "9": "Tests rest-api state by submitting invalid \ntransactions with invalid address ", "10": "Tests rest-api state by submitting invalid \ntransactions with minimum address length ", "11": "Tests rest-api state by submitting invalid \ntransactions with maximum address length ", "12": "Tests rest-api state by submitting valid \ntransactions with invalid transactions", "13": "Tests rest-api state by submitting invalid \ntransactions with valid transactions", "14": "Tests rest-api state by submitting invalid \ntransactions with same transactions", "15": "Tests rest-api state by submitting invalid \ntransactions with commit transactions", "16": "Tests rest-api state by submitting invalid \ntransactions with invalid bad  address ", "17": "Tests rest-api state by submitting invalid \ntransactions with invalid family name"}, "setup": {"duration": 0.0004684925079345703, "outcome": "passed"}, "call": {"duration": 0.004560232162475586, "outcome": "failed", "crash": {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]"}, "traceback": [{"path": "post/test_rest_api_post.py", "lineno": 219, "message": ""}, {"path": "post/test_rest_api_post.py", "lineno": 93, "message": "in async_post_batch"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 779, "message": "in __aenter__"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 319, "message": "in _request"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 418, "message": "in connect"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 736, "message": "in _create_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 855, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 838, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "ClientConnectorError"}], "log": [{"name": "test_rest_api_post", "msg": "Starting test for batch with bad protobuf", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/post/test_rest_api_post.py", "filename": "test_rest_api_post.py", "module": "test_rest_api_post", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 210, "funcName": "test_rest_api_no_batches", "created": 1552990409.3391683, "msecs": 339.1683101654053, "relativeCreated": 2530196.5889930725, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:29"}], "longrepr": "self = <aiohttp.connector.TCPConnector object at 0x7fd5998fbac8>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd5998fb860>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n>           return await self._loop.create_connection(*args, **kwargs)\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:800: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n                    yield from self.sock_connect(sock, address)\n                except OSError as exc:\n                    if sock is not None:\n                        sock.close()\n                    exceptions.append(exc)\n                except:\n                    if sock is not None:\n                        sock.close()\n                    raise\n                else:\n                    break\n            else:\n                if len(exceptions) == 1:\n>                   raise exceptions[0]\n\n/usr/lib/python3.6/asyncio/base_events.py:783: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n>                   yield from self.sock_connect(sock, address)\n\n/usr/lib/python3.6/asyncio/base_events.py:770: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>, sock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>\naddress = ('192.168.1.23', 8008)\n\n    @coroutine\n    def sock_connect(self, sock, address):\n        \"\"\"Connect to a remote socket at address.\n    \n        This method is a coroutine.\n        \"\"\"\n        if self._debug and sock.gettimeout() != 0:\n            raise ValueError(\"the socket must be non-blocking\")\n    \n        if not hasattr(socket, 'AF_UNIX') or sock.family != socket.AF_UNIX:\n            resolved = base_events._ensure_resolved(\n                address, family=sock.family, proto=sock.proto, loop=self)\n            if not resolved.done():\n                yield from resolved\n            _, _, _, _, address = resolved.result()[0]\n    \n        fut = self.create_future()\n        self._sock_connect(fut, sock, address)\n>       return (yield from fut)\n\n/usr/lib/python3.6/asyncio/selector_events.py:450: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nfut = <Future finished exception=ConnectionRefusedError(111, \"Connect call failed ('192.168.1.23', 8008)\")>\nsock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>, address = ('192.168.1.23', 8008)\n\n    def _sock_connect_cb(self, fut, sock, address):\n        if fut.cancelled():\n            return\n    \n        try:\n            err = sock.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)\n            if err != 0:\n                # Jump to any except clause below.\n>               raise OSError(err, 'Connect call failed %s' % (address,))\nE               ConnectionRefusedError: [Errno 111] Connect call failed ('192.168.1.23', 8008)\n\n/usr/lib/python3.6/asyncio/selector_events.py:480: ConnectionRefusedError\n\nThe above exception was the direct cause of the following exception:\n\nself = <test_rest_api_post.TestPostList object at 0x7fd5998fb5c0>\n\n    async def test_rest_api_no_batches(self):\n        \"\"\"\"Tests rest api by posting no batches\n        \"\"\"\n        LOGGER.info(\"Starting test for batch with bad protobuf\")\n        address = _get_client_address()\n        url='{}/batches'.format(address)\n        tasks=[]\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                task = asyncio.ensure_future(async_post_batch(url,session,data=EMPTY_BATCH))\n                tasks.append(task)\n>               response = await asyncio.gather(*tasks)\n\npost/test_rest_api_post.py:219: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npost/test_rest_api_post.py:93: in async_post_batch\n    async with session.post(url,data=data,headers=headers) as response:\n/usr/lib/python3/dist-packages/aiohttp/client.py:779: in __aenter__\n    self._resp = await self._coro\n/usr/lib/python3/dist-packages/aiohttp/client.py:319: in _request\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:418: in connect\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:736: in _create_connection\n    traces=None\n/usr/lib/python3/dist-packages/aiohttp/connector.py:855: in _create_direct_connection\n    raise last_exc\n/usr/lib/python3/dist-packages/aiohttp/connector.py:838: in _create_direct_connection\n    req=req, client_error=client_error)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <aiohttp.connector.TCPConnector object at 0x7fd5998fbac8>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd5998fb860>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n            return await self._loop.create_connection(*args, **kwargs)\n        except certificate_errors as exc:\n            raise ClientConnectorCertificateError(\n                req.connection_key, exc) from exc\n        except ssl_errors as exc:\n            raise ClientConnectorSSLError(req.connection_key, exc) from exc\n        except OSError as exc:\n>           raise client_error(req.connection_key, exc) from exc\nE           aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:807: ClientConnectorError"}, "teardown": {"duration": 0.0003116130828857422, "outcome": "passed"}}, {"nodeid": "post/test_rest_api_post.py::TestPostList::test_rest_api_bad_protobuf", "lineno": 224, "outcome": "failed", "keywords": ["TestPostList", "test_rest_api_bad_protobuf", "run", "post/test_rest_api_post.py", "post", "last", "api_test", "()"], "metadata": {"0": "Tests that transactions are submitted and committed for\neach block that are created by submitting intkey batches\nwith set operations", "1": "\"Tests rest api by posting no batches\n        ", "2": "Tests rest api by posting with bad protobuf\n        ", "3": "Tests rest api by posting with wrong header\n        ", "4": "Tests the rest-api by submitting multiple transactions with same key\n        ", "5": "Tests rest-api state by submitting multiple\ntransactions in multiple batches", "6": "Tests rest-api state by submitting\ntransactions in empty transaction list", "7": "Tests rest-api state by submitting \ntransactions with different signer ", "8": "Tests rest-api state by submitting\ntransactions with no endpoint", "9": "Tests rest-api state by submitting invalid \ntransactions with invalid address ", "10": "Tests rest-api state by submitting invalid \ntransactions with minimum address length ", "11": "Tests rest-api state by submitting invalid \ntransactions with maximum address length ", "12": "Tests rest-api state by submitting valid \ntransactions with invalid transactions", "13": "Tests rest-api state by submitting invalid \ntransactions with valid transactions", "14": "Tests rest-api state by submitting invalid \ntransactions with same transactions", "15": "Tests rest-api state by submitting invalid \ntransactions with commit transactions", "16": "Tests rest-api state by submitting invalid \ntransactions with invalid bad  address ", "17": "Tests rest-api state by submitting invalid \ntransactions with invalid family name"}, "setup": {"duration": 0.000457763671875, "outcome": "passed"}, "call": {"duration": 0.004575967788696289, "outcome": "failed", "crash": {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]"}, "traceback": [{"path": "post/test_rest_api_post.py", "lineno": 238, "message": ""}, {"path": "post/test_rest_api_post.py", "lineno": 93, "message": "in async_post_batch"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 779, "message": "in __aenter__"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 319, "message": "in _request"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 418, "message": "in connect"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 736, "message": "in _create_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 855, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 838, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "ClientConnectorError"}], "log": [{"name": "test_rest_api_post", "msg": "Starting test for batch with bad protobuf", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/post/test_rest_api_post.py", "filename": "test_rest_api_post.py", "module": "test_rest_api_post", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 228, "funcName": "test_rest_api_bad_protobuf", "created": 1552990409.47749, "msecs": 477.4899482727051, "relativeCreated": 2530334.91063118, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:29"}], "longrepr": "self = <aiohttp.connector.TCPConnector object at 0x7fd599890198>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd5998901d0>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n>           return await self._loop.create_connection(*args, **kwargs)\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:800: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n                    yield from self.sock_connect(sock, address)\n                except OSError as exc:\n                    if sock is not None:\n                        sock.close()\n                    exceptions.append(exc)\n                except:\n                    if sock is not None:\n                        sock.close()\n                    raise\n                else:\n                    break\n            else:\n                if len(exceptions) == 1:\n>                   raise exceptions[0]\n\n/usr/lib/python3.6/asyncio/base_events.py:783: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n>                   yield from self.sock_connect(sock, address)\n\n/usr/lib/python3.6/asyncio/base_events.py:770: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>, sock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>\naddress = ('192.168.1.23', 8008)\n\n    @coroutine\n    def sock_connect(self, sock, address):\n        \"\"\"Connect to a remote socket at address.\n    \n        This method is a coroutine.\n        \"\"\"\n        if self._debug and sock.gettimeout() != 0:\n            raise ValueError(\"the socket must be non-blocking\")\n    \n        if not hasattr(socket, 'AF_UNIX') or sock.family != socket.AF_UNIX:\n            resolved = base_events._ensure_resolved(\n                address, family=sock.family, proto=sock.proto, loop=self)\n            if not resolved.done():\n                yield from resolved\n            _, _, _, _, address = resolved.result()[0]\n    \n        fut = self.create_future()\n        self._sock_connect(fut, sock, address)\n>       return (yield from fut)\n\n/usr/lib/python3.6/asyncio/selector_events.py:450: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nfut = <Future finished exception=ConnectionRefusedError(111, \"Connect call failed ('192.168.1.23', 8008)\")>\nsock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>, address = ('192.168.1.23', 8008)\n\n    def _sock_connect_cb(self, fut, sock, address):\n        if fut.cancelled():\n            return\n    \n        try:\n            err = sock.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)\n            if err != 0:\n                # Jump to any except clause below.\n>               raise OSError(err, 'Connect call failed %s' % (address,))\nE               ConnectionRefusedError: [Errno 111] Connect call failed ('192.168.1.23', 8008)\n\n/usr/lib/python3.6/asyncio/selector_events.py:480: ConnectionRefusedError\n\nThe above exception was the direct cause of the following exception:\n\nself = <test_rest_api_post.TestPostList object at 0x7fd599890630>\n\n    async def test_rest_api_bad_protobuf(self):\n        \"\"\"Tests rest api by posting with bad protobuf\n        \"\"\"\n        LOGGER.info(\"Starting test for batch with bad protobuf\")\n    \n        address = _get_client_address()\n        url='{}/batches'.format(address)\n        tasks=[]\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                task = asyncio.ensure_future(async_post_batch(url,session,data=BAD_PROTOBUF))\n                tasks.append(task)\n>               response = await asyncio.gather(*tasks)\n\npost/test_rest_api_post.py:238: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npost/test_rest_api_post.py:93: in async_post_batch\n    async with session.post(url,data=data,headers=headers) as response:\n/usr/lib/python3/dist-packages/aiohttp/client.py:779: in __aenter__\n    self._resp = await self._coro\n/usr/lib/python3/dist-packages/aiohttp/client.py:319: in _request\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:418: in connect\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:736: in _create_connection\n    traces=None\n/usr/lib/python3/dist-packages/aiohttp/connector.py:855: in _create_direct_connection\n    raise last_exc\n/usr/lib/python3/dist-packages/aiohttp/connector.py:838: in _create_direct_connection\n    req=req, client_error=client_error)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <aiohttp.connector.TCPConnector object at 0x7fd599890198>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd5998901d0>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n            return await self._loop.create_connection(*args, **kwargs)\n        except certificate_errors as exc:\n            raise ClientConnectorCertificateError(\n                req.connection_key, exc) from exc\n        except ssl_errors as exc:\n            raise ClientConnectorSSLError(req.connection_key, exc) from exc\n        except OSError as exc:\n>           raise client_error(req.connection_key, exc) from exc\nE           aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:807: ClientConnectorError"}, "teardown": {"duration": 0.00031256675720214844, "outcome": "passed"}}, {"nodeid": "post/test_rest_api_post.py::TestPostList::test_rest_api_post_wrong_header", "lineno": 243, "outcome": "failed", "keywords": ["test_rest_api_post_wrong_header", "TestPostList", "run", "post/test_rest_api_post.py", "post", "last", "api_test", "()"], "metadata": {"0": "Tests that transactions are submitted and committed for\neach block that are created by submitting intkey batches\nwith set operations", "1": "\"Tests rest api by posting no batches\n        ", "2": "Tests rest api by posting with bad protobuf\n        ", "3": "Tests rest api by posting with wrong header\n        ", "4": "Tests the rest-api by submitting multiple transactions with same key\n        ", "5": "Tests rest-api state by submitting multiple\ntransactions in multiple batches", "6": "Tests rest-api state by submitting\ntransactions in empty transaction list", "7": "Tests rest-api state by submitting \ntransactions with different signer ", "8": "Tests rest-api state by submitting\ntransactions with no endpoint", "9": "Tests rest-api state by submitting invalid \ntransactions with invalid address ", "10": "Tests rest-api state by submitting invalid \ntransactions with minimum address length ", "11": "Tests rest-api state by submitting invalid \ntransactions with maximum address length ", "12": "Tests rest-api state by submitting valid \ntransactions with invalid transactions", "13": "Tests rest-api state by submitting invalid \ntransactions with valid transactions", "14": "Tests rest-api state by submitting invalid \ntransactions with same transactions", "15": "Tests rest-api state by submitting invalid \ntransactions with commit transactions", "16": "Tests rest-api state by submitting invalid \ntransactions with invalid bad  address ", "17": "Tests rest-api state by submitting invalid \ntransactions with invalid family name"}, "setup": {"duration": 0.0005092620849609375, "outcome": "passed"}, "call": {"duration": 0.013762950897216797, "outcome": "failed", "crash": {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]"}, "traceback": [{"path": "post/test_rest_api_post.py", "lineno": 293, "message": ""}, {"path": "post/test_rest_api_post.py", "lineno": 93, "message": "in async_post_batch"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 779, "message": "in __aenter__"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 319, "message": "in _request"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 418, "message": "in connect"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 736, "message": "in _create_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 855, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 838, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "ClientConnectorError"}], "log": [{"name": "test_rest_api_post", "msg": "Starting test for batch post", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/post/test_rest_api_post.py", "filename": "test_rest_api_post.py", "module": "test_rest_api_post", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 247, "funcName": "test_rest_api_post_wrong_header", "created": 1552990409.5950663, "msecs": 595.0663089752197, "relativeCreated": 2530452.4869918823, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:29"}, {"name": "test_rest_api_post", "msg": "Creating intkey transactions with set operations", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/post/test_rest_api_post.py", "filename": "test_rest_api_post.py", "module": "test_rest_api_post", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 257, "funcName": "test_rest_api_post_wrong_header", "created": 1552990409.5977802, "msecs": 597.7802276611328, "relativeCreated": 2530455.2009105682, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:29"}, {"name": "test_rest_api_post", "msg": "Creating batches for transactions 1trn/batch", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/post/test_rest_api_post.py", "filename": "test_rest_api_post.py", "module": "test_rest_api_post", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 271, "funcName": "test_rest_api_post_wrong_header", "created": 1552990409.6065285, "msecs": 606.5285205841064, "relativeCreated": 2530463.949203491, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:29"}, {"name": "test_rest_api_post", "msg": "Submitting batches to the handlers", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/post/test_rest_api_post.py", "filename": "test_rest_api_post.py", "module": "test_rest_api_post", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 286, "funcName": "test_rest_api_post_wrong_header", "created": 1552990409.6069455, "msecs": 606.9455146789551, "relativeCreated": 2530464.366197586, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:29"}], "longrepr": "self = <aiohttp.connector.TCPConnector object at 0x7fd599b7d518>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd599b7db00>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n>           return await self._loop.create_connection(*args, **kwargs)\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:800: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n                    yield from self.sock_connect(sock, address)\n                except OSError as exc:\n                    if sock is not None:\n                        sock.close()\n                    exceptions.append(exc)\n                except:\n                    if sock is not None:\n                        sock.close()\n                    raise\n                else:\n                    break\n            else:\n                if len(exceptions) == 1:\n>                   raise exceptions[0]\n\n/usr/lib/python3.6/asyncio/base_events.py:783: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n>                   yield from self.sock_connect(sock, address)\n\n/usr/lib/python3.6/asyncio/base_events.py:770: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>, sock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>\naddress = ('192.168.1.23', 8008)\n\n    @coroutine\n    def sock_connect(self, sock, address):\n        \"\"\"Connect to a remote socket at address.\n    \n        This method is a coroutine.\n        \"\"\"\n        if self._debug and sock.gettimeout() != 0:\n            raise ValueError(\"the socket must be non-blocking\")\n    \n        if not hasattr(socket, 'AF_UNIX') or sock.family != socket.AF_UNIX:\n            resolved = base_events._ensure_resolved(\n                address, family=sock.family, proto=sock.proto, loop=self)\n            if not resolved.done():\n                yield from resolved\n            _, _, _, _, address = resolved.result()[0]\n    \n        fut = self.create_future()\n        self._sock_connect(fut, sock, address)\n>       return (yield from fut)\n\n/usr/lib/python3.6/asyncio/selector_events.py:450: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nfut = <Future finished exception=ConnectionRefusedError(111, \"Connect call failed ('192.168.1.23', 8008)\")>\nsock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>, address = ('192.168.1.23', 8008)\n\n    def _sock_connect_cb(self, fut, sock, address):\n        if fut.cancelled():\n            return\n    \n        try:\n            err = sock.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)\n            if err != 0:\n                # Jump to any except clause below.\n>               raise OSError(err, 'Connect call failed %s' % (address,))\nE               ConnectionRefusedError: [Errno 111] Connect call failed ('192.168.1.23', 8008)\n\n/usr/lib/python3.6/asyncio/selector_events.py:480: ConnectionRefusedError\n\nThe above exception was the direct cause of the following exception:\n\nself = <test_rest_api_post.TestPostList object at 0x7fd599919518>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_rest_api_post_wrong_header(self,setup):\n        \"\"\"Tests rest api by posting with wrong header\n        \"\"\"\n        LOGGER.info('Starting test for batch post')\n    \n        signer = get_signer()\n        expected_trxn_ids  = []\n        expected_batch_ids = []\n        address = _get_client_address()\n        url='{}/batches'.format(address)\n        tasks=[]\n        headers = {'Content-Type': 'application/json'}\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxn_ids.append(trxn_id)\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            data = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = data['header_signature']\n            expected_batch_ids.append(batch_id)\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                for batch in post_batch_list:\n                    task = asyncio.ensure_future(async_post_batch(url,session,data=batch,headers=headers))\n                    tasks.append(task)\n>               responses = await asyncio.gather(*tasks)\n\npost/test_rest_api_post.py:293: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npost/test_rest_api_post.py:93: in async_post_batch\n    async with session.post(url,data=data,headers=headers) as response:\n/usr/lib/python3/dist-packages/aiohttp/client.py:779: in __aenter__\n    self._resp = await self._coro\n/usr/lib/python3/dist-packages/aiohttp/client.py:319: in _request\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:418: in connect\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:736: in _create_connection\n    traces=None\n/usr/lib/python3/dist-packages/aiohttp/connector.py:855: in _create_direct_connection\n    raise last_exc\n/usr/lib/python3/dist-packages/aiohttp/connector.py:838: in _create_direct_connection\n    req=req, client_error=client_error)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <aiohttp.connector.TCPConnector object at 0x7fd599b7d518>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd599b7db00>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n            return await self._loop.create_connection(*args, **kwargs)\n        except certificate_errors as exc:\n            raise ClientConnectorCertificateError(\n                req.connection_key, exc) from exc\n        except ssl_errors as exc:\n            raise ClientConnectorSSLError(req.connection_key, exc) from exc\n        except OSError as exc:\n>           raise client_error(req.connection_key, exc) from exc\nE           aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:807: ClientConnectorError"}, "teardown": {"duration": 0.00030732154846191406, "outcome": "passed"}}, {"nodeid": "post/test_rest_api_post.py::TestPostList::test_rest_api_post_same_txns", "lineno": 299, "outcome": "failed", "keywords": ["TestPostList", "run", "post/test_rest_api_post.py", "test_rest_api_post_same_txns", "post", "last", "api_test", "()"], "metadata": {"0": "Tests that transactions are submitted and committed for\neach block that are created by submitting intkey batches\nwith set operations", "1": "\"Tests rest api by posting no batches\n        ", "2": "Tests rest api by posting with bad protobuf\n        ", "3": "Tests rest api by posting with wrong header\n        ", "4": "Tests the rest-api by submitting multiple transactions with same key\n        ", "5": "Tests rest-api state by submitting multiple\ntransactions in multiple batches", "6": "Tests rest-api state by submitting\ntransactions in empty transaction list", "7": "Tests rest-api state by submitting \ntransactions with different signer ", "8": "Tests rest-api state by submitting\ntransactions with no endpoint", "9": "Tests rest-api state by submitting invalid \ntransactions with invalid address ", "10": "Tests rest-api state by submitting invalid \ntransactions with minimum address length ", "11": "Tests rest-api state by submitting invalid \ntransactions with maximum address length ", "12": "Tests rest-api state by submitting valid \ntransactions with invalid transactions", "13": "Tests rest-api state by submitting invalid \ntransactions with valid transactions", "14": "Tests rest-api state by submitting invalid \ntransactions with same transactions", "15": "Tests rest-api state by submitting invalid \ntransactions with commit transactions", "16": "Tests rest-api state by submitting invalid \ntransactions with invalid bad  address ", "17": "Tests rest-api state by submitting invalid \ntransactions with invalid family name"}, "setup": {"duration": 0.0005249977111816406, "outcome": "passed"}, "call": {"duration": 0.006189107894897461, "outcome": "failed", "crash": {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1320, "message": "urllib.error.URLError: <urlopen error [Errno 111] Connection refused>"}, "traceback": [{"path": "post/test_rest_api_post.py", "lineno": 310, "message": ""}, {"path": "utils.py", "lineno": 358, "message": "in state_count"}, {"path": "utils.py", "lineno": 160, "message": "in get_state_list"}, {"path": "utils.py", "lineno": 183, "message": "in query_rest_api"}, {"path": "utils.py", "lineno": 186, "message": "in submit_request"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 223, "message": "in urlopen"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 526, "message": "in open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 544, "message": "in _open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 504, "message": "in _call_chain"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1346, "message": "in http_open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1320, "message": "URLError"}], "log": [{"name": "test_rest_api_post", "msg": "Starting test for batch post", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/post/test_rest_api_post.py", "filename": "test_rest_api_post.py", "module": "test_rest_api_post", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 303, "funcName": "test_rest_api_post_same_txns", "created": 1552990409.7218862, "msecs": 721.886157989502, "relativeCreated": 2530579.3068408966, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:29"}], "longrepr": "self = <urllib.request.HTTPHandler object at 0x7fd599cb66d8>, http_class = <class 'http.client.HTTPConnection'>, req = <urllib.request.Request object at 0x7fd599683080>\nhttp_conn_args = {}, host = '192.168.1.23:8008', h = <http.client.HTTPConnection object at 0x7fd599a3c8d0>\n\n    def do_open(self, http_class, req, **http_conn_args):\n        \"\"\"Return an HTTPResponse object for the request, using http_class.\n    \n        http_class must implement the HTTPConnection API from http.client.\n        \"\"\"\n        host = req.host\n        if not host:\n            raise URLError('no host given')\n    \n        # will parse host:port\n        h = http_class(host, timeout=req.timeout, **http_conn_args)\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # TODO(jhylton): Should this be redesigned to handle\n        # persistent connections?\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict((name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            try:\n                h.request(req.get_method(), req.selector, req.data, headers,\n>                         encode_chunked=req.has_header('Transfer-encoding'))\n\n/usr/lib/python3.6/urllib/request.py:1318: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599a3c8d0>, method = 'GET', url = '/state', body = None\nheaders = {'Connection': 'close', 'Host': '192.168.1.23:8008', 'User-Agent': 'Python-urllib/3.6'}\n\n    def request(self, method, url, body=None, headers={}, *,\n                encode_chunked=False):\n        \"\"\"Send a complete request to the server.\"\"\"\n>       self._send_request(method, url, body, headers, encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1239: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599a3c8d0>, method = 'GET', url = '/state', body = None\nheaders = {'Connection': 'close', 'Host': '192.168.1.23:8008', 'User-Agent': 'Python-urllib/3.6'}, encode_chunked = False\n\n    def _send_request(self, method, url, body, headers, encode_chunked):\n        # Honor explicitly requested Host: and Accept-Encoding: headers.\n        header_names = frozenset(k.lower() for k in headers)\n        skips = {}\n        if 'host' in header_names:\n            skips['skip_host'] = 1\n        if 'accept-encoding' in header_names:\n            skips['skip_accept_encoding'] = 1\n    \n        self.putrequest(method, url, **skips)\n    \n        # chunked encoding will happen if HTTP/1.1 is used and either\n        # the caller passes encode_chunked=True or the following\n        # conditions hold:\n        # 1. content-length has not been explicitly set\n        # 2. the body is a file or iterable, but not a str or bytes-like\n        # 3. Transfer-Encoding has NOT been explicitly set by the caller\n    \n        if 'content-length' not in header_names:\n            # only chunk body if not explicitly set for backwards\n            # compatibility, assuming the client code is already handling the\n            # chunking\n            if 'transfer-encoding' not in header_names:\n                # if content-length cannot be automatically determined, fall\n                # back to chunked encoding\n                encode_chunked = False\n                content_length = self._get_content_length(body, method)\n                if content_length is None:\n                    if body is not None:\n                        if self.debuglevel > 0:\n                            print('Unable to determine size of %r' % body)\n                        encode_chunked = True\n                        self.putheader('Transfer-Encoding', 'chunked')\n                else:\n                    self.putheader('Content-Length', str(content_length))\n        else:\n            encode_chunked = False\n    \n        for hdr, value in headers.items():\n            self.putheader(hdr, value)\n        if isinstance(body, str):\n            # RFC 2616 Section 3.7.1 says that text default has a\n            # default charset of iso-8859-1.\n            body = _encode(body, 'body')\n>       self.endheaders(body, encode_chunked=encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1285: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599a3c8d0>, message_body = None\n\n    def endheaders(self, message_body=None, *, encode_chunked=False):\n        \"\"\"Indicate that the last header line has been sent to the server.\n    \n        This method sends the request to the server.  The optional message_body\n        argument can be used to pass a message body associated with the\n        request.\n        \"\"\"\n        if self.__state == _CS_REQ_STARTED:\n            self.__state = _CS_REQ_SENT\n        else:\n            raise CannotSendHeader()\n>       self._send_output(message_body, encode_chunked=encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1234: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599a3c8d0>, message_body = None, encode_chunked = False\n\n    def _send_output(self, message_body=None, encode_chunked=False):\n        \"\"\"Send the currently buffered request and clear the buffer.\n    \n        Appends an extra \\\\r\\\\n to the buffer.\n        A message_body may be specified, to be appended to the request.\n        \"\"\"\n        self._buffer.extend((b\"\", b\"\"))\n        msg = b\"\\r\\n\".join(self._buffer)\n        del self._buffer[:]\n>       self.send(msg)\n\n/usr/lib/python3.6/http/client.py:1026: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599a3c8d0>\ndata = b'GET /state HTTP/1.1\\r\\nAccept-Encoding: identity\\r\\nHost: 192.168.1.23:8008\\r\\nUser-Agent: Python-urllib/3.6\\r\\nConnection: close\\r\\n\\r\\n'\n\n    def send(self, data):\n        \"\"\"Send `data' to the server.\n        ``data`` can be a string object, a bytes object, an array object, a\n        file-like object that supports a .read() method, or an iterable object.\n        \"\"\"\n    \n        if self.sock is None:\n            if self.auto_open:\n>               self.connect()\n\n/usr/lib/python3.6/http/client.py:964: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599a3c8d0>\n\n    def connect(self):\n        \"\"\"Connect to the host and port specified in __init__.\"\"\"\n        self.sock = self._create_connection(\n>           (self.host,self.port), self.timeout, self.source_address)\n\n/usr/lib/python3.6/http/client.py:936: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('192.168.1.23', 8008), timeout = <object object at 0x7fd5a15eb580>, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n                sock.connect(sa)\n                # Break explicitly a reference cycle\n                err = None\n                return sock\n    \n            except error as _:\n                err = _\n                if sock is not None:\n                    sock.close()\n    \n        if err is not None:\n>           raise err\n\n/usr/lib/python3.6/socket.py:724: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('192.168.1.23', 8008), timeout = <object object at 0x7fd5a15eb580>, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [Errno 111] Connection refused\n\n/usr/lib/python3.6/socket.py:713: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_rest_api_post.TestPostList object at 0x7fd599683d68>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_rest_api_post_same_txns(self, setup):\n        \"\"\"Tests the rest-api by submitting multiple transactions with same key\n        \"\"\"\n        LOGGER.info('Starting test for batch post')\n        address = _get_client_address()\n        url='{}/batches'.format(address)\n        tasks=[]\n        signer = get_signer()\n        expected_trxn_ids  = []\n        expected_batch_ids = []\n>       initial_state_length = state_count()\n\npost/test_rest_api_post.py:310: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nutils.py:358: in state_count\n    state_list = get_state_list()\nutils.py:160: in get_state_list\n    response = query_rest_api('/state')\nutils.py:183: in query_rest_api\n    return submit_request(urllib.request.Request(url, data, headers))\nutils.py:186: in submit_request\n    response = urllib.request.urlopen(request).read().decode('utf-8')\n/usr/lib/python3.6/urllib/request.py:223: in urlopen\n    return opener.open(url, data, timeout)\n/usr/lib/python3.6/urllib/request.py:526: in open\n    response = self._open(req, data)\n/usr/lib/python3.6/urllib/request.py:544: in _open\n    '_open', req)\n/usr/lib/python3.6/urllib/request.py:504: in _call_chain\n    result = func(*args)\n/usr/lib/python3.6/urllib/request.py:1346: in http_open\n    return self.do_open(http.client.HTTPConnection, req)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib.request.HTTPHandler object at 0x7fd599cb66d8>, http_class = <class 'http.client.HTTPConnection'>, req = <urllib.request.Request object at 0x7fd599683080>\nhttp_conn_args = {}, host = '192.168.1.23:8008', h = <http.client.HTTPConnection object at 0x7fd599a3c8d0>\n\n    def do_open(self, http_class, req, **http_conn_args):\n        \"\"\"Return an HTTPResponse object for the request, using http_class.\n    \n        http_class must implement the HTTPConnection API from http.client.\n        \"\"\"\n        host = req.host\n        if not host:\n            raise URLError('no host given')\n    \n        # will parse host:port\n        h = http_class(host, timeout=req.timeout, **http_conn_args)\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # TODO(jhylton): Should this be redesigned to handle\n        # persistent connections?\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict((name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            try:\n                h.request(req.get_method(), req.selector, req.data, headers,\n                          encode_chunked=req.has_header('Transfer-encoding'))\n            except OSError as err: # timeout error\n>               raise URLError(err)\nE               urllib.error.URLError: <urlopen error [Errno 111] Connection refused>\n\n/usr/lib/python3.6/urllib/request.py:1320: URLError"}, "teardown": {"duration": 0.0002837181091308594, "outcome": "passed"}}, {"nodeid": "post/test_rest_api_post.py::TestPostList::test_rest_api_multiple_txns_batches", "lineno": 353, "outcome": "failed", "keywords": ["TestPostList", "run", "post/test_rest_api_post.py", "test_rest_api_multiple_txns_batches", "post", "last", "api_test", "()"], "metadata": {"0": "Tests that transactions are submitted and committed for\neach block that are created by submitting intkey batches\nwith set operations", "1": "\"Tests rest api by posting no batches\n        ", "2": "Tests rest api by posting with bad protobuf\n        ", "3": "Tests rest api by posting with wrong header\n        ", "4": "Tests the rest-api by submitting multiple transactions with same key\n        ", "5": "Tests rest-api state by submitting multiple\ntransactions in multiple batches", "6": "Tests rest-api state by submitting\ntransactions in empty transaction list", "7": "Tests rest-api state by submitting \ntransactions with different signer ", "8": "Tests rest-api state by submitting\ntransactions with no endpoint", "9": "Tests rest-api state by submitting invalid \ntransactions with invalid address ", "10": "Tests rest-api state by submitting invalid \ntransactions with minimum address length ", "11": "Tests rest-api state by submitting invalid \ntransactions with maximum address length ", "12": "Tests rest-api state by submitting valid \ntransactions with invalid transactions", "13": "Tests rest-api state by submitting invalid \ntransactions with valid transactions", "14": "Tests rest-api state by submitting invalid \ntransactions with same transactions", "15": "Tests rest-api state by submitting invalid \ntransactions with commit transactions", "16": "Tests rest-api state by submitting invalid \ntransactions with invalid bad  address ", "17": "Tests rest-api state by submitting invalid \ntransactions with invalid family name"}, "setup": {"duration": 0.0004911422729492188, "outcome": "passed"}, "call": {"duration": 0.021512985229492188, "outcome": "failed", "crash": {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]"}, "traceback": [{"path": "post/test_rest_api_post.py", "lineno": 404, "message": ""}, {"path": "post/test_rest_api_post.py", "lineno": 93, "message": "in async_post_batch"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 779, "message": "in __aenter__"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 319, "message": "in _request"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 418, "message": "in connect"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 736, "message": "in _create_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 855, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 838, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "ClientConnectorError"}], "log": [{"name": "test_rest_api_post", "msg": "Starting test for batch post", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/post/test_rest_api_post.py", "filename": "test_rest_api_post.py", "module": "test_rest_api_post", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 358, "funcName": "test_rest_api_multiple_txns_batches", "created": 1552990409.9668782, "msecs": 966.8781757354736, "relativeCreated": 2530824.2988586426, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:29"}, {"name": "test_rest_api_post", "msg": "Creating intkey transactions with set operations", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/post/test_rest_api_post.py", "filename": "test_rest_api_post.py", "module": "test_rest_api_post", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 367, "funcName": "test_rest_api_multiple_txns_batches", "created": 1552990409.969568, "msecs": 969.5680141448975, "relativeCreated": 2530826.988697052, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:29"}, {"name": "test_rest_api_post", "msg": "Creating batches for transactions 1trn/batch", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/post/test_rest_api_post.py", "filename": "test_rest_api_post.py", "module": "test_rest_api_post", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 382, "funcName": "test_rest_api_multiple_txns_batches", "created": 1552990409.9855368, "msecs": 985.5368137359619, "relativeCreated": 2530842.957496643, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:29"}, {"name": "test_rest_api_post", "msg": "Submitting batches to the handlers", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/post/test_rest_api_post.py", "filename": "test_rest_api_post.py", "module": "test_rest_api_post", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 397, "funcName": "test_rest_api_multiple_txns_batches", "created": 1552990409.986166, "msecs": 986.1660003662109, "relativeCreated": 2530843.5866832733, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:29"}], "longrepr": "self = <aiohttp.connector.TCPConnector object at 0x7fd5994f2278>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd5994f2f28>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n>           return await self._loop.create_connection(*args, **kwargs)\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:800: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n                    yield from self.sock_connect(sock, address)\n                except OSError as exc:\n                    if sock is not None:\n                        sock.close()\n                    exceptions.append(exc)\n                except:\n                    if sock is not None:\n                        sock.close()\n                    raise\n                else:\n                    break\n            else:\n                if len(exceptions) == 1:\n>                   raise exceptions[0]\n\n/usr/lib/python3.6/asyncio/base_events.py:783: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n>                   yield from self.sock_connect(sock, address)\n\n/usr/lib/python3.6/asyncio/base_events.py:770: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>, sock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>\naddress = ('192.168.1.23', 8008)\n\n    @coroutine\n    def sock_connect(self, sock, address):\n        \"\"\"Connect to a remote socket at address.\n    \n        This method is a coroutine.\n        \"\"\"\n        if self._debug and sock.gettimeout() != 0:\n            raise ValueError(\"the socket must be non-blocking\")\n    \n        if not hasattr(socket, 'AF_UNIX') or sock.family != socket.AF_UNIX:\n            resolved = base_events._ensure_resolved(\n                address, family=sock.family, proto=sock.proto, loop=self)\n            if not resolved.done():\n                yield from resolved\n            _, _, _, _, address = resolved.result()[0]\n    \n        fut = self.create_future()\n        self._sock_connect(fut, sock, address)\n>       return (yield from fut)\n\n/usr/lib/python3.6/asyncio/selector_events.py:450: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nfut = <Future finished exception=ConnectionRefusedError(111, \"Connect call failed ('192.168.1.23', 8008)\")>\nsock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>, address = ('192.168.1.23', 8008)\n\n    def _sock_connect_cb(self, fut, sock, address):\n        if fut.cancelled():\n            return\n    \n        try:\n            err = sock.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)\n            if err != 0:\n                # Jump to any except clause below.\n>               raise OSError(err, 'Connect call failed %s' % (address,))\nE               ConnectionRefusedError: [Errno 111] Connect call failed ('192.168.1.23', 8008)\n\n/usr/lib/python3.6/asyncio/selector_events.py:480: ConnectionRefusedError\n\nThe above exception was the direct cause of the following exception:\n\nself = <test_rest_api_post.TestPostList object at 0x7fd599849e48>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_rest_api_multiple_txns_batches(self, setup):\n        \"\"\"Tests rest-api state by submitting multiple\n            transactions in multiple batches\n        \"\"\"\n        LOGGER.info('Starting test for batch post')\n    \n        signer = get_signer()\n        expected_trxn_ids  = []\n        expected_batch_ids = []\n        address = _get_client_address()\n        url='{}/batches'.format(address)\n        tasks=[]\n    \n        LOGGER.info(\"Creating intkey transactions with set operations\")\n        txns = [\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n            create_intkey_transaction(\"set\", [] , 50 , signer),\n        ]\n    \n        for txn in txns:\n            data = MessageToDict(\n                    txn,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            trxn_id = data['header_signature']\n            expected_trxn_ids.append(trxn_id)\n    \n        LOGGER.info(\"Creating batches for transactions 1trn/batch\")\n    \n        batches = [create_batch([txn], signer) for txn in txns]\n    \n        for batch in batches:\n            data = MessageToDict(\n                    batch,\n                    including_default_value_fields=True,\n                    preserving_proto_field_name=True)\n    \n            batch_id = data['header_signature']\n            expected_batch_ids.append(batch_id)\n    \n        post_batch_list = [BatchList(batches=[batch]).SerializeToString() for batch in batches]\n    \n        LOGGER.info(\"Submitting batches to the handlers\")\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                for batch in post_batch_list:\n                    task = asyncio.ensure_future(async_post_batch(url,session,data=batch))\n                    tasks.append(task)\n>               responses = await asyncio.gather(*tasks)\n\npost/test_rest_api_post.py:404: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npost/test_rest_api_post.py:93: in async_post_batch\n    async with session.post(url,data=data,headers=headers) as response:\n/usr/lib/python3/dist-packages/aiohttp/client.py:779: in __aenter__\n    self._resp = await self._coro\n/usr/lib/python3/dist-packages/aiohttp/client.py:319: in _request\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:418: in connect\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:736: in _create_connection\n    traces=None\n/usr/lib/python3/dist-packages/aiohttp/connector.py:855: in _create_direct_connection\n    raise last_exc\n/usr/lib/python3/dist-packages/aiohttp/connector.py:838: in _create_direct_connection\n    req=req, client_error=client_error)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <aiohttp.connector.TCPConnector object at 0x7fd5994f2278>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd5994f2f28>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n            return await self._loop.create_connection(*args, **kwargs)\n        except certificate_errors as exc:\n            raise ClientConnectorCertificateError(\n                req.connection_key, exc) from exc\n        except ssl_errors as exc:\n            raise ClientConnectorSSLError(req.connection_key, exc) from exc\n        except OSError as exc:\n>           raise client_error(req.connection_key, exc) from exc\nE           aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:807: ClientConnectorError"}, "teardown": {"duration": 0.00030350685119628906, "outcome": "passed"}}, {"nodeid": "post/test_rest_api_post.py::TestPostList::test_api_post_empty_trxns_list", "lineno": 436, "outcome": "failed", "keywords": ["TestPostList", "run", "test_api_post_empty_trxns_list", "post/test_rest_api_post.py", "post", "last", "api_test", "()"], "metadata": {"0": "Tests that transactions are submitted and committed for\neach block that are created by submitting intkey batches\nwith set operations", "1": "\"Tests rest api by posting no batches\n        ", "2": "Tests rest api by posting with bad protobuf\n        ", "3": "Tests rest api by posting with wrong header\n        ", "4": "Tests the rest-api by submitting multiple transactions with same key\n        ", "5": "Tests rest-api state by submitting multiple\ntransactions in multiple batches", "6": "Tests rest-api state by submitting\ntransactions in empty transaction list", "7": "Tests rest-api state by submitting \ntransactions with different signer ", "8": "Tests rest-api state by submitting\ntransactions with no endpoint", "9": "Tests rest-api state by submitting invalid \ntransactions with invalid address ", "10": "Tests rest-api state by submitting invalid \ntransactions with minimum address length ", "11": "Tests rest-api state by submitting invalid \ntransactions with maximum address length ", "12": "Tests rest-api state by submitting valid \ntransactions with invalid transactions", "13": "Tests rest-api state by submitting invalid \ntransactions with valid transactions", "14": "Tests rest-api state by submitting invalid \ntransactions with same transactions", "15": "Tests rest-api state by submitting invalid \ntransactions with commit transactions", "16": "Tests rest-api state by submitting invalid \ntransactions with invalid bad  address ", "17": "Tests rest-api state by submitting invalid \ntransactions with invalid family name"}, "setup": {"duration": 0.0007677078247070312, "outcome": "passed"}, "call": {"duration": 0.004576206207275391, "outcome": "failed", "crash": {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]"}, "traceback": [{"path": "post/test_rest_api_post.py", "lineno": 452, "message": ""}, {"path": "post/test_rest_api_post.py", "lineno": 93, "message": "in async_post_batch"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 779, "message": "in __aenter__"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 319, "message": "in _request"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 418, "message": "in connect"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 736, "message": "in _create_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 855, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 838, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "ClientConnectorError"}], "longrepr": "self = <aiohttp.connector.TCPConnector object at 0x7fd5998f1f28>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd5998f1128>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n>           return await self._loop.create_connection(*args, **kwargs)\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:800: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n                    yield from self.sock_connect(sock, address)\n                except OSError as exc:\n                    if sock is not None:\n                        sock.close()\n                    exceptions.append(exc)\n                except:\n                    if sock is not None:\n                        sock.close()\n                    raise\n                else:\n                    break\n            else:\n                if len(exceptions) == 1:\n>                   raise exceptions[0]\n\n/usr/lib/python3.6/asyncio/base_events.py:783: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n>                   yield from self.sock_connect(sock, address)\n\n/usr/lib/python3.6/asyncio/base_events.py:770: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>, sock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>\naddress = ('192.168.1.23', 8008)\n\n    @coroutine\n    def sock_connect(self, sock, address):\n        \"\"\"Connect to a remote socket at address.\n    \n        This method is a coroutine.\n        \"\"\"\n        if self._debug and sock.gettimeout() != 0:\n            raise ValueError(\"the socket must be non-blocking\")\n    \n        if not hasattr(socket, 'AF_UNIX') or sock.family != socket.AF_UNIX:\n            resolved = base_events._ensure_resolved(\n                address, family=sock.family, proto=sock.proto, loop=self)\n            if not resolved.done():\n                yield from resolved\n            _, _, _, _, address = resolved.result()[0]\n    \n        fut = self.create_future()\n        self._sock_connect(fut, sock, address)\n>       return (yield from fut)\n\n/usr/lib/python3.6/asyncio/selector_events.py:450: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nfut = <Future finished exception=ConnectionRefusedError(111, \"Connect call failed ('192.168.1.23', 8008)\")>\nsock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>, address = ('192.168.1.23', 8008)\n\n    def _sock_connect_cb(self, fut, sock, address):\n        if fut.cancelled():\n            return\n    \n        try:\n            err = sock.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)\n            if err != 0:\n                # Jump to any except clause below.\n>               raise OSError(err, 'Connect call failed %s' % (address,))\nE               ConnectionRefusedError: [Errno 111] Connect call failed ('192.168.1.23', 8008)\n\n/usr/lib/python3.6/asyncio/selector_events.py:480: ConnectionRefusedError\n\nThe above exception was the direct cause of the following exception:\n\nself = <test_rest_api_post.TestPostList object at 0x7fd5998f1748>\nsetup_empty_trxs_batch = header: \"\\nB028793a46f352794a18b2ef6bc78e6dd7a96413f486bbfa1fa612246f5df9de007\"\nheader_signature: \"e8ab7f5e8bd4b329d552849720ad267cda744b4cf27f8982de530f636ff81e8c6f027384b313713b5b280dd1b9df4c4933940effcef71fff064c0ab0d87c96b9\"\n\n\n    async def test_api_post_empty_trxns_list(self, setup_empty_trxs_batch):\n        \"\"\"Tests rest-api state by submitting\n            transactions in empty transaction list\n        \"\"\"\n        address = _get_client_address()\n        url='{}/batches'.format(address)\n        tasks=[]\n        batch = setup_empty_trxs_batch\n        post_batch_list = [BatchList(batches=[batch]).SerializeToString()]\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                for batch in post_batch_list:\n                    task = asyncio.ensure_future(async_post_batch(url,session,data=batch))\n                    tasks.append(task)\n>               response = await asyncio.gather(*tasks)\n\npost/test_rest_api_post.py:452: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npost/test_rest_api_post.py:93: in async_post_batch\n    async with session.post(url,data=data,headers=headers) as response:\n/usr/lib/python3/dist-packages/aiohttp/client.py:779: in __aenter__\n    self._resp = await self._coro\n/usr/lib/python3/dist-packages/aiohttp/client.py:319: in _request\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:418: in connect\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:736: in _create_connection\n    traces=None\n/usr/lib/python3/dist-packages/aiohttp/connector.py:855: in _create_direct_connection\n    raise last_exc\n/usr/lib/python3/dist-packages/aiohttp/connector.py:838: in _create_direct_connection\n    req=req, client_error=client_error)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <aiohttp.connector.TCPConnector object at 0x7fd5998f1f28>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd5998f1128>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n            return await self._loop.create_connection(*args, **kwargs)\n        except certificate_errors as exc:\n            raise ClientConnectorCertificateError(\n                req.connection_key, exc) from exc\n        except ssl_errors as exc:\n            raise ClientConnectorSSLError(req.connection_key, exc) from exc\n        except OSError as exc:\n>           raise client_error(req.connection_key, exc) from exc\nE           aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:807: ClientConnectorError"}, "teardown": {"duration": 0.0003209114074707031, "outcome": "passed"}}, {"nodeid": "post/test_rest_api_post.py::TestPostList::test_api_post_batch_different_signer", "lineno": 456, "outcome": "failed", "keywords": ["TestPostList", "run", "test_api_post_batch_different_signer", "post/test_rest_api_post.py", "post", "last", "api_test", "()"], "metadata": {"0": "Tests that transactions are submitted and committed for\neach block that are created by submitting intkey batches\nwith set operations", "1": "\"Tests rest api by posting no batches\n        ", "2": "Tests rest api by posting with bad protobuf\n        ", "3": "Tests rest api by posting with wrong header\n        ", "4": "Tests the rest-api by submitting multiple transactions with same key\n        ", "5": "Tests rest-api state by submitting multiple\ntransactions in multiple batches", "6": "Tests rest-api state by submitting\ntransactions in empty transaction list", "7": "Tests rest-api state by submitting \ntransactions with different signer ", "8": "Tests rest-api state by submitting\ntransactions with no endpoint", "9": "Tests rest-api state by submitting invalid \ntransactions with invalid address ", "10": "Tests rest-api state by submitting invalid \ntransactions with minimum address length ", "11": "Tests rest-api state by submitting invalid \ntransactions with maximum address length ", "12": "Tests rest-api state by submitting valid \ntransactions with invalid transactions", "13": "Tests rest-api state by submitting invalid \ntransactions with valid transactions", "14": "Tests rest-api state by submitting invalid \ntransactions with same transactions", "15": "Tests rest-api state by submitting invalid \ntransactions with commit transactions", "16": "Tests rest-api state by submitting invalid \ntransactions with invalid bad  address ", "17": "Tests rest-api state by submitting invalid \ntransactions with invalid family name"}, "setup": {"duration": 0.0004673004150390625, "outcome": "passed"}, "call": {"duration": 0.013345718383789062, "outcome": "failed", "crash": {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]"}, "traceback": [{"path": "post/test_rest_api_post.py", "lineno": 476, "message": ""}, {"path": "post/test_rest_api_post.py", "lineno": 93, "message": "in async_post_batch"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 779, "message": "in __aenter__"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/client.py", "lineno": 319, "message": "in _request"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 418, "message": "in connect"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 736, "message": "in _create_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 855, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 838, "message": "in _create_direct_connection"}, {"path": "/usr/lib/python3/dist-packages/aiohttp/connector.py", "lineno": 807, "message": "ClientConnectorError"}], "longrepr": "self = <aiohttp.connector.TCPConnector object at 0x7fd599a69518>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd599a69ac8>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n>           return await self._loop.create_connection(*args, **kwargs)\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:800: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n                    yield from self.sock_connect(sock, address)\n                except OSError as exc:\n                    if sock is not None:\n                        sock.close()\n                    exceptions.append(exc)\n                except:\n                    if sock is not None:\n                        sock.close()\n                    raise\n                else:\n                    break\n            else:\n                if len(exceptions) == 1:\n>                   raise exceptions[0]\n\n/usr/lib/python3.6/asyncio/base_events.py:783: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nprotocol_factory = functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>)\nhost = '192.168.1.23', port = 8008\n\n    @coroutine\n    def create_connection(self, protocol_factory, host=None, port=None, *,\n                          ssl=None, family=0, proto=0, flags=0, sock=None,\n                          local_addr=None, server_hostname=None):\n        \"\"\"Connect to a TCP server.\n    \n        Create a streaming transport connection to a given Internet host and\n        port: socket family AF_INET or socket.AF_INET6 depending on host (or\n        family if specified), socket type SOCK_STREAM. protocol_factory must be\n        a callable returning a protocol instance.\n    \n        This method is a coroutine which will try to establish the connection\n        in the background.  When successful, the coroutine returns a\n        (transport, protocol) pair.\n        \"\"\"\n        if server_hostname is not None and not ssl:\n            raise ValueError('server_hostname is only meaningful with ssl')\n    \n        if server_hostname is None and ssl:\n            # Use host as default for server_hostname.  It is an error\n            # if host is empty or not set, e.g. when an\n            # already-connected socket was passed or when only a port\n            # is given.  To avoid this error, you can pass\n            # server_hostname='' -- this will bypass the hostname\n            # check.  (This also means that if host is a numeric\n            # IP/IPv6 address, we will attempt to verify that exact\n            # address; this will probably fail, but it is possible to\n            # create a certificate for a specific IP address, so we\n            # don't judge it here.)\n            if not host:\n                raise ValueError('You must set server_hostname '\n                                 'when using ssl without a host')\n            server_hostname = host\n    \n        if host is not None or port is not None:\n            if sock is not None:\n                raise ValueError(\n                    'host/port and sock can not be specified at the same time')\n    \n            f1 = _ensure_resolved((host, port), family=family,\n                                  type=socket.SOCK_STREAM, proto=proto,\n                                  flags=flags, loop=self)\n            fs = [f1]\n            if local_addr is not None:\n                f2 = _ensure_resolved(local_addr, family=family,\n                                      type=socket.SOCK_STREAM, proto=proto,\n                                      flags=flags, loop=self)\n                fs.append(f2)\n            else:\n                f2 = None\n    \n            yield from tasks.wait(fs, loop=self)\n    \n            infos = f1.result()\n            if not infos:\n                raise OSError('getaddrinfo() returned empty list')\n            if f2 is not None:\n                laddr_infos = f2.result()\n                if not laddr_infos:\n                    raise OSError('getaddrinfo() returned empty list')\n    \n            exceptions = []\n            for family, type, proto, cname, address in infos:\n                try:\n                    sock = socket.socket(family=family, type=type, proto=proto)\n                    sock.setblocking(False)\n                    if f2 is not None:\n                        for _, _, _, _, laddr in laddr_infos:\n                            try:\n                                sock.bind(laddr)\n                                break\n                            except OSError as exc:\n                                exc = OSError(\n                                    exc.errno, 'error while '\n                                    'attempting to bind on address '\n                                    '{!r}: {}'.format(\n                                        laddr, exc.strerror.lower()))\n                                exceptions.append(exc)\n                        else:\n                            sock.close()\n                            sock = None\n                            continue\n                    if self._debug:\n                        logger.debug(\"connect %r to %r\", sock, address)\n>                   yield from self.sock_connect(sock, address)\n\n/usr/lib/python3.6/asyncio/base_events.py:770: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>, sock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>\naddress = ('192.168.1.23', 8008)\n\n    @coroutine\n    def sock_connect(self, sock, address):\n        \"\"\"Connect to a remote socket at address.\n    \n        This method is a coroutine.\n        \"\"\"\n        if self._debug and sock.gettimeout() != 0:\n            raise ValueError(\"the socket must be non-blocking\")\n    \n        if not hasattr(socket, 'AF_UNIX') or sock.family != socket.AF_UNIX:\n            resolved = base_events._ensure_resolved(\n                address, family=sock.family, proto=sock.proto, loop=self)\n            if not resolved.done():\n                yield from resolved\n            _, _, _, _, address = resolved.result()[0]\n    \n        fut = self.create_future()\n        self._sock_connect(fut, sock, address)\n>       return (yield from fut)\n\n/usr/lib/python3.6/asyncio/selector_events.py:450: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <_UnixSelectorEventLoop running=False closed=False debug=False>\nfut = <Future finished exception=ConnectionRefusedError(111, \"Connect call failed ('192.168.1.23', 8008)\")>\nsock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=2049, proto=6>, address = ('192.168.1.23', 8008)\n\n    def _sock_connect_cb(self, fut, sock, address):\n        if fut.cancelled():\n            return\n    \n        try:\n            err = sock.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)\n            if err != 0:\n                # Jump to any except clause below.\n>               raise OSError(err, 'Connect call failed %s' % (address,))\nE               ConnectionRefusedError: [Errno 111] Connect call failed ('192.168.1.23', 8008)\n\n/usr/lib/python3.6/asyncio/selector_events.py:480: ConnectionRefusedError\n\nThe above exception was the direct cause of the following exception:\n\nself = <test_rest_api_post.TestPostList object at 0x7fd5997aaf60>\nsetup = {'address': 'http://192.168.1.23:8008', 'batch_ids': ['0c6411bdddb17d6e413fa5f67f281cbfc93c4057f2967cec68befbc16430231...3c7851d3560e7ba48b5aeef94710ca174d378e4405ad90263430c2f91c4&limit=100', 'paging': {'limit': None, 'start': None}}, ...}\n\n    async def test_api_post_batch_different_signer(self, setup):\n        \"\"\"Tests rest-api state by submitting\n            transactions with different signer\n        \"\"\"\n        address = _get_client_address()\n        url='{}/batches'.format(address)\n        tasks=[]\n        signer_trans = get_signer()\n        intkey=create_intkey_transaction(\"set\",[],50,signer_trans)\n        translist=[intkey]\n        signer_batch = get_signer()\n        batch= create_batch(translist,signer_batch)\n        post_batch_list=[BatchList(batches=[batch]).SerializeToString()]\n    \n        try:\n            async with aiohttp.ClientSession() as session:\n                for batch in post_batch_list:\n                    task = asyncio.ensure_future(async_post_batch(url,session,data=batch))\n                    tasks.append(task)\n>               response = await asyncio.gather(*tasks)\n\npost/test_rest_api_post.py:476: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npost/test_rest_api_post.py:93: in async_post_batch\n    async with session.post(url,data=data,headers=headers) as response:\n/usr/lib/python3/dist-packages/aiohttp/client.py:779: in __aenter__\n    self._resp = await self._coro\n/usr/lib/python3/dist-packages/aiohttp/client.py:319: in _request\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:418: in connect\n    traces=traces\n/usr/lib/python3/dist-packages/aiohttp/connector.py:736: in _create_connection\n    traces=None\n/usr/lib/python3/dist-packages/aiohttp/connector.py:855: in _create_direct_connection\n    raise last_exc\n/usr/lib/python3/dist-packages/aiohttp/connector.py:838: in _create_direct_connection\n    req=req, client_error=client_error)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <aiohttp.connector.TCPConnector object at 0x7fd599a69518>, req = <aiohttp.client_reqrep.ClientRequest object at 0x7fd599a69ac8>\nclient_error = <class 'aiohttp.client_exceptions.ClientConnectorError'>\nargs = (functools.partial(<class 'aiohttp.client_proto.ResponseHandler'>, loop=<_UnixSelectorEventLoop running=False closed=False debug=False>), '192.168.1.23', 8008)\nkwargs = {'family': 0, 'flags': 0, 'local_addr': None, 'proto': 0, ...}\n\n    async def _wrap_create_connection(self, *args,\n                                      req, client_error=ClientConnectorError,\n                                      **kwargs):\n        try:\n            return await self._loop.create_connection(*args, **kwargs)\n        except certificate_errors as exc:\n            raise ClientConnectorCertificateError(\n                req.connection_key, exc) from exc\n        except ssl_errors as exc:\n            raise ClientConnectorSSLError(req.connection_key, exc) from exc\n        except OSError as exc:\n>           raise client_error(req.connection_key, exc) from exc\nE           aiohttp.client_exceptions.ClientConnectorError: Cannot connect to host 192.168.1.23:8008 ssl:False [Connect call failed ('192.168.1.23', 8008)]\n\n/usr/lib/python3/dist-packages/aiohttp/connector.py:807: ClientConnectorError"}, "teardown": {"duration": 0.00030112266540527344, "outcome": "passed"}}, {"nodeid": "post/test_rest_api_post.py::TestPostList::test_rest_api_post_no_endpoint", "lineno": 481, "outcome": "passed", "keywords": ["TestPostList", "run", "post/test_rest_api_post.py", "post", "last", "test_rest_api_post_no_endpoint", "api_test", "()"], "metadata": {"0": "Tests that transactions are submitted and committed for\neach block that are created by submitting intkey batches\nwith set operations", "1": "\"Tests rest api by posting no batches\n        ", "2": "Tests rest api by posting with bad protobuf\n        ", "3": "Tests rest api by posting with wrong header\n        ", "4": "Tests the rest-api by submitting multiple transactions with same key\n        ", "5": "Tests rest-api state by submitting multiple\ntransactions in multiple batches", "6": "Tests rest-api state by submitting\ntransactions in empty transaction list", "7": "Tests rest-api state by submitting \ntransactions with different signer ", "8": "Tests rest-api state by submitting\ntransactions with no endpoint", "9": "Tests rest-api state by submitting invalid \ntransactions with invalid address ", "10": "Tests rest-api state by submitting invalid \ntransactions with minimum address length ", "11": "Tests rest-api state by submitting invalid \ntransactions with maximum address length ", "12": "Tests rest-api state by submitting valid \ntransactions with invalid transactions", "13": "Tests rest-api state by submitting invalid \ntransactions with valid transactions", "14": "Tests rest-api state by submitting invalid \ntransactions with same transactions", "15": "Tests rest-api state by submitting invalid \ntransactions with commit transactions", "16": "Tests rest-api state by submitting invalid \ntransactions with invalid bad  address ", "17": "Tests rest-api state by submitting invalid \ntransactions with invalid family name"}, "setup": {"duration": 0.0004868507385253906, "outcome": "passed"}, "call": {"duration": 0.02945089340209961, "outcome": "passed", "log": [{"name": "test_rest_api_post", "msg": "Rest Api is Unreachable", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/post/test_rest_api_post.py", "filename": "test_rest_api_post.py", "module": "test_rest_api_post", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 501, "funcName": "test_rest_api_post_no_endpoint", "created": 1552990410.3769288, "msecs": 376.92880630493164, "relativeCreated": 2531234.349489212, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:30"}, {"name": "test_rest_api_post", "msg": "Url is not correct", "args": null, "levelname": "INFO", "levelno": 20, "pathname": "/home/ubuntu/Rest_tests_13Mar/14Mar_aiohttp/sawtooth-core/rest_api/tests/api_test/post/test_rest_api_post.py", "filename": "test_rest_api_post.py", "module": "test_rest_api_post", "exc_info": null, "exc_text": null, "stack_info": null, "lineno": 502, "funcName": "test_rest_api_post_no_endpoint", "created": 1552990410.3771014, "msecs": 377.1014213562012, "relativeCreated": 2531234.5221042633, "thread": 140555512387392, "threadName": "MainThread", "processName": "MainProcess", "process": 10560, "asctime": "2019-03-19 15:43:30"}]}, "teardown": {"duration": 0.00025343894958496094, "outcome": "passed"}}, {"nodeid": "post/test_rest_api_post.py::TestPostInvalidTxns::test_txn_invalid_addr", "lineno": 505, "outcome": "error", "keywords": ["run", "post/test_rest_api_post.py", "post", "last", "api_test", "test_txn_invalid_addr", "TestPostInvalidTxns", "()"], "metadata": {"0": "Tests that transactions are submitted and committed for\neach block that are created by submitting intkey batches\nwith set operations", "1": "\"Tests rest api by posting no batches\n        ", "2": "Tests rest api by posting with bad protobuf\n        ", "3": "Tests rest api by posting with wrong header\n        ", "4": "Tests the rest-api by submitting multiple transactions with same key\n        ", "5": "Tests rest-api state by submitting multiple\ntransactions in multiple batches", "6": "Tests rest-api state by submitting\ntransactions in empty transaction list", "7": "Tests rest-api state by submitting \ntransactions with different signer ", "8": "Tests rest-api state by submitting\ntransactions with no endpoint", "9": "Tests rest-api state by submitting invalid \ntransactions with invalid address ", "10": "Tests rest-api state by submitting invalid \ntransactions with minimum address length ", "11": "Tests rest-api state by submitting invalid \ntransactions with maximum address length ", "12": "Tests rest-api state by submitting valid \ntransactions with invalid transactions", "13": "Tests rest-api state by submitting invalid \ntransactions with valid transactions", "14": "Tests rest-api state by submitting invalid \ntransactions with same transactions", "15": "Tests rest-api state by submitting invalid \ntransactions with commit transactions", "16": "Tests rest-api state by submitting invalid \ntransactions with invalid bad  address ", "17": "Tests rest-api state by submitting invalid \ntransactions with invalid family name"}, "setup": {"duration": 0.02533745765686035, "outcome": "failed", "crash": {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1320, "message": "urllib.error.URLError: <urlopen error [Errno 111] Connection refused>"}, "traceback": [{"path": "fixtures.py", "lineno": 183, "message": ""}, {"path": "payload.py", "lineno": 301, "message": "in get_batch_invalid_txns"}, {"path": "payload.py", "lineno": 360, "message": "in get_txns_commit_data"}, {"path": "utils.py", "lineno": 377, "message": "in batch_count"}, {"path": "utils.py", "lineno": 92, "message": "in get_batches"}, {"path": "utils.py", "lineno": 183, "message": "in query_rest_api"}, {"path": "utils.py", "lineno": 186, "message": "in submit_request"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 223, "message": "in urlopen"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 526, "message": "in open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 544, "message": "in _open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 504, "message": "in _call_chain"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1346, "message": "in http_open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1320, "message": "URLError"}], "longrepr": "self = <urllib.request.HTTPHandler object at 0x7fd599cb66d8>, http_class = <class 'http.client.HTTPConnection'>, req = <urllib.request.Request object at 0x7fd5997050b8>\nhttp_conn_args = {}, host = '192.168.1.23:8008', h = <http.client.HTTPConnection object at 0x7fd599705dd8>\n\n    def do_open(self, http_class, req, **http_conn_args):\n        \"\"\"Return an HTTPResponse object for the request, using http_class.\n    \n        http_class must implement the HTTPConnection API from http.client.\n        \"\"\"\n        host = req.host\n        if not host:\n            raise URLError('no host given')\n    \n        # will parse host:port\n        h = http_class(host, timeout=req.timeout, **http_conn_args)\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # TODO(jhylton): Should this be redesigned to handle\n        # persistent connections?\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict((name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            try:\n                h.request(req.get_method(), req.selector, req.data, headers,\n>                         encode_chunked=req.has_header('Transfer-encoding'))\n\n/usr/lib/python3.6/urllib/request.py:1318: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599705dd8>, method = 'GET', url = '/batches', body = None\nheaders = {'Connection': 'close', 'Host': '192.168.1.23:8008', 'User-Agent': 'Python-urllib/3.6'}\n\n    def request(self, method, url, body=None, headers={}, *,\n                encode_chunked=False):\n        \"\"\"Send a complete request to the server.\"\"\"\n>       self._send_request(method, url, body, headers, encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1239: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599705dd8>, method = 'GET', url = '/batches', body = None\nheaders = {'Connection': 'close', 'Host': '192.168.1.23:8008', 'User-Agent': 'Python-urllib/3.6'}, encode_chunked = False\n\n    def _send_request(self, method, url, body, headers, encode_chunked):\n        # Honor explicitly requested Host: and Accept-Encoding: headers.\n        header_names = frozenset(k.lower() for k in headers)\n        skips = {}\n        if 'host' in header_names:\n            skips['skip_host'] = 1\n        if 'accept-encoding' in header_names:\n            skips['skip_accept_encoding'] = 1\n    \n        self.putrequest(method, url, **skips)\n    \n        # chunked encoding will happen if HTTP/1.1 is used and either\n        # the caller passes encode_chunked=True or the following\n        # conditions hold:\n        # 1. content-length has not been explicitly set\n        # 2. the body is a file or iterable, but not a str or bytes-like\n        # 3. Transfer-Encoding has NOT been explicitly set by the caller\n    \n        if 'content-length' not in header_names:\n            # only chunk body if not explicitly set for backwards\n            # compatibility, assuming the client code is already handling the\n            # chunking\n            if 'transfer-encoding' not in header_names:\n                # if content-length cannot be automatically determined, fall\n                # back to chunked encoding\n                encode_chunked = False\n                content_length = self._get_content_length(body, method)\n                if content_length is None:\n                    if body is not None:\n                        if self.debuglevel > 0:\n                            print('Unable to determine size of %r' % body)\n                        encode_chunked = True\n                        self.putheader('Transfer-Encoding', 'chunked')\n                else:\n                    self.putheader('Content-Length', str(content_length))\n        else:\n            encode_chunked = False\n    \n        for hdr, value in headers.items():\n            self.putheader(hdr, value)\n        if isinstance(body, str):\n            # RFC 2616 Section 3.7.1 says that text default has a\n            # default charset of iso-8859-1.\n            body = _encode(body, 'body')\n>       self.endheaders(body, encode_chunked=encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1285: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599705dd8>, message_body = None\n\n    def endheaders(self, message_body=None, *, encode_chunked=False):\n        \"\"\"Indicate that the last header line has been sent to the server.\n    \n        This method sends the request to the server.  The optional message_body\n        argument can be used to pass a message body associated with the\n        request.\n        \"\"\"\n        if self.__state == _CS_REQ_STARTED:\n            self.__state = _CS_REQ_SENT\n        else:\n            raise CannotSendHeader()\n>       self._send_output(message_body, encode_chunked=encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1234: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599705dd8>, message_body = None, encode_chunked = False\n\n    def _send_output(self, message_body=None, encode_chunked=False):\n        \"\"\"Send the currently buffered request and clear the buffer.\n    \n        Appends an extra \\\\r\\\\n to the buffer.\n        A message_body may be specified, to be appended to the request.\n        \"\"\"\n        self._buffer.extend((b\"\", b\"\"))\n        msg = b\"\\r\\n\".join(self._buffer)\n        del self._buffer[:]\n>       self.send(msg)\n\n/usr/lib/python3.6/http/client.py:1026: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599705dd8>\ndata = b'GET /batches HTTP/1.1\\r\\nAccept-Encoding: identity\\r\\nHost: 192.168.1.23:8008\\r\\nUser-Agent: Python-urllib/3.6\\r\\nConnection: close\\r\\n\\r\\n'\n\n    def send(self, data):\n        \"\"\"Send `data' to the server.\n        ``data`` can be a string object, a bytes object, an array object, a\n        file-like object that supports a .read() method, or an iterable object.\n        \"\"\"\n    \n        if self.sock is None:\n            if self.auto_open:\n>               self.connect()\n\n/usr/lib/python3.6/http/client.py:964: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599705dd8>\n\n    def connect(self):\n        \"\"\"Connect to the host and port specified in __init__.\"\"\"\n        self.sock = self._create_connection(\n>           (self.host,self.port), self.timeout, self.source_address)\n\n/usr/lib/python3.6/http/client.py:936: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('192.168.1.23', 8008), timeout = <object object at 0x7fd5a15eb580>, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n                sock.connect(sa)\n                # Break explicitly a reference cycle\n                err = None\n                return sock\n    \n            except error as _:\n                err = _\n                if sock is not None:\n                    sock.close()\n    \n        if err is not None:\n>           raise err\n\n/usr/lib/python3.6/socket.py:724: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('192.168.1.23', 8008), timeout = <object object at 0x7fd5a15eb580>, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [Errno 111] Connection refused\n\n/usr/lib/python3.6/socket.py:713: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nrequest = <SubRequest 'setup_invalid_txns' for <Function test_txn_invalid_addr>>\n\n    @pytest.fixture(scope=\"function\")\n    def setup_invalid_txns(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        Txns=Transactions(invalidtype=\"addr\")\n>       data = Txns.get_batch_invalid_txns()\n\nfixtures.py:183: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npayload.py:301: in get_batch_invalid_txns\n    self.data = self.get_txns_commit_data(txns,self.signer, self.data)\npayload.py:360: in get_txns_commit_data\n    initial_batch_length = batch_count()\nutils.py:377: in batch_count\n    batch_list = get_batches()\nutils.py:92: in get_batches\n    response = query_rest_api('/batches')\nutils.py:183: in query_rest_api\n    return submit_request(urllib.request.Request(url, data, headers))\nutils.py:186: in submit_request\n    response = urllib.request.urlopen(request).read().decode('utf-8')\n/usr/lib/python3.6/urllib/request.py:223: in urlopen\n    return opener.open(url, data, timeout)\n/usr/lib/python3.6/urllib/request.py:526: in open\n    response = self._open(req, data)\n/usr/lib/python3.6/urllib/request.py:544: in _open\n    '_open', req)\n/usr/lib/python3.6/urllib/request.py:504: in _call_chain\n    result = func(*args)\n/usr/lib/python3.6/urllib/request.py:1346: in http_open\n    return self.do_open(http.client.HTTPConnection, req)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib.request.HTTPHandler object at 0x7fd599cb66d8>, http_class = <class 'http.client.HTTPConnection'>, req = <urllib.request.Request object at 0x7fd5997050b8>\nhttp_conn_args = {}, host = '192.168.1.23:8008', h = <http.client.HTTPConnection object at 0x7fd599705dd8>\n\n    def do_open(self, http_class, req, **http_conn_args):\n        \"\"\"Return an HTTPResponse object for the request, using http_class.\n    \n        http_class must implement the HTTPConnection API from http.client.\n        \"\"\"\n        host = req.host\n        if not host:\n            raise URLError('no host given')\n    \n        # will parse host:port\n        h = http_class(host, timeout=req.timeout, **http_conn_args)\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # TODO(jhylton): Should this be redesigned to handle\n        # persistent connections?\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict((name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            try:\n                h.request(req.get_method(), req.selector, req.data, headers,\n                          encode_chunked=req.has_header('Transfer-encoding'))\n            except OSError as err: # timeout error\n>               raise URLError(err)\nE               urllib.error.URLError: <urlopen error [Errno 111] Connection refused>\n\n/usr/lib/python3.6/urllib/request.py:1320: URLError"}, "teardown": {"duration": 0.0002951622009277344, "outcome": "passed"}}, {"nodeid": "post/test_rest_api_post.py::TestPostInvalidTxns::test_txn_invalid_min", "lineno": 517, "outcome": "error", "keywords": ["run", "post/test_rest_api_post.py", "post", "test_txn_invalid_min", "last", "api_test", "TestPostInvalidTxns", "()"], "metadata": {"0": "Tests that transactions are submitted and committed for\neach block that are created by submitting intkey batches\nwith set operations", "1": "\"Tests rest api by posting no batches\n        ", "2": "Tests rest api by posting with bad protobuf\n        ", "3": "Tests rest api by posting with wrong header\n        ", "4": "Tests the rest-api by submitting multiple transactions with same key\n        ", "5": "Tests rest-api state by submitting multiple\ntransactions in multiple batches", "6": "Tests rest-api state by submitting\ntransactions in empty transaction list", "7": "Tests rest-api state by submitting \ntransactions with different signer ", "8": "Tests rest-api state by submitting\ntransactions with no endpoint", "9": "Tests rest-api state by submitting invalid \ntransactions with invalid address ", "10": "Tests rest-api state by submitting invalid \ntransactions with minimum address length ", "11": "Tests rest-api state by submitting invalid \ntransactions with maximum address length ", "12": "Tests rest-api state by submitting valid \ntransactions with invalid transactions", "13": "Tests rest-api state by submitting invalid \ntransactions with valid transactions", "14": "Tests rest-api state by submitting invalid \ntransactions with same transactions", "15": "Tests rest-api state by submitting invalid \ntransactions with commit transactions", "16": "Tests rest-api state by submitting invalid \ntransactions with invalid bad  address ", "17": "Tests rest-api state by submitting invalid \ntransactions with invalid family name"}, "setup": {"duration": 0.02626800537109375, "outcome": "failed", "crash": {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1320, "message": "urllib.error.URLError: <urlopen error [Errno 111] Connection refused>"}, "traceback": [{"path": "fixtures.py", "lineno": 212, "message": ""}, {"path": "payload.py", "lineno": 301, "message": "in get_batch_invalid_txns"}, {"path": "payload.py", "lineno": 360, "message": "in get_txns_commit_data"}, {"path": "utils.py", "lineno": 377, "message": "in batch_count"}, {"path": "utils.py", "lineno": 92, "message": "in get_batches"}, {"path": "utils.py", "lineno": 183, "message": "in query_rest_api"}, {"path": "utils.py", "lineno": 186, "message": "in submit_request"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 223, "message": "in urlopen"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 526, "message": "in open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 544, "message": "in _open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 504, "message": "in _call_chain"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1346, "message": "in http_open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1320, "message": "URLError"}], "longrepr": "self = <urllib.request.HTTPHandler object at 0x7fd599cb66d8>, http_class = <class 'http.client.HTTPConnection'>, req = <urllib.request.Request object at 0x7fd59971e7b8>\nhttp_conn_args = {}, host = '192.168.1.23:8008', h = <http.client.HTTPConnection object at 0x7fd59971e940>\n\n    def do_open(self, http_class, req, **http_conn_args):\n        \"\"\"Return an HTTPResponse object for the request, using http_class.\n    \n        http_class must implement the HTTPConnection API from http.client.\n        \"\"\"\n        host = req.host\n        if not host:\n            raise URLError('no host given')\n    \n        # will parse host:port\n        h = http_class(host, timeout=req.timeout, **http_conn_args)\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # TODO(jhylton): Should this be redesigned to handle\n        # persistent connections?\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict((name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            try:\n                h.request(req.get_method(), req.selector, req.data, headers,\n>                         encode_chunked=req.has_header('Transfer-encoding'))\n\n/usr/lib/python3.6/urllib/request.py:1318: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd59971e940>, method = 'GET', url = '/batches', body = None\nheaders = {'Connection': 'close', 'Host': '192.168.1.23:8008', 'User-Agent': 'Python-urllib/3.6'}\n\n    def request(self, method, url, body=None, headers={}, *,\n                encode_chunked=False):\n        \"\"\"Send a complete request to the server.\"\"\"\n>       self._send_request(method, url, body, headers, encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1239: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd59971e940>, method = 'GET', url = '/batches', body = None\nheaders = {'Connection': 'close', 'Host': '192.168.1.23:8008', 'User-Agent': 'Python-urllib/3.6'}, encode_chunked = False\n\n    def _send_request(self, method, url, body, headers, encode_chunked):\n        # Honor explicitly requested Host: and Accept-Encoding: headers.\n        header_names = frozenset(k.lower() for k in headers)\n        skips = {}\n        if 'host' in header_names:\n            skips['skip_host'] = 1\n        if 'accept-encoding' in header_names:\n            skips['skip_accept_encoding'] = 1\n    \n        self.putrequest(method, url, **skips)\n    \n        # chunked encoding will happen if HTTP/1.1 is used and either\n        # the caller passes encode_chunked=True or the following\n        # conditions hold:\n        # 1. content-length has not been explicitly set\n        # 2. the body is a file or iterable, but not a str or bytes-like\n        # 3. Transfer-Encoding has NOT been explicitly set by the caller\n    \n        if 'content-length' not in header_names:\n            # only chunk body if not explicitly set for backwards\n            # compatibility, assuming the client code is already handling the\n            # chunking\n            if 'transfer-encoding' not in header_names:\n                # if content-length cannot be automatically determined, fall\n                # back to chunked encoding\n                encode_chunked = False\n                content_length = self._get_content_length(body, method)\n                if content_length is None:\n                    if body is not None:\n                        if self.debuglevel > 0:\n                            print('Unable to determine size of %r' % body)\n                        encode_chunked = True\n                        self.putheader('Transfer-Encoding', 'chunked')\n                else:\n                    self.putheader('Content-Length', str(content_length))\n        else:\n            encode_chunked = False\n    \n        for hdr, value in headers.items():\n            self.putheader(hdr, value)\n        if isinstance(body, str):\n            # RFC 2616 Section 3.7.1 says that text default has a\n            # default charset of iso-8859-1.\n            body = _encode(body, 'body')\n>       self.endheaders(body, encode_chunked=encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1285: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd59971e940>, message_body = None\n\n    def endheaders(self, message_body=None, *, encode_chunked=False):\n        \"\"\"Indicate that the last header line has been sent to the server.\n    \n        This method sends the request to the server.  The optional message_body\n        argument can be used to pass a message body associated with the\n        request.\n        \"\"\"\n        if self.__state == _CS_REQ_STARTED:\n            self.__state = _CS_REQ_SENT\n        else:\n            raise CannotSendHeader()\n>       self._send_output(message_body, encode_chunked=encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1234: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd59971e940>, message_body = None, encode_chunked = False\n\n    def _send_output(self, message_body=None, encode_chunked=False):\n        \"\"\"Send the currently buffered request and clear the buffer.\n    \n        Appends an extra \\\\r\\\\n to the buffer.\n        A message_body may be specified, to be appended to the request.\n        \"\"\"\n        self._buffer.extend((b\"\", b\"\"))\n        msg = b\"\\r\\n\".join(self._buffer)\n        del self._buffer[:]\n>       self.send(msg)\n\n/usr/lib/python3.6/http/client.py:1026: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd59971e940>\ndata = b'GET /batches HTTP/1.1\\r\\nAccept-Encoding: identity\\r\\nHost: 192.168.1.23:8008\\r\\nUser-Agent: Python-urllib/3.6\\r\\nConnection: close\\r\\n\\r\\n'\n\n    def send(self, data):\n        \"\"\"Send `data' to the server.\n        ``data`` can be a string object, a bytes object, an array object, a\n        file-like object that supports a .read() method, or an iterable object.\n        \"\"\"\n    \n        if self.sock is None:\n            if self.auto_open:\n>               self.connect()\n\n/usr/lib/python3.6/http/client.py:964: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd59971e940>\n\n    def connect(self):\n        \"\"\"Connect to the host and port specified in __init__.\"\"\"\n        self.sock = self._create_connection(\n>           (self.host,self.port), self.timeout, self.source_address)\n\n/usr/lib/python3.6/http/client.py:936: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('192.168.1.23', 8008), timeout = <object object at 0x7fd5a15eb580>, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n                sock.connect(sa)\n                # Break explicitly a reference cycle\n                err = None\n                return sock\n    \n            except error as _:\n                err = _\n                if sock is not None:\n                    sock.close()\n    \n        if err is not None:\n>           raise err\n\n/usr/lib/python3.6/socket.py:724: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('192.168.1.23', 8008), timeout = <object object at 0x7fd5a15eb580>, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [Errno 111] Connection refused\n\n/usr/lib/python3.6/socket.py:713: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nrequest = <SubRequest 'setup_invalid_txns_min' for <Function test_txn_invalid_min>>\n\n    @pytest.fixture(scope=\"function\")\n    def setup_invalid_txns_min(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        Txns=Transactions(invalidtype=\"min\")\n>       data = Txns.get_batch_invalid_txns()\n\nfixtures.py:212: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npayload.py:301: in get_batch_invalid_txns\n    self.data = self.get_txns_commit_data(txns,self.signer, self.data)\npayload.py:360: in get_txns_commit_data\n    initial_batch_length = batch_count()\nutils.py:377: in batch_count\n    batch_list = get_batches()\nutils.py:92: in get_batches\n    response = query_rest_api('/batches')\nutils.py:183: in query_rest_api\n    return submit_request(urllib.request.Request(url, data, headers))\nutils.py:186: in submit_request\n    response = urllib.request.urlopen(request).read().decode('utf-8')\n/usr/lib/python3.6/urllib/request.py:223: in urlopen\n    return opener.open(url, data, timeout)\n/usr/lib/python3.6/urllib/request.py:526: in open\n    response = self._open(req, data)\n/usr/lib/python3.6/urllib/request.py:544: in _open\n    '_open', req)\n/usr/lib/python3.6/urllib/request.py:504: in _call_chain\n    result = func(*args)\n/usr/lib/python3.6/urllib/request.py:1346: in http_open\n    return self.do_open(http.client.HTTPConnection, req)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib.request.HTTPHandler object at 0x7fd599cb66d8>, http_class = <class 'http.client.HTTPConnection'>, req = <urllib.request.Request object at 0x7fd59971e7b8>\nhttp_conn_args = {}, host = '192.168.1.23:8008', h = <http.client.HTTPConnection object at 0x7fd59971e940>\n\n    def do_open(self, http_class, req, **http_conn_args):\n        \"\"\"Return an HTTPResponse object for the request, using http_class.\n    \n        http_class must implement the HTTPConnection API from http.client.\n        \"\"\"\n        host = req.host\n        if not host:\n            raise URLError('no host given')\n    \n        # will parse host:port\n        h = http_class(host, timeout=req.timeout, **http_conn_args)\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # TODO(jhylton): Should this be redesigned to handle\n        # persistent connections?\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict((name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            try:\n                h.request(req.get_method(), req.selector, req.data, headers,\n                          encode_chunked=req.has_header('Transfer-encoding'))\n            except OSError as err: # timeout error\n>               raise URLError(err)\nE               urllib.error.URLError: <urlopen error [Errno 111] Connection refused>\n\n/usr/lib/python3.6/urllib/request.py:1320: URLError"}, "teardown": {"duration": 0.00027441978454589844, "outcome": "passed"}}, {"nodeid": "post/test_rest_api_post.py::TestPostInvalidTxns::test_txn_invalid_max", "lineno": 529, "outcome": "error", "keywords": ["run", "post/test_rest_api_post.py", "post", "last", "api_test", "test_txn_invalid_max", "TestPostInvalidTxns", "()"], "metadata": {"0": "Tests that transactions are submitted and committed for\neach block that are created by submitting intkey batches\nwith set operations", "1": "\"Tests rest api by posting no batches\n        ", "2": "Tests rest api by posting with bad protobuf\n        ", "3": "Tests rest api by posting with wrong header\n        ", "4": "Tests the rest-api by submitting multiple transactions with same key\n        ", "5": "Tests rest-api state by submitting multiple\ntransactions in multiple batches", "6": "Tests rest-api state by submitting\ntransactions in empty transaction list", "7": "Tests rest-api state by submitting \ntransactions with different signer ", "8": "Tests rest-api state by submitting\ntransactions with no endpoint", "9": "Tests rest-api state by submitting invalid \ntransactions with invalid address ", "10": "Tests rest-api state by submitting invalid \ntransactions with minimum address length ", "11": "Tests rest-api state by submitting invalid \ntransactions with maximum address length ", "12": "Tests rest-api state by submitting valid \ntransactions with invalid transactions", "13": "Tests rest-api state by submitting invalid \ntransactions with valid transactions", "14": "Tests rest-api state by submitting invalid \ntransactions with same transactions", "15": "Tests rest-api state by submitting invalid \ntransactions with commit transactions", "16": "Tests rest-api state by submitting invalid \ntransactions with invalid bad  address ", "17": "Tests rest-api state by submitting invalid \ntransactions with invalid family name"}, "setup": {"duration": 0.02582406997680664, "outcome": "failed", "crash": {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1320, "message": "urllib.error.URLError: <urlopen error [Errno 111] Connection refused>"}, "traceback": [{"path": "fixtures.py", "lineno": 221, "message": ""}, {"path": "payload.py", "lineno": 301, "message": "in get_batch_invalid_txns"}, {"path": "payload.py", "lineno": 360, "message": "in get_txns_commit_data"}, {"path": "utils.py", "lineno": 377, "message": "in batch_count"}, {"path": "utils.py", "lineno": 92, "message": "in get_batches"}, {"path": "utils.py", "lineno": 183, "message": "in query_rest_api"}, {"path": "utils.py", "lineno": 186, "message": "in submit_request"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 223, "message": "in urlopen"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 526, "message": "in open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 544, "message": "in _open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 504, "message": "in _call_chain"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1346, "message": "in http_open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1320, "message": "URLError"}], "longrepr": "self = <urllib.request.HTTPHandler object at 0x7fd599cb66d8>, http_class = <class 'http.client.HTTPConnection'>, req = <urllib.request.Request object at 0x7fd599b0b438>\nhttp_conn_args = {}, host = '192.168.1.23:8008', h = <http.client.HTTPConnection object at 0x7fd5997f1908>\n\n    def do_open(self, http_class, req, **http_conn_args):\n        \"\"\"Return an HTTPResponse object for the request, using http_class.\n    \n        http_class must implement the HTTPConnection API from http.client.\n        \"\"\"\n        host = req.host\n        if not host:\n            raise URLError('no host given')\n    \n        # will parse host:port\n        h = http_class(host, timeout=req.timeout, **http_conn_args)\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # TODO(jhylton): Should this be redesigned to handle\n        # persistent connections?\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict((name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            try:\n                h.request(req.get_method(), req.selector, req.data, headers,\n>                         encode_chunked=req.has_header('Transfer-encoding'))\n\n/usr/lib/python3.6/urllib/request.py:1318: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd5997f1908>, method = 'GET', url = '/batches', body = None\nheaders = {'Connection': 'close', 'Host': '192.168.1.23:8008', 'User-Agent': 'Python-urllib/3.6'}\n\n    def request(self, method, url, body=None, headers={}, *,\n                encode_chunked=False):\n        \"\"\"Send a complete request to the server.\"\"\"\n>       self._send_request(method, url, body, headers, encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1239: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd5997f1908>, method = 'GET', url = '/batches', body = None\nheaders = {'Connection': 'close', 'Host': '192.168.1.23:8008', 'User-Agent': 'Python-urllib/3.6'}, encode_chunked = False\n\n    def _send_request(self, method, url, body, headers, encode_chunked):\n        # Honor explicitly requested Host: and Accept-Encoding: headers.\n        header_names = frozenset(k.lower() for k in headers)\n        skips = {}\n        if 'host' in header_names:\n            skips['skip_host'] = 1\n        if 'accept-encoding' in header_names:\n            skips['skip_accept_encoding'] = 1\n    \n        self.putrequest(method, url, **skips)\n    \n        # chunked encoding will happen if HTTP/1.1 is used and either\n        # the caller passes encode_chunked=True or the following\n        # conditions hold:\n        # 1. content-length has not been explicitly set\n        # 2. the body is a file or iterable, but not a str or bytes-like\n        # 3. Transfer-Encoding has NOT been explicitly set by the caller\n    \n        if 'content-length' not in header_names:\n            # only chunk body if not explicitly set for backwards\n            # compatibility, assuming the client code is already handling the\n            # chunking\n            if 'transfer-encoding' not in header_names:\n                # if content-length cannot be automatically determined, fall\n                # back to chunked encoding\n                encode_chunked = False\n                content_length = self._get_content_length(body, method)\n                if content_length is None:\n                    if body is not None:\n                        if self.debuglevel > 0:\n                            print('Unable to determine size of %r' % body)\n                        encode_chunked = True\n                        self.putheader('Transfer-Encoding', 'chunked')\n                else:\n                    self.putheader('Content-Length', str(content_length))\n        else:\n            encode_chunked = False\n    \n        for hdr, value in headers.items():\n            self.putheader(hdr, value)\n        if isinstance(body, str):\n            # RFC 2616 Section 3.7.1 says that text default has a\n            # default charset of iso-8859-1.\n            body = _encode(body, 'body')\n>       self.endheaders(body, encode_chunked=encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1285: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd5997f1908>, message_body = None\n\n    def endheaders(self, message_body=None, *, encode_chunked=False):\n        \"\"\"Indicate that the last header line has been sent to the server.\n    \n        This method sends the request to the server.  The optional message_body\n        argument can be used to pass a message body associated with the\n        request.\n        \"\"\"\n        if self.__state == _CS_REQ_STARTED:\n            self.__state = _CS_REQ_SENT\n        else:\n            raise CannotSendHeader()\n>       self._send_output(message_body, encode_chunked=encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1234: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd5997f1908>, message_body = None, encode_chunked = False\n\n    def _send_output(self, message_body=None, encode_chunked=False):\n        \"\"\"Send the currently buffered request and clear the buffer.\n    \n        Appends an extra \\\\r\\\\n to the buffer.\n        A message_body may be specified, to be appended to the request.\n        \"\"\"\n        self._buffer.extend((b\"\", b\"\"))\n        msg = b\"\\r\\n\".join(self._buffer)\n        del self._buffer[:]\n>       self.send(msg)\n\n/usr/lib/python3.6/http/client.py:1026: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd5997f1908>\ndata = b'GET /batches HTTP/1.1\\r\\nAccept-Encoding: identity\\r\\nHost: 192.168.1.23:8008\\r\\nUser-Agent: Python-urllib/3.6\\r\\nConnection: close\\r\\n\\r\\n'\n\n    def send(self, data):\n        \"\"\"Send `data' to the server.\n        ``data`` can be a string object, a bytes object, an array object, a\n        file-like object that supports a .read() method, or an iterable object.\n        \"\"\"\n    \n        if self.sock is None:\n            if self.auto_open:\n>               self.connect()\n\n/usr/lib/python3.6/http/client.py:964: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd5997f1908>\n\n    def connect(self):\n        \"\"\"Connect to the host and port specified in __init__.\"\"\"\n        self.sock = self._create_connection(\n>           (self.host,self.port), self.timeout, self.source_address)\n\n/usr/lib/python3.6/http/client.py:936: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('192.168.1.23', 8008), timeout = <object object at 0x7fd5a15eb580>, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n                sock.connect(sa)\n                # Break explicitly a reference cycle\n                err = None\n                return sock\n    \n            except error as _:\n                err = _\n                if sock is not None:\n                    sock.close()\n    \n        if err is not None:\n>           raise err\n\n/usr/lib/python3.6/socket.py:724: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('192.168.1.23', 8008), timeout = <object object at 0x7fd5a15eb580>, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [Errno 111] Connection refused\n\n/usr/lib/python3.6/socket.py:713: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nrequest = <SubRequest 'setup_invalid_txns_max' for <Function test_txn_invalid_max>>\n\n    @pytest.fixture(scope=\"function\")\n    def setup_invalid_txns_max(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        Txns=Transactions(invalidtype=\"max\")\n>       data = Txns.get_batch_invalid_txns()\n\nfixtures.py:221: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npayload.py:301: in get_batch_invalid_txns\n    self.data = self.get_txns_commit_data(txns,self.signer, self.data)\npayload.py:360: in get_txns_commit_data\n    initial_batch_length = batch_count()\nutils.py:377: in batch_count\n    batch_list = get_batches()\nutils.py:92: in get_batches\n    response = query_rest_api('/batches')\nutils.py:183: in query_rest_api\n    return submit_request(urllib.request.Request(url, data, headers))\nutils.py:186: in submit_request\n    response = urllib.request.urlopen(request).read().decode('utf-8')\n/usr/lib/python3.6/urllib/request.py:223: in urlopen\n    return opener.open(url, data, timeout)\n/usr/lib/python3.6/urllib/request.py:526: in open\n    response = self._open(req, data)\n/usr/lib/python3.6/urllib/request.py:544: in _open\n    '_open', req)\n/usr/lib/python3.6/urllib/request.py:504: in _call_chain\n    result = func(*args)\n/usr/lib/python3.6/urllib/request.py:1346: in http_open\n    return self.do_open(http.client.HTTPConnection, req)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib.request.HTTPHandler object at 0x7fd599cb66d8>, http_class = <class 'http.client.HTTPConnection'>, req = <urllib.request.Request object at 0x7fd599b0b438>\nhttp_conn_args = {}, host = '192.168.1.23:8008', h = <http.client.HTTPConnection object at 0x7fd5997f1908>\n\n    def do_open(self, http_class, req, **http_conn_args):\n        \"\"\"Return an HTTPResponse object for the request, using http_class.\n    \n        http_class must implement the HTTPConnection API from http.client.\n        \"\"\"\n        host = req.host\n        if not host:\n            raise URLError('no host given')\n    \n        # will parse host:port\n        h = http_class(host, timeout=req.timeout, **http_conn_args)\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # TODO(jhylton): Should this be redesigned to handle\n        # persistent connections?\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict((name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            try:\n                h.request(req.get_method(), req.selector, req.data, headers,\n                          encode_chunked=req.has_header('Transfer-encoding'))\n            except OSError as err: # timeout error\n>               raise URLError(err)\nE               urllib.error.URLError: <urlopen error [Errno 111] Connection refused>\n\n/usr/lib/python3.6/urllib/request.py:1320: URLError"}, "teardown": {"duration": 0.00029277801513671875, "outcome": "passed"}}, {"nodeid": "post/test_rest_api_post.py::TestPostInvalidTxns::test_txn_valid_invalid_txns", "lineno": 541, "outcome": "error", "keywords": ["run", "post/test_rest_api_post.py", "post", "last", "api_test", "test_txn_valid_invalid_txns", "TestPostInvalidTxns", "()"], "metadata": {"0": "Tests that transactions are submitted and committed for\neach block that are created by submitting intkey batches\nwith set operations", "1": "\"Tests rest api by posting no batches\n        ", "2": "Tests rest api by posting with bad protobuf\n        ", "3": "Tests rest api by posting with wrong header\n        ", "4": "Tests the rest-api by submitting multiple transactions with same key\n        ", "5": "Tests rest-api state by submitting multiple\ntransactions in multiple batches", "6": "Tests rest-api state by submitting\ntransactions in empty transaction list", "7": "Tests rest-api state by submitting \ntransactions with different signer ", "8": "Tests rest-api state by submitting\ntransactions with no endpoint", "9": "Tests rest-api state by submitting invalid \ntransactions with invalid address ", "10": "Tests rest-api state by submitting invalid \ntransactions with minimum address length ", "11": "Tests rest-api state by submitting invalid \ntransactions with maximum address length ", "12": "Tests rest-api state by submitting valid \ntransactions with invalid transactions", "13": "Tests rest-api state by submitting invalid \ntransactions with valid transactions", "14": "Tests rest-api state by submitting invalid \ntransactions with same transactions", "15": "Tests rest-api state by submitting invalid \ntransactions with commit transactions", "16": "Tests rest-api state by submitting invalid \ntransactions with invalid bad  address ", "17": "Tests rest-api state by submitting invalid \ntransactions with invalid family name"}, "setup": {"duration": 0.025866031646728516, "outcome": "failed", "crash": {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1320, "message": "urllib.error.URLError: <urlopen error [Errno 111] Connection refused>"}, "traceback": [{"path": "fixtures.py", "lineno": 163, "message": ""}, {"path": "payload.py", "lineno": 275, "message": "in get_batch_valinv_txns"}, {"path": "payload.py", "lineno": 360, "message": "in get_txns_commit_data"}, {"path": "utils.py", "lineno": 377, "message": "in batch_count"}, {"path": "utils.py", "lineno": 92, "message": "in get_batches"}, {"path": "utils.py", "lineno": 183, "message": "in query_rest_api"}, {"path": "utils.py", "lineno": 186, "message": "in submit_request"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 223, "message": "in urlopen"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 526, "message": "in open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 544, "message": "in _open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 504, "message": "in _call_chain"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1346, "message": "in http_open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1320, "message": "URLError"}], "longrepr": "self = <urllib.request.HTTPHandler object at 0x7fd599cb66d8>, http_class = <class 'http.client.HTTPConnection'>, req = <urllib.request.Request object at 0x7fd599b0c2e8>\nhttp_conn_args = {}, host = '192.168.1.23:8008', h = <http.client.HTTPConnection object at 0x7fd599b0c3c8>\n\n    def do_open(self, http_class, req, **http_conn_args):\n        \"\"\"Return an HTTPResponse object for the request, using http_class.\n    \n        http_class must implement the HTTPConnection API from http.client.\n        \"\"\"\n        host = req.host\n        if not host:\n            raise URLError('no host given')\n    \n        # will parse host:port\n        h = http_class(host, timeout=req.timeout, **http_conn_args)\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # TODO(jhylton): Should this be redesigned to handle\n        # persistent connections?\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict((name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            try:\n                h.request(req.get_method(), req.selector, req.data, headers,\n>                         encode_chunked=req.has_header('Transfer-encoding'))\n\n/usr/lib/python3.6/urllib/request.py:1318: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599b0c3c8>, method = 'GET', url = '/batches', body = None\nheaders = {'Connection': 'close', 'Host': '192.168.1.23:8008', 'User-Agent': 'Python-urllib/3.6'}\n\n    def request(self, method, url, body=None, headers={}, *,\n                encode_chunked=False):\n        \"\"\"Send a complete request to the server.\"\"\"\n>       self._send_request(method, url, body, headers, encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1239: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599b0c3c8>, method = 'GET', url = '/batches', body = None\nheaders = {'Connection': 'close', 'Host': '192.168.1.23:8008', 'User-Agent': 'Python-urllib/3.6'}, encode_chunked = False\n\n    def _send_request(self, method, url, body, headers, encode_chunked):\n        # Honor explicitly requested Host: and Accept-Encoding: headers.\n        header_names = frozenset(k.lower() for k in headers)\n        skips = {}\n        if 'host' in header_names:\n            skips['skip_host'] = 1\n        if 'accept-encoding' in header_names:\n            skips['skip_accept_encoding'] = 1\n    \n        self.putrequest(method, url, **skips)\n    \n        # chunked encoding will happen if HTTP/1.1 is used and either\n        # the caller passes encode_chunked=True or the following\n        # conditions hold:\n        # 1. content-length has not been explicitly set\n        # 2. the body is a file or iterable, but not a str or bytes-like\n        # 3. Transfer-Encoding has NOT been explicitly set by the caller\n    \n        if 'content-length' not in header_names:\n            # only chunk body if not explicitly set for backwards\n            # compatibility, assuming the client code is already handling the\n            # chunking\n            if 'transfer-encoding' not in header_names:\n                # if content-length cannot be automatically determined, fall\n                # back to chunked encoding\n                encode_chunked = False\n                content_length = self._get_content_length(body, method)\n                if content_length is None:\n                    if body is not None:\n                        if self.debuglevel > 0:\n                            print('Unable to determine size of %r' % body)\n                        encode_chunked = True\n                        self.putheader('Transfer-Encoding', 'chunked')\n                else:\n                    self.putheader('Content-Length', str(content_length))\n        else:\n            encode_chunked = False\n    \n        for hdr, value in headers.items():\n            self.putheader(hdr, value)\n        if isinstance(body, str):\n            # RFC 2616 Section 3.7.1 says that text default has a\n            # default charset of iso-8859-1.\n            body = _encode(body, 'body')\n>       self.endheaders(body, encode_chunked=encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1285: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599b0c3c8>, message_body = None\n\n    def endheaders(self, message_body=None, *, encode_chunked=False):\n        \"\"\"Indicate that the last header line has been sent to the server.\n    \n        This method sends the request to the server.  The optional message_body\n        argument can be used to pass a message body associated with the\n        request.\n        \"\"\"\n        if self.__state == _CS_REQ_STARTED:\n            self.__state = _CS_REQ_SENT\n        else:\n            raise CannotSendHeader()\n>       self._send_output(message_body, encode_chunked=encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1234: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599b0c3c8>, message_body = None, encode_chunked = False\n\n    def _send_output(self, message_body=None, encode_chunked=False):\n        \"\"\"Send the currently buffered request and clear the buffer.\n    \n        Appends an extra \\\\r\\\\n to the buffer.\n        A message_body may be specified, to be appended to the request.\n        \"\"\"\n        self._buffer.extend((b\"\", b\"\"))\n        msg = b\"\\r\\n\".join(self._buffer)\n        del self._buffer[:]\n>       self.send(msg)\n\n/usr/lib/python3.6/http/client.py:1026: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599b0c3c8>\ndata = b'GET /batches HTTP/1.1\\r\\nAccept-Encoding: identity\\r\\nHost: 192.168.1.23:8008\\r\\nUser-Agent: Python-urllib/3.6\\r\\nConnection: close\\r\\n\\r\\n'\n\n    def send(self, data):\n        \"\"\"Send `data' to the server.\n        ``data`` can be a string object, a bytes object, an array object, a\n        file-like object that supports a .read() method, or an iterable object.\n        \"\"\"\n    \n        if self.sock is None:\n            if self.auto_open:\n>               self.connect()\n\n/usr/lib/python3.6/http/client.py:964: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599b0c3c8>\n\n    def connect(self):\n        \"\"\"Connect to the host and port specified in __init__.\"\"\"\n        self.sock = self._create_connection(\n>           (self.host,self.port), self.timeout, self.source_address)\n\n/usr/lib/python3.6/http/client.py:936: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('192.168.1.23', 8008), timeout = <object object at 0x7fd5a15eb580>, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n                sock.connect(sa)\n                # Break explicitly a reference cycle\n                err = None\n                return sock\n    \n            except error as _:\n                err = _\n                if sock is not None:\n                    sock.close()\n    \n        if err is not None:\n>           raise err\n\n/usr/lib/python3.6/socket.py:724: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('192.168.1.23', 8008), timeout = <object object at 0x7fd5a15eb580>, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [Errno 111] Connection refused\n\n/usr/lib/python3.6/socket.py:713: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nrequest = <SubRequest 'setup_valinv_txns' for <Function test_txn_valid_invalid_txns>>\n\n    @pytest.fixture(scope=\"function\")\n    def setup_valinv_txns(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        Txns=Transactions(invalidtype=\"addr\")\n>       data = Txns.get_batch_valinv_txns()\n\nfixtures.py:163: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npayload.py:275: in get_batch_valinv_txns\n    self.data = self.get_txns_commit_data(txns,self.signer, self.data)\npayload.py:360: in get_txns_commit_data\n    initial_batch_length = batch_count()\nutils.py:377: in batch_count\n    batch_list = get_batches()\nutils.py:92: in get_batches\n    response = query_rest_api('/batches')\nutils.py:183: in query_rest_api\n    return submit_request(urllib.request.Request(url, data, headers))\nutils.py:186: in submit_request\n    response = urllib.request.urlopen(request).read().decode('utf-8')\n/usr/lib/python3.6/urllib/request.py:223: in urlopen\n    return opener.open(url, data, timeout)\n/usr/lib/python3.6/urllib/request.py:526: in open\n    response = self._open(req, data)\n/usr/lib/python3.6/urllib/request.py:544: in _open\n    '_open', req)\n/usr/lib/python3.6/urllib/request.py:504: in _call_chain\n    result = func(*args)\n/usr/lib/python3.6/urllib/request.py:1346: in http_open\n    return self.do_open(http.client.HTTPConnection, req)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib.request.HTTPHandler object at 0x7fd599cb66d8>, http_class = <class 'http.client.HTTPConnection'>, req = <urllib.request.Request object at 0x7fd599b0c2e8>\nhttp_conn_args = {}, host = '192.168.1.23:8008', h = <http.client.HTTPConnection object at 0x7fd599b0c3c8>\n\n    def do_open(self, http_class, req, **http_conn_args):\n        \"\"\"Return an HTTPResponse object for the request, using http_class.\n    \n        http_class must implement the HTTPConnection API from http.client.\n        \"\"\"\n        host = req.host\n        if not host:\n            raise URLError('no host given')\n    \n        # will parse host:port\n        h = http_class(host, timeout=req.timeout, **http_conn_args)\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # TODO(jhylton): Should this be redesigned to handle\n        # persistent connections?\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict((name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            try:\n                h.request(req.get_method(), req.selector, req.data, headers,\n                          encode_chunked=req.has_header('Transfer-encoding'))\n            except OSError as err: # timeout error\n>               raise URLError(err)\nE               urllib.error.URLError: <urlopen error [Errno 111] Connection refused>\n\n/usr/lib/python3.6/urllib/request.py:1320: URLError"}, "teardown": {"duration": 0.00027441978454589844, "outcome": "passed"}}, {"nodeid": "post/test_rest_api_post.py::TestPostInvalidTxns::test_txn_invalid_valid_txns", "lineno": 553, "outcome": "error", "keywords": ["run", "post/test_rest_api_post.py", "post", "last", "api_test", "test_txn_invalid_valid_txns", "TestPostInvalidTxns", "()"], "metadata": {"0": "Tests that transactions are submitted and committed for\neach block that are created by submitting intkey batches\nwith set operations", "1": "\"Tests rest api by posting no batches\n        ", "2": "Tests rest api by posting with bad protobuf\n        ", "3": "Tests rest api by posting with wrong header\n        ", "4": "Tests the rest-api by submitting multiple transactions with same key\n        ", "5": "Tests rest-api state by submitting multiple\ntransactions in multiple batches", "6": "Tests rest-api state by submitting\ntransactions in empty transaction list", "7": "Tests rest-api state by submitting \ntransactions with different signer ", "8": "Tests rest-api state by submitting\ntransactions with no endpoint", "9": "Tests rest-api state by submitting invalid \ntransactions with invalid address ", "10": "Tests rest-api state by submitting invalid \ntransactions with minimum address length ", "11": "Tests rest-api state by submitting invalid \ntransactions with maximum address length ", "12": "Tests rest-api state by submitting valid \ntransactions with invalid transactions", "13": "Tests rest-api state by submitting invalid \ntransactions with valid transactions", "14": "Tests rest-api state by submitting invalid \ntransactions with same transactions", "15": "Tests rest-api state by submitting invalid \ntransactions with commit transactions", "16": "Tests rest-api state by submitting invalid \ntransactions with invalid bad  address ", "17": "Tests rest-api state by submitting invalid \ntransactions with invalid family name"}, "setup": {"duration": 0.025858402252197266, "outcome": "failed", "crash": {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1320, "message": "urllib.error.URLError: <urlopen error [Errno 111] Connection refused>"}, "traceback": [{"path": "fixtures.py", "lineno": 173, "message": ""}, {"path": "payload.py", "lineno": 287, "message": "in get_batch_invval_txns"}, {"path": "payload.py", "lineno": 360, "message": "in get_txns_commit_data"}, {"path": "utils.py", "lineno": 377, "message": "in batch_count"}, {"path": "utils.py", "lineno": 92, "message": "in get_batches"}, {"path": "utils.py", "lineno": 183, "message": "in query_rest_api"}, {"path": "utils.py", "lineno": 186, "message": "in submit_request"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 223, "message": "in urlopen"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 526, "message": "in open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 544, "message": "in _open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 504, "message": "in _call_chain"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1346, "message": "in http_open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1320, "message": "URLError"}], "longrepr": "self = <urllib.request.HTTPHandler object at 0x7fd599cb66d8>, http_class = <class 'http.client.HTTPConnection'>, req = <urllib.request.Request object at 0x7fd59984a240>\nhttp_conn_args = {}, host = '192.168.1.23:8008', h = <http.client.HTTPConnection object at 0x7fd59984a5f8>\n\n    def do_open(self, http_class, req, **http_conn_args):\n        \"\"\"Return an HTTPResponse object for the request, using http_class.\n    \n        http_class must implement the HTTPConnection API from http.client.\n        \"\"\"\n        host = req.host\n        if not host:\n            raise URLError('no host given')\n    \n        # will parse host:port\n        h = http_class(host, timeout=req.timeout, **http_conn_args)\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # TODO(jhylton): Should this be redesigned to handle\n        # persistent connections?\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict((name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            try:\n                h.request(req.get_method(), req.selector, req.data, headers,\n>                         encode_chunked=req.has_header('Transfer-encoding'))\n\n/usr/lib/python3.6/urllib/request.py:1318: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd59984a5f8>, method = 'GET', url = '/batches', body = None\nheaders = {'Connection': 'close', 'Host': '192.168.1.23:8008', 'User-Agent': 'Python-urllib/3.6'}\n\n    def request(self, method, url, body=None, headers={}, *,\n                encode_chunked=False):\n        \"\"\"Send a complete request to the server.\"\"\"\n>       self._send_request(method, url, body, headers, encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1239: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd59984a5f8>, method = 'GET', url = '/batches', body = None\nheaders = {'Connection': 'close', 'Host': '192.168.1.23:8008', 'User-Agent': 'Python-urllib/3.6'}, encode_chunked = False\n\n    def _send_request(self, method, url, body, headers, encode_chunked):\n        # Honor explicitly requested Host: and Accept-Encoding: headers.\n        header_names = frozenset(k.lower() for k in headers)\n        skips = {}\n        if 'host' in header_names:\n            skips['skip_host'] = 1\n        if 'accept-encoding' in header_names:\n            skips['skip_accept_encoding'] = 1\n    \n        self.putrequest(method, url, **skips)\n    \n        # chunked encoding will happen if HTTP/1.1 is used and either\n        # the caller passes encode_chunked=True or the following\n        # conditions hold:\n        # 1. content-length has not been explicitly set\n        # 2. the body is a file or iterable, but not a str or bytes-like\n        # 3. Transfer-Encoding has NOT been explicitly set by the caller\n    \n        if 'content-length' not in header_names:\n            # only chunk body if not explicitly set for backwards\n            # compatibility, assuming the client code is already handling the\n            # chunking\n            if 'transfer-encoding' not in header_names:\n                # if content-length cannot be automatically determined, fall\n                # back to chunked encoding\n                encode_chunked = False\n                content_length = self._get_content_length(body, method)\n                if content_length is None:\n                    if body is not None:\n                        if self.debuglevel > 0:\n                            print('Unable to determine size of %r' % body)\n                        encode_chunked = True\n                        self.putheader('Transfer-Encoding', 'chunked')\n                else:\n                    self.putheader('Content-Length', str(content_length))\n        else:\n            encode_chunked = False\n    \n        for hdr, value in headers.items():\n            self.putheader(hdr, value)\n        if isinstance(body, str):\n            # RFC 2616 Section 3.7.1 says that text default has a\n            # default charset of iso-8859-1.\n            body = _encode(body, 'body')\n>       self.endheaders(body, encode_chunked=encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1285: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd59984a5f8>, message_body = None\n\n    def endheaders(self, message_body=None, *, encode_chunked=False):\n        \"\"\"Indicate that the last header line has been sent to the server.\n    \n        This method sends the request to the server.  The optional message_body\n        argument can be used to pass a message body associated with the\n        request.\n        \"\"\"\n        if self.__state == _CS_REQ_STARTED:\n            self.__state = _CS_REQ_SENT\n        else:\n            raise CannotSendHeader()\n>       self._send_output(message_body, encode_chunked=encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1234: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd59984a5f8>, message_body = None, encode_chunked = False\n\n    def _send_output(self, message_body=None, encode_chunked=False):\n        \"\"\"Send the currently buffered request and clear the buffer.\n    \n        Appends an extra \\\\r\\\\n to the buffer.\n        A message_body may be specified, to be appended to the request.\n        \"\"\"\n        self._buffer.extend((b\"\", b\"\"))\n        msg = b\"\\r\\n\".join(self._buffer)\n        del self._buffer[:]\n>       self.send(msg)\n\n/usr/lib/python3.6/http/client.py:1026: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd59984a5f8>\ndata = b'GET /batches HTTP/1.1\\r\\nAccept-Encoding: identity\\r\\nHost: 192.168.1.23:8008\\r\\nUser-Agent: Python-urllib/3.6\\r\\nConnection: close\\r\\n\\r\\n'\n\n    def send(self, data):\n        \"\"\"Send `data' to the server.\n        ``data`` can be a string object, a bytes object, an array object, a\n        file-like object that supports a .read() method, or an iterable object.\n        \"\"\"\n    \n        if self.sock is None:\n            if self.auto_open:\n>               self.connect()\n\n/usr/lib/python3.6/http/client.py:964: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd59984a5f8>\n\n    def connect(self):\n        \"\"\"Connect to the host and port specified in __init__.\"\"\"\n        self.sock = self._create_connection(\n>           (self.host,self.port), self.timeout, self.source_address)\n\n/usr/lib/python3.6/http/client.py:936: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('192.168.1.23', 8008), timeout = <object object at 0x7fd5a15eb580>, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n                sock.connect(sa)\n                # Break explicitly a reference cycle\n                err = None\n                return sock\n    \n            except error as _:\n                err = _\n                if sock is not None:\n                    sock.close()\n    \n        if err is not None:\n>           raise err\n\n/usr/lib/python3.6/socket.py:724: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('192.168.1.23', 8008), timeout = <object object at 0x7fd5a15eb580>, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [Errno 111] Connection refused\n\n/usr/lib/python3.6/socket.py:713: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nrequest = <SubRequest 'setup_invval_txns' for <Function test_txn_invalid_valid_txns>>\n\n    @pytest.fixture(scope=\"function\")\n    def setup_invval_txns(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        Txns=Transactions(invalidtype=\"addr\")\n>       data = Txns.get_batch_invval_txns()\n\nfixtures.py:173: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npayload.py:287: in get_batch_invval_txns\n    self.data = self.get_txns_commit_data(txns,self.signer, self.data)\npayload.py:360: in get_txns_commit_data\n    initial_batch_length = batch_count()\nutils.py:377: in batch_count\n    batch_list = get_batches()\nutils.py:92: in get_batches\n    response = query_rest_api('/batches')\nutils.py:183: in query_rest_api\n    return submit_request(urllib.request.Request(url, data, headers))\nutils.py:186: in submit_request\n    response = urllib.request.urlopen(request).read().decode('utf-8')\n/usr/lib/python3.6/urllib/request.py:223: in urlopen\n    return opener.open(url, data, timeout)\n/usr/lib/python3.6/urllib/request.py:526: in open\n    response = self._open(req, data)\n/usr/lib/python3.6/urllib/request.py:544: in _open\n    '_open', req)\n/usr/lib/python3.6/urllib/request.py:504: in _call_chain\n    result = func(*args)\n/usr/lib/python3.6/urllib/request.py:1346: in http_open\n    return self.do_open(http.client.HTTPConnection, req)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib.request.HTTPHandler object at 0x7fd599cb66d8>, http_class = <class 'http.client.HTTPConnection'>, req = <urllib.request.Request object at 0x7fd59984a240>\nhttp_conn_args = {}, host = '192.168.1.23:8008', h = <http.client.HTTPConnection object at 0x7fd59984a5f8>\n\n    def do_open(self, http_class, req, **http_conn_args):\n        \"\"\"Return an HTTPResponse object for the request, using http_class.\n    \n        http_class must implement the HTTPConnection API from http.client.\n        \"\"\"\n        host = req.host\n        if not host:\n            raise URLError('no host given')\n    \n        # will parse host:port\n        h = http_class(host, timeout=req.timeout, **http_conn_args)\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # TODO(jhylton): Should this be redesigned to handle\n        # persistent connections?\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict((name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            try:\n                h.request(req.get_method(), req.selector, req.data, headers,\n                          encode_chunked=req.has_header('Transfer-encoding'))\n            except OSError as err: # timeout error\n>               raise URLError(err)\nE               urllib.error.URLError: <urlopen error [Errno 111] Connection refused>\n\n/usr/lib/python3.6/urllib/request.py:1320: URLError"}, "teardown": {"duration": 0.0003104209899902344, "outcome": "passed"}}, {"nodeid": "post/test_rest_api_post.py::TestPostInvalidTxns::test_txn_same_txns", "lineno": 565, "outcome": "error", "keywords": ["run", "post/test_rest_api_post.py", "post", "last", "api_test", "test_txn_same_txns", "TestPostInvalidTxns", "()"], "metadata": {"0": "Tests that transactions are submitted and committed for\neach block that are created by submitting intkey batches\nwith set operations", "1": "\"Tests rest api by posting no batches\n        ", "2": "Tests rest api by posting with bad protobuf\n        ", "3": "Tests rest api by posting with wrong header\n        ", "4": "Tests the rest-api by submitting multiple transactions with same key\n        ", "5": "Tests rest-api state by submitting multiple\ntransactions in multiple batches", "6": "Tests rest-api state by submitting\ntransactions in empty transaction list", "7": "Tests rest-api state by submitting \ntransactions with different signer ", "8": "Tests rest-api state by submitting\ntransactions with no endpoint", "9": "Tests rest-api state by submitting invalid \ntransactions with invalid address ", "10": "Tests rest-api state by submitting invalid \ntransactions with minimum address length ", "11": "Tests rest-api state by submitting invalid \ntransactions with maximum address length ", "12": "Tests rest-api state by submitting valid \ntransactions with invalid transactions", "13": "Tests rest-api state by submitting invalid \ntransactions with valid transactions", "14": "Tests rest-api state by submitting invalid \ntransactions with same transactions", "15": "Tests rest-api state by submitting invalid \ntransactions with commit transactions", "16": "Tests rest-api state by submitting invalid \ntransactions with invalid bad  address ", "17": "Tests rest-api state by submitting invalid \ntransactions with invalid family name"}, "setup": {"duration": 0.00438237190246582, "outcome": "failed", "crash": {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1320, "message": "urllib.error.URLError: <urlopen error [Errno 111] Connection refused>"}, "traceback": [{"path": "fixtures.py", "lineno": 203, "message": ""}, {"path": "payload.py", "lineno": 335, "message": "in get_batch_same_txns"}, {"path": "payload.py", "lineno": 360, "message": "in get_txns_commit_data"}, {"path": "utils.py", "lineno": 377, "message": "in batch_count"}, {"path": "utils.py", "lineno": 92, "message": "in get_batches"}, {"path": "utils.py", "lineno": 183, "message": "in query_rest_api"}, {"path": "utils.py", "lineno": 186, "message": "in submit_request"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 223, "message": "in urlopen"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 526, "message": "in open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 544, "message": "in _open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 504, "message": "in _call_chain"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1346, "message": "in http_open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1320, "message": "URLError"}], "longrepr": "self = <urllib.request.HTTPHandler object at 0x7fd599cb66d8>, http_class = <class 'http.client.HTTPConnection'>, req = <urllib.request.Request object at 0x7fd5998fb7f0>\nhttp_conn_args = {}, host = '192.168.1.23:8008', h = <http.client.HTTPConnection object at 0x7fd599539978>\n\n    def do_open(self, http_class, req, **http_conn_args):\n        \"\"\"Return an HTTPResponse object for the request, using http_class.\n    \n        http_class must implement the HTTPConnection API from http.client.\n        \"\"\"\n        host = req.host\n        if not host:\n            raise URLError('no host given')\n    \n        # will parse host:port\n        h = http_class(host, timeout=req.timeout, **http_conn_args)\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # TODO(jhylton): Should this be redesigned to handle\n        # persistent connections?\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict((name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            try:\n                h.request(req.get_method(), req.selector, req.data, headers,\n>                         encode_chunked=req.has_header('Transfer-encoding'))\n\n/usr/lib/python3.6/urllib/request.py:1318: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599539978>, method = 'GET', url = '/batches', body = None\nheaders = {'Connection': 'close', 'Host': '192.168.1.23:8008', 'User-Agent': 'Python-urllib/3.6'}\n\n    def request(self, method, url, body=None, headers={}, *,\n                encode_chunked=False):\n        \"\"\"Send a complete request to the server.\"\"\"\n>       self._send_request(method, url, body, headers, encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1239: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599539978>, method = 'GET', url = '/batches', body = None\nheaders = {'Connection': 'close', 'Host': '192.168.1.23:8008', 'User-Agent': 'Python-urllib/3.6'}, encode_chunked = False\n\n    def _send_request(self, method, url, body, headers, encode_chunked):\n        # Honor explicitly requested Host: and Accept-Encoding: headers.\n        header_names = frozenset(k.lower() for k in headers)\n        skips = {}\n        if 'host' in header_names:\n            skips['skip_host'] = 1\n        if 'accept-encoding' in header_names:\n            skips['skip_accept_encoding'] = 1\n    \n        self.putrequest(method, url, **skips)\n    \n        # chunked encoding will happen if HTTP/1.1 is used and either\n        # the caller passes encode_chunked=True or the following\n        # conditions hold:\n        # 1. content-length has not been explicitly set\n        # 2. the body is a file or iterable, but not a str or bytes-like\n        # 3. Transfer-Encoding has NOT been explicitly set by the caller\n    \n        if 'content-length' not in header_names:\n            # only chunk body if not explicitly set for backwards\n            # compatibility, assuming the client code is already handling the\n            # chunking\n            if 'transfer-encoding' not in header_names:\n                # if content-length cannot be automatically determined, fall\n                # back to chunked encoding\n                encode_chunked = False\n                content_length = self._get_content_length(body, method)\n                if content_length is None:\n                    if body is not None:\n                        if self.debuglevel > 0:\n                            print('Unable to determine size of %r' % body)\n                        encode_chunked = True\n                        self.putheader('Transfer-Encoding', 'chunked')\n                else:\n                    self.putheader('Content-Length', str(content_length))\n        else:\n            encode_chunked = False\n    \n        for hdr, value in headers.items():\n            self.putheader(hdr, value)\n        if isinstance(body, str):\n            # RFC 2616 Section 3.7.1 says that text default has a\n            # default charset of iso-8859-1.\n            body = _encode(body, 'body')\n>       self.endheaders(body, encode_chunked=encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1285: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599539978>, message_body = None\n\n    def endheaders(self, message_body=None, *, encode_chunked=False):\n        \"\"\"Indicate that the last header line has been sent to the server.\n    \n        This method sends the request to the server.  The optional message_body\n        argument can be used to pass a message body associated with the\n        request.\n        \"\"\"\n        if self.__state == _CS_REQ_STARTED:\n            self.__state = _CS_REQ_SENT\n        else:\n            raise CannotSendHeader()\n>       self._send_output(message_body, encode_chunked=encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1234: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599539978>, message_body = None, encode_chunked = False\n\n    def _send_output(self, message_body=None, encode_chunked=False):\n        \"\"\"Send the currently buffered request and clear the buffer.\n    \n        Appends an extra \\\\r\\\\n to the buffer.\n        A message_body may be specified, to be appended to the request.\n        \"\"\"\n        self._buffer.extend((b\"\", b\"\"))\n        msg = b\"\\r\\n\".join(self._buffer)\n        del self._buffer[:]\n>       self.send(msg)\n\n/usr/lib/python3.6/http/client.py:1026: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599539978>\ndata = b'GET /batches HTTP/1.1\\r\\nAccept-Encoding: identity\\r\\nHost: 192.168.1.23:8008\\r\\nUser-Agent: Python-urllib/3.6\\r\\nConnection: close\\r\\n\\r\\n'\n\n    def send(self, data):\n        \"\"\"Send `data' to the server.\n        ``data`` can be a string object, a bytes object, an array object, a\n        file-like object that supports a .read() method, or an iterable object.\n        \"\"\"\n    \n        if self.sock is None:\n            if self.auto_open:\n>               self.connect()\n\n/usr/lib/python3.6/http/client.py:964: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599539978>\n\n    def connect(self):\n        \"\"\"Connect to the host and port specified in __init__.\"\"\"\n        self.sock = self._create_connection(\n>           (self.host,self.port), self.timeout, self.source_address)\n\n/usr/lib/python3.6/http/client.py:936: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('192.168.1.23', 8008), timeout = <object object at 0x7fd5a15eb580>, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n                sock.connect(sa)\n                # Break explicitly a reference cycle\n                err = None\n                return sock\n    \n            except error as _:\n                err = _\n                if sock is not None:\n                    sock.close()\n    \n        if err is not None:\n>           raise err\n\n/usr/lib/python3.6/socket.py:724: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('192.168.1.23', 8008), timeout = <object object at 0x7fd5a15eb580>, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [Errno 111] Connection refused\n\n/usr/lib/python3.6/socket.py:713: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nrequest = <SubRequest 'setup_same_txns' for <Function test_txn_same_txns>>\n\n    @pytest.fixture(scope=\"function\")\n    def setup_same_txns(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        Txns=Transactions(invalidtype=\"addr\")\n>       data = Txns.get_batch_same_txns()\n\nfixtures.py:203: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npayload.py:335: in get_batch_same_txns\n    self.data = self.get_txns_commit_data(txns,self.signer, self.data)\npayload.py:360: in get_txns_commit_data\n    initial_batch_length = batch_count()\nutils.py:377: in batch_count\n    batch_list = get_batches()\nutils.py:92: in get_batches\n    response = query_rest_api('/batches')\nutils.py:183: in query_rest_api\n    return submit_request(urllib.request.Request(url, data, headers))\nutils.py:186: in submit_request\n    response = urllib.request.urlopen(request).read().decode('utf-8')\n/usr/lib/python3.6/urllib/request.py:223: in urlopen\n    return opener.open(url, data, timeout)\n/usr/lib/python3.6/urllib/request.py:526: in open\n    response = self._open(req, data)\n/usr/lib/python3.6/urllib/request.py:544: in _open\n    '_open', req)\n/usr/lib/python3.6/urllib/request.py:504: in _call_chain\n    result = func(*args)\n/usr/lib/python3.6/urllib/request.py:1346: in http_open\n    return self.do_open(http.client.HTTPConnection, req)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib.request.HTTPHandler object at 0x7fd599cb66d8>, http_class = <class 'http.client.HTTPConnection'>, req = <urllib.request.Request object at 0x7fd5998fb7f0>\nhttp_conn_args = {}, host = '192.168.1.23:8008', h = <http.client.HTTPConnection object at 0x7fd599539978>\n\n    def do_open(self, http_class, req, **http_conn_args):\n        \"\"\"Return an HTTPResponse object for the request, using http_class.\n    \n        http_class must implement the HTTPConnection API from http.client.\n        \"\"\"\n        host = req.host\n        if not host:\n            raise URLError('no host given')\n    \n        # will parse host:port\n        h = http_class(host, timeout=req.timeout, **http_conn_args)\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # TODO(jhylton): Should this be redesigned to handle\n        # persistent connections?\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict((name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            try:\n                h.request(req.get_method(), req.selector, req.data, headers,\n                          encode_chunked=req.has_header('Transfer-encoding'))\n            except OSError as err: # timeout error\n>               raise URLError(err)\nE               urllib.error.URLError: <urlopen error [Errno 111] Connection refused>\n\n/usr/lib/python3.6/urllib/request.py:1320: URLError"}, "teardown": {"duration": 0.0002734661102294922, "outcome": "passed"}}, {"nodeid": "post/test_rest_api_post.py::TestPostInvalidTxns::test_api_sent_commit_txns", "lineno": 577, "outcome": "error", "keywords": ["run", "post/test_rest_api_post.py", "post", "last", "test_api_sent_commit_txns", "api_test", "TestPostInvalidTxns", "()"], "metadata": {"0": "Tests that transactions are submitted and committed for\neach block that are created by submitting intkey batches\nwith set operations", "1": "\"Tests rest api by posting no batches\n        ", "2": "Tests rest api by posting with bad protobuf\n        ", "3": "Tests rest api by posting with wrong header\n        ", "4": "Tests the rest-api by submitting multiple transactions with same key\n        ", "5": "Tests rest-api state by submitting multiple\ntransactions in multiple batches", "6": "Tests rest-api state by submitting\ntransactions in empty transaction list", "7": "Tests rest-api state by submitting \ntransactions with different signer ", "8": "Tests rest-api state by submitting\ntransactions with no endpoint", "9": "Tests rest-api state by submitting invalid \ntransactions with invalid address ", "10": "Tests rest-api state by submitting invalid \ntransactions with minimum address length ", "11": "Tests rest-api state by submitting invalid \ntransactions with maximum address length ", "12": "Tests rest-api state by submitting valid \ntransactions with invalid transactions", "13": "Tests rest-api state by submitting invalid \ntransactions with valid transactions", "14": "Tests rest-api state by submitting invalid \ntransactions with same transactions", "15": "Tests rest-api state by submitting invalid \ntransactions with commit transactions", "16": "Tests rest-api state by submitting invalid \ntransactions with invalid bad  address ", "17": "Tests rest-api state by submitting invalid \ntransactions with invalid family name"}, "setup": {"duration": 0.026210308074951172, "outcome": "failed", "crash": {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1320, "message": "urllib.error.URLError: <urlopen error [Errno 111] Connection refused>"}, "traceback": [{"path": "fixtures.py", "lineno": 230, "message": ""}, {"path": "payload.py", "lineno": 323, "message": "in get_batch_valid_txns"}, {"path": "payload.py", "lineno": 360, "message": "in get_txns_commit_data"}, {"path": "utils.py", "lineno": 377, "message": "in batch_count"}, {"path": "utils.py", "lineno": 92, "message": "in get_batches"}, {"path": "utils.py", "lineno": 183, "message": "in query_rest_api"}, {"path": "utils.py", "lineno": 186, "message": "in submit_request"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 223, "message": "in urlopen"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 526, "message": "in open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 544, "message": "in _open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 504, "message": "in _call_chain"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1346, "message": "in http_open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1320, "message": "URLError"}], "longrepr": "self = <urllib.request.HTTPHandler object at 0x7fd599cb66d8>, http_class = <class 'http.client.HTTPConnection'>, req = <urllib.request.Request object at 0x7fd5997c8dd8>\nhttp_conn_args = {}, host = '192.168.1.23:8008', h = <http.client.HTTPConnection object at 0x7fd5992b0860>\n\n    def do_open(self, http_class, req, **http_conn_args):\n        \"\"\"Return an HTTPResponse object for the request, using http_class.\n    \n        http_class must implement the HTTPConnection API from http.client.\n        \"\"\"\n        host = req.host\n        if not host:\n            raise URLError('no host given')\n    \n        # will parse host:port\n        h = http_class(host, timeout=req.timeout, **http_conn_args)\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # TODO(jhylton): Should this be redesigned to handle\n        # persistent connections?\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict((name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            try:\n                h.request(req.get_method(), req.selector, req.data, headers,\n>                         encode_chunked=req.has_header('Transfer-encoding'))\n\n/usr/lib/python3.6/urllib/request.py:1318: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd5992b0860>, method = 'GET', url = '/batches', body = None\nheaders = {'Connection': 'close', 'Host': '192.168.1.23:8008', 'User-Agent': 'Python-urllib/3.6'}\n\n    def request(self, method, url, body=None, headers={}, *,\n                encode_chunked=False):\n        \"\"\"Send a complete request to the server.\"\"\"\n>       self._send_request(method, url, body, headers, encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1239: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd5992b0860>, method = 'GET', url = '/batches', body = None\nheaders = {'Connection': 'close', 'Host': '192.168.1.23:8008', 'User-Agent': 'Python-urllib/3.6'}, encode_chunked = False\n\n    def _send_request(self, method, url, body, headers, encode_chunked):\n        # Honor explicitly requested Host: and Accept-Encoding: headers.\n        header_names = frozenset(k.lower() for k in headers)\n        skips = {}\n        if 'host' in header_names:\n            skips['skip_host'] = 1\n        if 'accept-encoding' in header_names:\n            skips['skip_accept_encoding'] = 1\n    \n        self.putrequest(method, url, **skips)\n    \n        # chunked encoding will happen if HTTP/1.1 is used and either\n        # the caller passes encode_chunked=True or the following\n        # conditions hold:\n        # 1. content-length has not been explicitly set\n        # 2. the body is a file or iterable, but not a str or bytes-like\n        # 3. Transfer-Encoding has NOT been explicitly set by the caller\n    \n        if 'content-length' not in header_names:\n            # only chunk body if not explicitly set for backwards\n            # compatibility, assuming the client code is already handling the\n            # chunking\n            if 'transfer-encoding' not in header_names:\n                # if content-length cannot be automatically determined, fall\n                # back to chunked encoding\n                encode_chunked = False\n                content_length = self._get_content_length(body, method)\n                if content_length is None:\n                    if body is not None:\n                        if self.debuglevel > 0:\n                            print('Unable to determine size of %r' % body)\n                        encode_chunked = True\n                        self.putheader('Transfer-Encoding', 'chunked')\n                else:\n                    self.putheader('Content-Length', str(content_length))\n        else:\n            encode_chunked = False\n    \n        for hdr, value in headers.items():\n            self.putheader(hdr, value)\n        if isinstance(body, str):\n            # RFC 2616 Section 3.7.1 says that text default has a\n            # default charset of iso-8859-1.\n            body = _encode(body, 'body')\n>       self.endheaders(body, encode_chunked=encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1285: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd5992b0860>, message_body = None\n\n    def endheaders(self, message_body=None, *, encode_chunked=False):\n        \"\"\"Indicate that the last header line has been sent to the server.\n    \n        This method sends the request to the server.  The optional message_body\n        argument can be used to pass a message body associated with the\n        request.\n        \"\"\"\n        if self.__state == _CS_REQ_STARTED:\n            self.__state = _CS_REQ_SENT\n        else:\n            raise CannotSendHeader()\n>       self._send_output(message_body, encode_chunked=encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1234: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd5992b0860>, message_body = None, encode_chunked = False\n\n    def _send_output(self, message_body=None, encode_chunked=False):\n        \"\"\"Send the currently buffered request and clear the buffer.\n    \n        Appends an extra \\\\r\\\\n to the buffer.\n        A message_body may be specified, to be appended to the request.\n        \"\"\"\n        self._buffer.extend((b\"\", b\"\"))\n        msg = b\"\\r\\n\".join(self._buffer)\n        del self._buffer[:]\n>       self.send(msg)\n\n/usr/lib/python3.6/http/client.py:1026: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd5992b0860>\ndata = b'GET /batches HTTP/1.1\\r\\nAccept-Encoding: identity\\r\\nHost: 192.168.1.23:8008\\r\\nUser-Agent: Python-urllib/3.6\\r\\nConnection: close\\r\\n\\r\\n'\n\n    def send(self, data):\n        \"\"\"Send `data' to the server.\n        ``data`` can be a string object, a bytes object, an array object, a\n        file-like object that supports a .read() method, or an iterable object.\n        \"\"\"\n    \n        if self.sock is None:\n            if self.auto_open:\n>               self.connect()\n\n/usr/lib/python3.6/http/client.py:964: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd5992b0860>\n\n    def connect(self):\n        \"\"\"Connect to the host and port specified in __init__.\"\"\"\n        self.sock = self._create_connection(\n>           (self.host,self.port), self.timeout, self.source_address)\n\n/usr/lib/python3.6/http/client.py:936: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('192.168.1.23', 8008), timeout = <object object at 0x7fd5a15eb580>, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n                sock.connect(sa)\n                # Break explicitly a reference cycle\n                err = None\n                return sock\n    \n            except error as _:\n                err = _\n                if sock is not None:\n                    sock.close()\n    \n        if err is not None:\n>           raise err\n\n/usr/lib/python3.6/socket.py:724: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('192.168.1.23', 8008), timeout = <object object at 0x7fd5a15eb580>, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [Errno 111] Connection refused\n\n/usr/lib/python3.6/socket.py:713: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nrequest = <SubRequest 'setup_valid_txns' for <Function test_api_sent_commit_txns>>\n\n    @pytest.fixture(scope=\"function\")\n    def setup_valid_txns(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        Txns=Transactions(invalidtype=\"addr\")\n>       data = Txns.get_batch_valid_txns()\n\nfixtures.py:230: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npayload.py:323: in get_batch_valid_txns\n    self.data = self.get_txns_commit_data(txns,self.signer, self.data)\npayload.py:360: in get_txns_commit_data\n    initial_batch_length = batch_count()\nutils.py:377: in batch_count\n    batch_list = get_batches()\nutils.py:92: in get_batches\n    response = query_rest_api('/batches')\nutils.py:183: in query_rest_api\n    return submit_request(urllib.request.Request(url, data, headers))\nutils.py:186: in submit_request\n    response = urllib.request.urlopen(request).read().decode('utf-8')\n/usr/lib/python3.6/urllib/request.py:223: in urlopen\n    return opener.open(url, data, timeout)\n/usr/lib/python3.6/urllib/request.py:526: in open\n    response = self._open(req, data)\n/usr/lib/python3.6/urllib/request.py:544: in _open\n    '_open', req)\n/usr/lib/python3.6/urllib/request.py:504: in _call_chain\n    result = func(*args)\n/usr/lib/python3.6/urllib/request.py:1346: in http_open\n    return self.do_open(http.client.HTTPConnection, req)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib.request.HTTPHandler object at 0x7fd599cb66d8>, http_class = <class 'http.client.HTTPConnection'>, req = <urllib.request.Request object at 0x7fd5997c8dd8>\nhttp_conn_args = {}, host = '192.168.1.23:8008', h = <http.client.HTTPConnection object at 0x7fd5992b0860>\n\n    def do_open(self, http_class, req, **http_conn_args):\n        \"\"\"Return an HTTPResponse object for the request, using http_class.\n    \n        http_class must implement the HTTPConnection API from http.client.\n        \"\"\"\n        host = req.host\n        if not host:\n            raise URLError('no host given')\n    \n        # will parse host:port\n        h = http_class(host, timeout=req.timeout, **http_conn_args)\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # TODO(jhylton): Should this be redesigned to handle\n        # persistent connections?\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict((name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            try:\n                h.request(req.get_method(), req.selector, req.data, headers,\n                          encode_chunked=req.has_header('Transfer-encoding'))\n            except OSError as err: # timeout error\n>               raise URLError(err)\nE               urllib.error.URLError: <urlopen error [Errno 111] Connection refused>\n\n/usr/lib/python3.6/urllib/request.py:1320: URLError"}, "teardown": {"duration": 0.00030040740966796875, "outcome": "passed"}}, {"nodeid": "post/test_rest_api_post.py::TestPostInvalidTxns::test_txn_invalid_bad_addr", "lineno": 595, "outcome": "error", "keywords": ["run", "post/test_rest_api_post.py", "post", "last", "api_test", "test_txn_invalid_bad_addr", "TestPostInvalidTxns", "()"], "metadata": {"0": "Tests that transactions are submitted and committed for\neach block that are created by submitting intkey batches\nwith set operations", "1": "\"Tests rest api by posting no batches\n        ", "2": "Tests rest api by posting with bad protobuf\n        ", "3": "Tests rest api by posting with wrong header\n        ", "4": "Tests the rest-api by submitting multiple transactions with same key\n        ", "5": "Tests rest-api state by submitting multiple\ntransactions in multiple batches", "6": "Tests rest-api state by submitting\ntransactions in empty transaction list", "7": "Tests rest-api state by submitting \ntransactions with different signer ", "8": "Tests rest-api state by submitting\ntransactions with no endpoint", "9": "Tests rest-api state by submitting invalid \ntransactions with invalid address ", "10": "Tests rest-api state by submitting invalid \ntransactions with minimum address length ", "11": "Tests rest-api state by submitting invalid \ntransactions with maximum address length ", "12": "Tests rest-api state by submitting valid \ntransactions with invalid transactions", "13": "Tests rest-api state by submitting invalid \ntransactions with valid transactions", "14": "Tests rest-api state by submitting invalid \ntransactions with same transactions", "15": "Tests rest-api state by submitting invalid \ntransactions with commit transactions", "16": "Tests rest-api state by submitting invalid \ntransactions with invalid bad  address ", "17": "Tests rest-api state by submitting invalid \ntransactions with invalid family name"}, "setup": {"duration": 0.026375293731689453, "outcome": "failed", "crash": {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1320, "message": "urllib.error.URLError: <urlopen error [Errno 111] Connection refused>"}, "traceback": [{"path": "fixtures.py", "lineno": 193, "message": ""}, {"path": "payload.py", "lineno": 301, "message": "in get_batch_invalid_txns"}, {"path": "payload.py", "lineno": 360, "message": "in get_txns_commit_data"}, {"path": "utils.py", "lineno": 377, "message": "in batch_count"}, {"path": "utils.py", "lineno": 92, "message": "in get_batches"}, {"path": "utils.py", "lineno": 183, "message": "in query_rest_api"}, {"path": "utils.py", "lineno": 186, "message": "in submit_request"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 223, "message": "in urlopen"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 526, "message": "in open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 544, "message": "in _open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 504, "message": "in _call_chain"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1346, "message": "in http_open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1320, "message": "URLError"}], "longrepr": "self = <urllib.request.HTTPHandler object at 0x7fd599cb66d8>, http_class = <class 'http.client.HTTPConnection'>, req = <urllib.request.Request object at 0x7fd5995953c8>\nhttp_conn_args = {}, host = '192.168.1.23:8008', h = <http.client.HTTPConnection object at 0x7fd5995955c0>\n\n    def do_open(self, http_class, req, **http_conn_args):\n        \"\"\"Return an HTTPResponse object for the request, using http_class.\n    \n        http_class must implement the HTTPConnection API from http.client.\n        \"\"\"\n        host = req.host\n        if not host:\n            raise URLError('no host given')\n    \n        # will parse host:port\n        h = http_class(host, timeout=req.timeout, **http_conn_args)\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # TODO(jhylton): Should this be redesigned to handle\n        # persistent connections?\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict((name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            try:\n                h.request(req.get_method(), req.selector, req.data, headers,\n>                         encode_chunked=req.has_header('Transfer-encoding'))\n\n/usr/lib/python3.6/urllib/request.py:1318: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd5995955c0>, method = 'GET', url = '/batches', body = None\nheaders = {'Connection': 'close', 'Host': '192.168.1.23:8008', 'User-Agent': 'Python-urllib/3.6'}\n\n    def request(self, method, url, body=None, headers={}, *,\n                encode_chunked=False):\n        \"\"\"Send a complete request to the server.\"\"\"\n>       self._send_request(method, url, body, headers, encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1239: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd5995955c0>, method = 'GET', url = '/batches', body = None\nheaders = {'Connection': 'close', 'Host': '192.168.1.23:8008', 'User-Agent': 'Python-urllib/3.6'}, encode_chunked = False\n\n    def _send_request(self, method, url, body, headers, encode_chunked):\n        # Honor explicitly requested Host: and Accept-Encoding: headers.\n        header_names = frozenset(k.lower() for k in headers)\n        skips = {}\n        if 'host' in header_names:\n            skips['skip_host'] = 1\n        if 'accept-encoding' in header_names:\n            skips['skip_accept_encoding'] = 1\n    \n        self.putrequest(method, url, **skips)\n    \n        # chunked encoding will happen if HTTP/1.1 is used and either\n        # the caller passes encode_chunked=True or the following\n        # conditions hold:\n        # 1. content-length has not been explicitly set\n        # 2. the body is a file or iterable, but not a str or bytes-like\n        # 3. Transfer-Encoding has NOT been explicitly set by the caller\n    \n        if 'content-length' not in header_names:\n            # only chunk body if not explicitly set for backwards\n            # compatibility, assuming the client code is already handling the\n            # chunking\n            if 'transfer-encoding' not in header_names:\n                # if content-length cannot be automatically determined, fall\n                # back to chunked encoding\n                encode_chunked = False\n                content_length = self._get_content_length(body, method)\n                if content_length is None:\n                    if body is not None:\n                        if self.debuglevel > 0:\n                            print('Unable to determine size of %r' % body)\n                        encode_chunked = True\n                        self.putheader('Transfer-Encoding', 'chunked')\n                else:\n                    self.putheader('Content-Length', str(content_length))\n        else:\n            encode_chunked = False\n    \n        for hdr, value in headers.items():\n            self.putheader(hdr, value)\n        if isinstance(body, str):\n            # RFC 2616 Section 3.7.1 says that text default has a\n            # default charset of iso-8859-1.\n            body = _encode(body, 'body')\n>       self.endheaders(body, encode_chunked=encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1285: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd5995955c0>, message_body = None\n\n    def endheaders(self, message_body=None, *, encode_chunked=False):\n        \"\"\"Indicate that the last header line has been sent to the server.\n    \n        This method sends the request to the server.  The optional message_body\n        argument can be used to pass a message body associated with the\n        request.\n        \"\"\"\n        if self.__state == _CS_REQ_STARTED:\n            self.__state = _CS_REQ_SENT\n        else:\n            raise CannotSendHeader()\n>       self._send_output(message_body, encode_chunked=encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1234: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd5995955c0>, message_body = None, encode_chunked = False\n\n    def _send_output(self, message_body=None, encode_chunked=False):\n        \"\"\"Send the currently buffered request and clear the buffer.\n    \n        Appends an extra \\\\r\\\\n to the buffer.\n        A message_body may be specified, to be appended to the request.\n        \"\"\"\n        self._buffer.extend((b\"\", b\"\"))\n        msg = b\"\\r\\n\".join(self._buffer)\n        del self._buffer[:]\n>       self.send(msg)\n\n/usr/lib/python3.6/http/client.py:1026: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd5995955c0>\ndata = b'GET /batches HTTP/1.1\\r\\nAccept-Encoding: identity\\r\\nHost: 192.168.1.23:8008\\r\\nUser-Agent: Python-urllib/3.6\\r\\nConnection: close\\r\\n\\r\\n'\n\n    def send(self, data):\n        \"\"\"Send `data' to the server.\n        ``data`` can be a string object, a bytes object, an array object, a\n        file-like object that supports a .read() method, or an iterable object.\n        \"\"\"\n    \n        if self.sock is None:\n            if self.auto_open:\n>               self.connect()\n\n/usr/lib/python3.6/http/client.py:964: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd5995955c0>\n\n    def connect(self):\n        \"\"\"Connect to the host and port specified in __init__.\"\"\"\n        self.sock = self._create_connection(\n>           (self.host,self.port), self.timeout, self.source_address)\n\n/usr/lib/python3.6/http/client.py:936: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('192.168.1.23', 8008), timeout = <object object at 0x7fd5a15eb580>, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n                sock.connect(sa)\n                # Break explicitly a reference cycle\n                err = None\n                return sock\n    \n            except error as _:\n                err = _\n                if sock is not None:\n                    sock.close()\n    \n        if err is not None:\n>           raise err\n\n/usr/lib/python3.6/socket.py:724: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('192.168.1.23', 8008), timeout = <object object at 0x7fd5a15eb580>, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [Errno 111] Connection refused\n\n/usr/lib/python3.6/socket.py:713: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nrequest = <SubRequest 'setup_invalid_invaddr' for <Function test_txn_invalid_bad_addr>>\n\n    @pytest.fixture(scope=\"function\")\n    def setup_invalid_invaddr(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        Txns=Transactions(invalidtype=\"invaddr\")\n>       data = Txns.get_batch_invalid_txns()\n\nfixtures.py:193: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npayload.py:301: in get_batch_invalid_txns\n    self.data = self.get_txns_commit_data(txns,self.signer, self.data)\npayload.py:360: in get_txns_commit_data\n    initial_batch_length = batch_count()\nutils.py:377: in batch_count\n    batch_list = get_batches()\nutils.py:92: in get_batches\n    response = query_rest_api('/batches')\nutils.py:183: in query_rest_api\n    return submit_request(urllib.request.Request(url, data, headers))\nutils.py:186: in submit_request\n    response = urllib.request.urlopen(request).read().decode('utf-8')\n/usr/lib/python3.6/urllib/request.py:223: in urlopen\n    return opener.open(url, data, timeout)\n/usr/lib/python3.6/urllib/request.py:526: in open\n    response = self._open(req, data)\n/usr/lib/python3.6/urllib/request.py:544: in _open\n    '_open', req)\n/usr/lib/python3.6/urllib/request.py:504: in _call_chain\n    result = func(*args)\n/usr/lib/python3.6/urllib/request.py:1346: in http_open\n    return self.do_open(http.client.HTTPConnection, req)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib.request.HTTPHandler object at 0x7fd599cb66d8>, http_class = <class 'http.client.HTTPConnection'>, req = <urllib.request.Request object at 0x7fd5995953c8>\nhttp_conn_args = {}, host = '192.168.1.23:8008', h = <http.client.HTTPConnection object at 0x7fd5995955c0>\n\n    def do_open(self, http_class, req, **http_conn_args):\n        \"\"\"Return an HTTPResponse object for the request, using http_class.\n    \n        http_class must implement the HTTPConnection API from http.client.\n        \"\"\"\n        host = req.host\n        if not host:\n            raise URLError('no host given')\n    \n        # will parse host:port\n        h = http_class(host, timeout=req.timeout, **http_conn_args)\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # TODO(jhylton): Should this be redesigned to handle\n        # persistent connections?\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict((name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            try:\n                h.request(req.get_method(), req.selector, req.data, headers,\n                          encode_chunked=req.has_header('Transfer-encoding'))\n            except OSError as err: # timeout error\n>               raise URLError(err)\nE               urllib.error.URLError: <urlopen error [Errno 111] Connection refused>\n\n/usr/lib/python3.6/urllib/request.py:1320: URLError"}, "teardown": {"duration": 0.00027751922607421875, "outcome": "passed"}}, {"nodeid": "post/test_rest_api_post.py::TestPostInvalidTxns::test_txn_invalid_family_name", "lineno": 606, "outcome": "error", "keywords": ["run", "post/test_rest_api_post.py", "post", "last", "api_test", "test_txn_invalid_family_name", "TestPostInvalidTxns", "()"], "metadata": {"0": "Tests that transactions are submitted and committed for\neach block that are created by submitting intkey batches\nwith set operations", "1": "\"Tests rest api by posting no batches\n        ", "2": "Tests rest api by posting with bad protobuf\n        ", "3": "Tests rest api by posting with wrong header\n        ", "4": "Tests the rest-api by submitting multiple transactions with same key\n        ", "5": "Tests rest-api state by submitting multiple\ntransactions in multiple batches", "6": "Tests rest-api state by submitting\ntransactions in empty transaction list", "7": "Tests rest-api state by submitting \ntransactions with different signer ", "8": "Tests rest-api state by submitting\ntransactions with no endpoint", "9": "Tests rest-api state by submitting invalid \ntransactions with invalid address ", "10": "Tests rest-api state by submitting invalid \ntransactions with minimum address length ", "11": "Tests rest-api state by submitting invalid \ntransactions with maximum address length ", "12": "Tests rest-api state by submitting valid \ntransactions with invalid transactions", "13": "Tests rest-api state by submitting invalid \ntransactions with valid transactions", "14": "Tests rest-api state by submitting invalid \ntransactions with same transactions", "15": "Tests rest-api state by submitting invalid \ntransactions with commit transactions", "16": "Tests rest-api state by submitting invalid \ntransactions with invalid bad  address ", "17": "Tests rest-api state by submitting invalid \ntransactions with invalid family name"}, "setup": {"duration": 0.0263669490814209, "outcome": "failed", "crash": {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1320, "message": "urllib.error.URLError: <urlopen error [Errno 111] Connection refused>"}, "traceback": [{"path": "fixtures.py", "lineno": 239, "message": ""}, {"path": "payload.py", "lineno": 349, "message": "in get_batch_invalid_txns_fam_name"}, {"path": "payload.py", "lineno": 360, "message": "in get_txns_commit_data"}, {"path": "utils.py", "lineno": 377, "message": "in batch_count"}, {"path": "utils.py", "lineno": 92, "message": "in get_batches"}, {"path": "utils.py", "lineno": 183, "message": "in query_rest_api"}, {"path": "utils.py", "lineno": 186, "message": "in submit_request"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 223, "message": "in urlopen"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 526, "message": "in open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 544, "message": "in _open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 504, "message": "in _call_chain"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1346, "message": "in http_open"}, {"path": "/usr/lib/python3.6/urllib/request.py", "lineno": 1320, "message": "URLError"}], "longrepr": "self = <urllib.request.HTTPHandler object at 0x7fd599cb66d8>, http_class = <class 'http.client.HTTPConnection'>, req = <urllib.request.Request object at 0x7fd599845518>\nhttp_conn_args = {}, host = '192.168.1.23:8008', h = <http.client.HTTPConnection object at 0x7fd599845ef0>\n\n    def do_open(self, http_class, req, **http_conn_args):\n        \"\"\"Return an HTTPResponse object for the request, using http_class.\n    \n        http_class must implement the HTTPConnection API from http.client.\n        \"\"\"\n        host = req.host\n        if not host:\n            raise URLError('no host given')\n    \n        # will parse host:port\n        h = http_class(host, timeout=req.timeout, **http_conn_args)\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # TODO(jhylton): Should this be redesigned to handle\n        # persistent connections?\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict((name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            try:\n                h.request(req.get_method(), req.selector, req.data, headers,\n>                         encode_chunked=req.has_header('Transfer-encoding'))\n\n/usr/lib/python3.6/urllib/request.py:1318: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599845ef0>, method = 'GET', url = '/batches', body = None\nheaders = {'Connection': 'close', 'Host': '192.168.1.23:8008', 'User-Agent': 'Python-urllib/3.6'}\n\n    def request(self, method, url, body=None, headers={}, *,\n                encode_chunked=False):\n        \"\"\"Send a complete request to the server.\"\"\"\n>       self._send_request(method, url, body, headers, encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1239: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599845ef0>, method = 'GET', url = '/batches', body = None\nheaders = {'Connection': 'close', 'Host': '192.168.1.23:8008', 'User-Agent': 'Python-urllib/3.6'}, encode_chunked = False\n\n    def _send_request(self, method, url, body, headers, encode_chunked):\n        # Honor explicitly requested Host: and Accept-Encoding: headers.\n        header_names = frozenset(k.lower() for k in headers)\n        skips = {}\n        if 'host' in header_names:\n            skips['skip_host'] = 1\n        if 'accept-encoding' in header_names:\n            skips['skip_accept_encoding'] = 1\n    \n        self.putrequest(method, url, **skips)\n    \n        # chunked encoding will happen if HTTP/1.1 is used and either\n        # the caller passes encode_chunked=True or the following\n        # conditions hold:\n        # 1. content-length has not been explicitly set\n        # 2. the body is a file or iterable, but not a str or bytes-like\n        # 3. Transfer-Encoding has NOT been explicitly set by the caller\n    \n        if 'content-length' not in header_names:\n            # only chunk body if not explicitly set for backwards\n            # compatibility, assuming the client code is already handling the\n            # chunking\n            if 'transfer-encoding' not in header_names:\n                # if content-length cannot be automatically determined, fall\n                # back to chunked encoding\n                encode_chunked = False\n                content_length = self._get_content_length(body, method)\n                if content_length is None:\n                    if body is not None:\n                        if self.debuglevel > 0:\n                            print('Unable to determine size of %r' % body)\n                        encode_chunked = True\n                        self.putheader('Transfer-Encoding', 'chunked')\n                else:\n                    self.putheader('Content-Length', str(content_length))\n        else:\n            encode_chunked = False\n    \n        for hdr, value in headers.items():\n            self.putheader(hdr, value)\n        if isinstance(body, str):\n            # RFC 2616 Section 3.7.1 says that text default has a\n            # default charset of iso-8859-1.\n            body = _encode(body, 'body')\n>       self.endheaders(body, encode_chunked=encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1285: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599845ef0>, message_body = None\n\n    def endheaders(self, message_body=None, *, encode_chunked=False):\n        \"\"\"Indicate that the last header line has been sent to the server.\n    \n        This method sends the request to the server.  The optional message_body\n        argument can be used to pass a message body associated with the\n        request.\n        \"\"\"\n        if self.__state == _CS_REQ_STARTED:\n            self.__state = _CS_REQ_SENT\n        else:\n            raise CannotSendHeader()\n>       self._send_output(message_body, encode_chunked=encode_chunked)\n\n/usr/lib/python3.6/http/client.py:1234: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599845ef0>, message_body = None, encode_chunked = False\n\n    def _send_output(self, message_body=None, encode_chunked=False):\n        \"\"\"Send the currently buffered request and clear the buffer.\n    \n        Appends an extra \\\\r\\\\n to the buffer.\n        A message_body may be specified, to be appended to the request.\n        \"\"\"\n        self._buffer.extend((b\"\", b\"\"))\n        msg = b\"\\r\\n\".join(self._buffer)\n        del self._buffer[:]\n>       self.send(msg)\n\n/usr/lib/python3.6/http/client.py:1026: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599845ef0>\ndata = b'GET /batches HTTP/1.1\\r\\nAccept-Encoding: identity\\r\\nHost: 192.168.1.23:8008\\r\\nUser-Agent: Python-urllib/3.6\\r\\nConnection: close\\r\\n\\r\\n'\n\n    def send(self, data):\n        \"\"\"Send `data' to the server.\n        ``data`` can be a string object, a bytes object, an array object, a\n        file-like object that supports a .read() method, or an iterable object.\n        \"\"\"\n    \n        if self.sock is None:\n            if self.auto_open:\n>               self.connect()\n\n/usr/lib/python3.6/http/client.py:964: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x7fd599845ef0>\n\n    def connect(self):\n        \"\"\"Connect to the host and port specified in __init__.\"\"\"\n        self.sock = self._create_connection(\n>           (self.host,self.port), self.timeout, self.source_address)\n\n/usr/lib/python3.6/http/client.py:936: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('192.168.1.23', 8008), timeout = <object object at 0x7fd5a15eb580>, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n                sock.connect(sa)\n                # Break explicitly a reference cycle\n                err = None\n                return sock\n    \n            except error as _:\n                err = _\n                if sock is not None:\n                    sock.close()\n    \n        if err is not None:\n>           raise err\n\n/usr/lib/python3.6/socket.py:724: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('192.168.1.23', 8008), timeout = <object object at 0x7fd5a15eb580>, source_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [Errno 111] Connection refused\n\n/usr/lib/python3.6/socket.py:713: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nrequest = <SubRequest 'setup_invalid_txns_fn' for <Function test_txn_invalid_family_name>>\n\n    @pytest.fixture(scope=\"function\")\n    def setup_invalid_txns_fn(request):\n        \"\"\"Setup method for posting batches and returning the\n           response\n        \"\"\"\n        Txns=Transactions(invalidtype=\"fn\")\n>       data = Txns.get_batch_invalid_txns_fam_name()\n\nfixtures.py:239: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npayload.py:349: in get_batch_invalid_txns_fam_name\n    self.data = self.get_txns_commit_data(txns,self.signer, self.data)\npayload.py:360: in get_txns_commit_data\n    initial_batch_length = batch_count()\nutils.py:377: in batch_count\n    batch_list = get_batches()\nutils.py:92: in get_batches\n    response = query_rest_api('/batches')\nutils.py:183: in query_rest_api\n    return submit_request(urllib.request.Request(url, data, headers))\nutils.py:186: in submit_request\n    response = urllib.request.urlopen(request).read().decode('utf-8')\n/usr/lib/python3.6/urllib/request.py:223: in urlopen\n    return opener.open(url, data, timeout)\n/usr/lib/python3.6/urllib/request.py:526: in open\n    response = self._open(req, data)\n/usr/lib/python3.6/urllib/request.py:544: in _open\n    '_open', req)\n/usr/lib/python3.6/urllib/request.py:504: in _call_chain\n    result = func(*args)\n/usr/lib/python3.6/urllib/request.py:1346: in http_open\n    return self.do_open(http.client.HTTPConnection, req)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib.request.HTTPHandler object at 0x7fd599cb66d8>, http_class = <class 'http.client.HTTPConnection'>, req = <urllib.request.Request object at 0x7fd599845518>\nhttp_conn_args = {}, host = '192.168.1.23:8008', h = <http.client.HTTPConnection object at 0x7fd599845ef0>\n\n    def do_open(self, http_class, req, **http_conn_args):\n        \"\"\"Return an HTTPResponse object for the request, using http_class.\n    \n        http_class must implement the HTTPConnection API from http.client.\n        \"\"\"\n        host = req.host\n        if not host:\n            raise URLError('no host given')\n    \n        # will parse host:port\n        h = http_class(host, timeout=req.timeout, **http_conn_args)\n        h.set_debuglevel(self._debuglevel)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # TODO(jhylton): Should this be redesigned to handle\n        # persistent connections?\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict((name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            try:\n                h.request(req.get_method(), req.selector, req.data, headers,\n                          encode_chunked=req.has_header('Transfer-encoding'))\n            except OSError as err: # timeout error\n>               raise URLError(err)\nE               urllib.error.URLError: <urlopen error [Errno 111] Connection refused>\n\n/usr/lib/python3.6/urllib/request.py:1320: URLError"}, "teardown": {"duration": 0.0018510818481445312, "outcome": "passed"}}]}